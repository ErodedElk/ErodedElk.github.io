<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>VirtualApp原理速览 - Activity 原生启动流程 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>VirtualApp原理速览 - Activity 原生启动流程</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-05-23T18:41:16.000Z" id="date"> 2025-05-24</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-05-27T14:47:11.165Z" id="updated"> 2025-05-27</time></div></span></div></div><hr><div id="post-content"><h1 id="Activity-原生启动流程"><a href="#Activity-原生启动流程" class="headerlink" title="Activity 原生启动流程"></a>Activity 原生启动流程</h1><h2 id="系统界面-Launcher"><a href="#系统界面-Launcher" class="headerlink" title="系统界面 Launcher"></a>系统界面 Launcher</h2><p>为了解 VA 是如何启动 Activity 的，我们需要先知道 Android 是如何启动 Activity 的。在 Android 系统启动以后，系统已经启动了 Zygote，ServiceManager，SystemServer 等系统进程。</p>
<p><code>ServiceManager</code> 进程中完成了 <code>Binder</code> 初始化；<code>SystemServer</code> 进程中 ActivityManagerService，<code>WindowManagerService</code>，<code>PackageManagerService</code> 等系统服务在 <code>ServiceManager</code> 中已经注册；最后启动了 <code>Launcher</code> 桌面应用。</p>
<p class='item-img' data-src='/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/system_process.png'><img src="/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/system_process.png"></p>
<p><code>Launcher</code> 作为用户的交互界面，在用户点击 APP 图标的时候提供了打开应用的能力。不同的手机厂商可能会根据 <code>Launcher</code> 做一些定制，比如 <code>miui</code> 就是如此，但最终的原理是一致的。</p>
<p>应用安装的时候，通过 <code>PackageManagerService</code> 解析 apk 的 <code>AndroidManifest.xml</code> 文件，提取出这个 apk 的信息写入到 <code>packages.xml</code> 文件中，这些信息包括：权限、应用包名、icon、apk 的安装位置、版本、userID 等等。packages.xml 文件位于系统目录下&#x2F;data&#x2F;system&#x2F;packages.xml。</p>
<h2 id="启动应用流程"><a href="#启动应用流程" class="headerlink" title="启动应用流程"></a>启动应用流程</h2><p class='item-img' data-src='/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/launcherapp.png'><img src="/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/launcherapp.png"></p>
<p>当用户点击桌面上的应用图标后，Launcher 会通过 service_manager 向 AMS 服务发出请求，查询对应的 APP 信息，然后由 Zygote 创建目标 APP 进程。</p>
<p class='item-img' data-src='/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/android13.png'><img src="/images/virtualappquickreview/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/android13.png"></p>
<p>先梳理一下大致的流程：</p>
<ol>
<li>Launcher 通过 Binder 方式沟通 AMS </li>
<li>AMS 先检查这个 APP 进程是不是已经创建了</li>
<li>如果已经创建，则直接调用 <code>realStartActivityLocked</code> 直接到第 7 步</li>
<li>否则，AMS 接到请求后让 Zygote 通过 fork 创建 APP 进程，完成 <code>Application.onCreate</code> 、创建应用的上下文和其他各种必要对象，这些对象会在 AMS 中留有备份进行保留。</li>
<li>新创建的 APP 进程通过 Binder 发送 <code>ATTACH_APPLICATION_TRANSACTION</code> 通知 AMS </li>
<li>AMS 接到 <code>ATTACH_APPLICATION_TRANSACTION</code> 后调用 <code>realStartActivityLocked</code> </li>
<li>设置进程为顶部 Activity，为新进程创建事务发送调度命令 <code>H.EXECUTE_TRANSACTION</code></li>
<li>进程处理命令消息时调用 Activity.onCreate 并且初始化应用自己的视图</li>
</ol>
<p>具体到代码实现中，分为几个步骤，首先启动步骤从 Launcher 开始：</p>
<ol>
<li>检查将要打开的目标 APP 的 Activity 是否存在，如果存在就不需要打开了</li>
</ol>
<p><code>Launcher.startActivitySafel</code> -&gt; <code>Launcher.startActivity</code></p>
<ol start="2">
<li>打开目标 Activity</li>
</ol>
<p><code>Activity.startActivity</code></p>
<ol start="3">
<li>通过 ATSM 服务调用该服务提供的 startActivity</li>
</ol>
<p><code>Activity.startActivityForResult</code> - <code>Instrumentation.execStartActivity</code> - <code>ActivityTaskManager.getService().startActivity</code></p>
<p><code>ActivityManagerNative.getDefault()</code> 会返回一个 <code>ActivityManagerProxy</code> 作为 Launcher 中使用 <code>ActivityTaskManager</code> 的代理，该代理的 startActivity 会发送 <code>START_ACTIVITY_TRANSACTION</code> 来通知 <code>ActivityTaskManager</code></p>
<p>完成上述过程后，进程从 <code>Launcher</code> 切换到 <code>system_server</code> 中的 <code>ActivityManagerService</code>，也就是 AMS。</p>
<ol>
<li>在 startActivityAsUser 中会先获取用户的 UserID 作为参数然后往下调用 getActivityStartController 中的 starter</li>
</ol>
<p><code>startActivity</code> - <code>startActivityAsUser</code> </p>
<ol start="2">
<li>创建新的 intent 对象，获取 ApplicationPackageManager</li>
</ol>
<p><code>ActivityStackSupervisor.startActivityMayWait</code> - <code>resolveActivity</code></p>
<ol start="3">
<li>获取 intent 所指向的 Activity 信息，并保存到 Intent 对象。</li>
</ol>
<p><code>PackageManagerService.resolveIntent()</code>  - <code>queryIntentActivities()</code></p>
<ol start="4">
<li><p>获取到调用者的进程信息，通过 <code>Intent.FLAG_ACTIVITY_FORWARD_RESULT</code> 判断是否需要进行 <code>startActivityForResult</code> 处理。检查调用者是否有权限来调用指定的 Activity</p>
</li>
<li><p>Activity 有多种启动模式，对 launchMode 的处理，创建 Task 等操作。启动 Activity 所在进程，已存在则直接 <code>onResume()</code>，不存在则创建 Activity 并处理是否触发 <code>onNewIntent()</code>。</p>
</li>
</ol>
<p><code>ActivityStackSupervisor.startActivityUncheckedLocked</code> - <code>startActivityLocked</code></p>
<ol start="6">
<li>若找到 resume 状态的 Activity，执行 <code>startPausingLocked()</code> 暂停该 Activity，同时暂停所有处于后台栈的 Activity，这里一般来说会把桌面，也就是 Launcher 暂停掉。</li>
</ol>
<p><code>ActivityStack.resumeTopActivityInnerLocked</code></p>
<ol start="7">
<li>获取要启动的Activity进程信息，若成功，则表示进程已经启动了，通过 <code>realStartActivityLocked</code> 启动这个 activity；否则，通过 AMS 代理调用 startProcessAsync 去创建进程。前者的条件就是前面所述的目标 APP 已经启动过的情况，后者则是从头开始创建这个 APP 进程。</li>
</ol>
<p><code>ActivityStackSupervisor.startSpecificActivity</code></p>
<p>我们考虑后者的情况，程序将会往下调用 <code>startProcessAsync</code> 创建新进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">startProcessAsync</span><span class="hljs-params">(ActivityRecord activity, <span class="hljs-type">boolean</span> knownToBeDead, <span class="hljs-type">boolean</span> isTop,String hostingType)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>        <span class="hljs-comment">// 发布消息以启动进程，以避免在持有 ATMS 锁的情况下调用 AMS 可能出现死锁。</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,<br>                mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,<br>                isTop, hostingType, activity.intent.getComponent());<br>        mH.sendMessage(m);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>startProcessAsync 会通过消息的方式让 ATMS 服务在处理该消息时创建对应的进程，调用目标为 <code>ActivityManagerInternal::startProcess</code></p>
<p>而 <code>ActivityManagerInternal::startProcess</code> 调用<code>ActivityManagerService::startProcessLocked</code> 调用 <code>ProcessList::startProcessLocked</code> 调用 <code>ProcessList::startProcess</code></p>
<p>如果目标进程是 top app，设置 flag 保证启动的最高优先级，并最终在 startProcess 中创建对应的目标进程，也就是 APP 的进程。</p>
<p>在进程创建成功后，将当前进程切换到新进程，并将 <code>ActivityThread</code> 类加载到新进程，调用 <code>ActivityThread.main</code></p>
<ol>
<li><code>ActivityThread.main</code> ：创建主线程的 Looper 对象，创建 <code>ActivityThread</code> 对象，<code>ActivityThread.attach()</code> 建立 Binder 通道，开启 <code>Looper.loop()</code> 消息循环</li>
<li><code>ActivityThread.attach</code>：创建 <code>ActivityManagerProxy</code> 对象，调用基于 <code>IActivityManager</code> 接口的 Binder 通道 <code>ActivityManagerProxy.attachApplication()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ...<br>    <span class="hljs-comment">//初始化当前进程的 Looper 对象</span><br>    Looper.prepareMainLooper();<br>    ...<br>    <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>    <span class="hljs-comment">//此处创建Application</span><br>    thread.attach(<span class="hljs-literal">false</span>, startSeq);<br> <br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>    &#125;<br> <br>    <span class="hljs-comment">// 调用 Looper 的 loop 方法开启无限循环。</span><br>    Looper.loop();<br> <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Looper 会持续从消息队列中获取消息，然后处理指定的任务。其中，attach 函数调用时会发送 <code>ATTACH_APPLICATION_TRANSACTION</code> 通知 system_server 中的服务。</p>
<p>此时，应用的 <code>ActivityThread</code> 和 <code>ApplicationThread</code> 已经被创建，并创建了消息循环机制。当调用 <code>ActivityThread.attach</code> 时，内部会调用 <code>ActivityManagerProxy.attachApplication</code> ，通过 Binder 来调用 AMS 中的 <code>attachApplication</code> 函数，此时会把 <code>ApplicationThread</code> 传递过去。</p>
<p><code>attachApplication</code> - <code>attachApplicationLocked</code> 主要有两个关键函数需要关注：</p>
<ul>
<li>bindApplication</li>
<li>ActivityTaskManagerService.LocalService#attachApplication</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attachApplicationLocked</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IApplicationThread thread,</span><br><span class="hljs-params">                                        <span class="hljs-type">int</span> pid, <span class="hljs-type">int</span> callingUid, <span class="hljs-type">long</span> startSeq)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (mProcLock) &#123;<br>        app.mState.setCurAdj(ProcessList.INVALID_ADJ);<br>        app.mState.setSetAdj(ProcessList.INVALID_ADJ);<br>        app.mState.setVerifiedAdj(ProcessList.INVALID_ADJ);<br>        mOomAdjuster.setAttachingSchedGroupLSP(app);<br>        app.mState.setForcingToImportant(<span class="hljs-literal">null</span>);<br>        updateProcessForegroundLocked(app, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>);<br>        app.mState.setHasShownUi(<span class="hljs-literal">false</span>);<br>        app.mState.setCached(<span class="hljs-literal">false</span>);<br>        app.setDebugging(<span class="hljs-literal">false</span>);<br>        app.setKilledByAm(<span class="hljs-literal">false</span>);<br>        app.setKilled(<span class="hljs-literal">false</span>);<br>        app.setUnlocked(StorageManager.isUserKeyUnlocked(app.userId));<br>    &#125;<br>    <span class="hljs-comment">// 移除进程超时信息</span><br>    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ProviderInfoList</span> <span class="hljs-variable">providerList</span> <span class="hljs-operator">=</span> ProviderInfoList.fromList(providers);<br>    <span class="hljs-keyword">if</span> (app.getIsolatedEntryPoint() != <span class="hljs-literal">null</span>) &#123;<br>        thread.runIsolatedEntryPoint(<br>            app.getIsolatedEntryPoint(), app.getIsolatedEntryPointArgs());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instr2 != <span class="hljs-literal">null</span>) &#123;<br>        thread.bindApplication(processName, appInfo,<br>                               app.sdkSandboxClientAppVolumeUuid, app.sdkSandboxClientAppPackage,<br>                               providerList,<br>                               instr2.mClass,<br>                               profilerInfo, instr2.mArguments,<br>                               instr2.mWatcher,<br>                               instr2.mUiAutomationConnection, testMode,<br>                               mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                               isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>                               app.getCompat(), getCommonServicesLocked(app.isolated),<br>                               mCoreSettingsObserver.getCoreSettingsLocked(),<br>                               buildSerial, autofillOptions, contentCaptureOptions,<br>                               app.getDisabledCompatChanges(), serializedSystemFontMap,<br>                               app.getStartElapsedTime(), app.getStartUptime());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        thread.bindApplication(processName, appInfo,<br>                               app.sdkSandboxClientAppVolumeUuid, app.sdkSandboxClientAppPackage,<br>                               providerList, <span class="hljs-literal">null</span>, profilerInfo, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, testMode,<br>                               mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                               isRestrictedBackupMode || !normalMode, app.isPersistent(),<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),<br>                               app.getCompat(), getCommonServicesLocked(app.isolated),<br>                               mCoreSettingsObserver.getCoreSettingsLocked(),<br>                               buildSerial, autofillOptions, contentCaptureOptions,<br>                               app.getDisabledCompatChanges(), serializedSystemFontMap,<br>                               app.getStartElapsedTime(), app.getStartUptime());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (normalMode) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 最终调用ActivityTaskManagerService.LocalService#attachApplication()</span><br>            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们先关注 <code>thread.bindApplication</code> ，thread 就是刚刚由新进程传过来的。</p>
<p>函数先调用 <code>bindApplication</code> 向进程发送 <code>H.BIND_APPLICATION</code> 命令，进程收到该命令后，通过 <code>handleBindApplication</code> 处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;    <br>    <span class="hljs-comment">// 初始化context</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);       <br>    <span class="hljs-comment">// 初始化Instrumentation</span><br>    <span class="hljs-keyword">if</span> (ii != <span class="hljs-literal">null</span>) &#123;<br>        initInstrumentation(ii, data, appContext);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInstrumentation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instrumentation</span>();<br>        mInstrumentation.basicInit(<span class="hljs-built_in">this</span>);<br>    &#125;    <br>    Application app; <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 初始化Application</span><br>        <span class="hljs-comment">// 调用LoadedApk#makeApplicationInner()</span><br>        app = data.info.makeApplicationInner(data.restrictedBackupMode, <span class="hljs-literal">null</span>);           <br>        mInstrumentation.onCreate(data.instrumentationArgs);        <br>        <span class="hljs-comment">// 回调Application#onCreate()</span><br>        mInstrumentation.callApplicationOnCreate(app);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>handleBindApplication</code> 初始化 <code>context</code>，然后初始化 <code>Instrumentation</code> 对象，创建 <code>Application</code> 对象，并调用该对象的 <code>onCreate</code></p>
<p>初始化流程调用链为 <code>makeApplication</code> - <code>newApplication</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> &#123;    <br>    <span class="hljs-comment">// 初始化context</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);       <br>    <span class="hljs-comment">// 初始化Instrumentation</span><br>    <span class="hljs-keyword">if</span> (ii != <span class="hljs-literal">null</span>) &#123;<br>        initInstrumentation(ii, data, appContext);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mInstrumentation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instrumentation</span>();<br>        mInstrumentation.basicInit(<span class="hljs-built_in">this</span>);<br>    &#125;    <br>    Application app; <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 初始化Application</span><br>        <span class="hljs-comment">// 调用LoadedApk#makeApplicationInner()</span><br>        app = data.info.makeApplicationInner(data.restrictedBackupMode, <span class="hljs-literal">null</span>);           <br>        mInstrumentation.onCreate(data.instrumentationArgs);        <br>        <span class="hljs-comment">// 回调Application#onCreate()</span><br>        mInstrumentation.callApplicationOnCreate(app);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">makeApplication</span><span class="hljs-params">(<span class="hljs-type">boolean</span> forceDefaultAppClass,Instrumentation instrumentation)</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-literal">null</span>) &#123;   <br>       <span class="hljs-keyword">return</span> mApplication;<br>    &#125;<br>    <br>    <span class="hljs-type">String</span> <span class="hljs-variable">appClass</span> <span class="hljs-operator">=</span> mApplicationInfo.className;<br>    java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> getClassLoader();<br>    <br>    <span class="hljs-comment">//此时新建一个 Application 的 ContextImpl 对象，</span><br>    <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(mActivityThread, <span class="hljs-built_in">this</span>);<br>    <br>    <span class="hljs-comment">//通过在 handleBindApplication 创建的 mInstrumentation 对象新建一个 Application 对象，同时进行 attach。</span><br>    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);<br>    appContext.setOuterContext(app);<br>&#125;<br><br><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">newApplication</span><span class="hljs-params">(ClassLoader cl, String className, Context context)</span> &#123;    <br>    <span class="hljs-keyword">return</span> newApplication(cl.loadClass(className), context);<br>&#125;<br>Instrumentation类：<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> Application <span class="hljs-title function_">newApplication</span><span class="hljs-params">(Class&lt;?&gt; clazz, Context context)</span>  &#123;<br>    <span class="hljs-comment">//实例化 Application</span><br>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> (Application)clazz.newInstance();     <br>    <br>    <span class="hljs-comment">// Application 和 context绑定</span><br>    app.attach(context);    <br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><span class="hljs-comment">//attach 就是将新建的 ContextImpl 赋值到 mBase，这个 ContextImpl 对象就是所有Application 内 Context 的具体实现，同时赋值一些其他的信息如 mLoadedApk。</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Context context)</span> &#123;    <br>    mBase = base;  <br>    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>然后是 <code>makeApplicationInner</code> 的细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Application <span class="hljs-title function_">makeApplicationInner</span><span class="hljs-params">(<span class="hljs-type">boolean</span> forceDefaultAppClass,</span><br><span class="hljs-params">                                        Instrumentation instrumentation)</span> &#123;<br>    <span class="hljs-keyword">return</span> makeApplicationInner(forceDefaultAppClass, instrumentation, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> Application <span class="hljs-title function_">makeApplicationInner</span><span class="hljs-params">(<span class="hljs-type">boolean</span> forceDefaultAppClass,</span><br><span class="hljs-params">                                         Instrumentation instrumentation, <span class="hljs-type">boolean</span> allowDuplicateInstances)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> mApplication;<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (sApplications) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Application</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> sApplications.get(mPackageName);<br>        <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!allowDuplicateInstances) &#123;<br>                mApplication = cached;<br>                <span class="hljs-keyword">return</span> cached;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">myProcessName</span> <span class="hljs-operator">=</span> Process.myProcessName();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">appClass</span> <span class="hljs-operator">=</span> mApplicationInfo.getCustomApplicationClassNameForProcess(<br>        myProcessName);<br><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> getClassLoader();<br>        <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">&quot;android&quot;</span>)) &#123; <br>            initializeJavaContextClassLoader(); <br>        &#125;<br>        <span class="hljs-comment">// 初始化Application的上下文</span><br>        <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(mActivityThread, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 创建Application实例</span><br>        app = mActivityThread.mInstrumentation.newApplication(<br>            cl, appClass, appContext);<br>        appContext.setOuterContext(app);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>    mActivityThread.mAllApplications.add(app);<br>    mApplication = app;<br>    <span class="hljs-keyword">if</span> (!allowDuplicateInstances) &#123;<br>        <span class="hljs-keyword">synchronized</span> (sApplications) &#123;<br>            sApplications.put(mPackageName, app);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instrumentation != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 回调Application#onCreate()</span><br>            instrumentation.callApplicationOnCreate(app);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于新创建的这个进程而言，当 <code>callApplicationOnCreate</code> 完成调用以后，这个进程的上下文，以及 <code>Application</code> 对象和 <code>Instrumentation</code> 对象都完成的创建和初始化。而在进程这波完成上述的初始化过程中，AMS 那边也没闲着，在发送完相应的命令以后， <code>ActivityManagerService#attachApplicationLocked</code> 继续往下调用 <code> ActivityTaskManagerService.LocalService#attachApplication</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(WindowProcessController wpc)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用RootWindowContainer#attachApplication()</span><br>            <span class="hljs-comment">// 最终调用AttachApplicationHelper#test()</span><br>            <span class="hljs-keyword">return</span> mRootWindowContainer.attachApplication(wpc);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;           <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(ActivityRecord r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (r.finishing || !r.showToCurrentUser() || !r.visibleIgnoringKeyguard<br>            || r.app != <span class="hljs-literal">null</span> || mApp.mUid != r.info.applicationInfo.uid<br>            || !mApp.mName.equals(r.processName)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用ActivityTaskSupervisor#realStartActivityLocked()</span><br>        <span class="hljs-keyword">if</span> (mTaskSupervisor.realStartActivityLocked(r, mApp,<br>                mTop == r &amp;&amp; r.getTask().canBeResumed(r) <span class="hljs-comment">/* andResume */</span>,<br>                <span class="hljs-literal">true</span> <span class="hljs-comment">/* checkConfig */</span>)) &#123;<br>            mHasActivityStarted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以注意到，最终这个函数将往下执行 <code>ActivityTaskSupervisor#realStartActivityLocked</code> 完成最后的步骤。而如果<strong>此前不需要创建新进程，那么刚打开 APP 的时候就会从这个地方开始恢复进程的状态</strong>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, WindowProcessController proc,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;            <br>    <span class="hljs-comment">// 创建启动Activity的事务 </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">clientTransaction</span> <span class="hljs-operator">=</span> ClientTransaction.obtain(proc.getThread(), r.token);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isTransitionForward</span> <span class="hljs-operator">=</span> r.isTransitionForward();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IBinder</span> <span class="hljs-variable">fragmentToken</span> <span class="hljs-operator">=</span> r.getTaskFragment().getFragmentToken();<br>    <span class="hljs-comment">// 添加callback</span><br>    clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(r.intent),<br>                    System.identityHashCode(r), r.info,                 <br>                    mergedConfiguration.getGlobalConfiguration(),<br>                    mergedConfiguration.getOverrideConfiguration(), r.compat,<br>                    r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,<br>                    proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),<br>                    results, newIntents, r.takeOptions(), isTransitionForward,<br>                    proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,<br>                    r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));<br> <br>    <span class="hljs-comment">// 设置Activity启动后的生命周期状态</span><br>    <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem;<br>    <span class="hljs-keyword">if</span> (andResume) &#123;<br>        <span class="hljs-comment">// RESUME状态</span><br>        lifecycleItem = ResumeActivityItem.obtain(isTransitionForward);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// PAUSE状态</span><br>        lifecycleItem = PauseActivityItem.obtain();<br>    &#125;<br>    <span class="hljs-comment">// 设置状态</span><br>    clientTransaction.setLifecycleStateRequest(lifecycleItem);<br><br>    <span class="hljs-comment">// 开启事务，最终调用ClientLifecycleManager#scheduleTransaction()</span><br>    mService.getLifecycleManager().scheduleTransaction(clientTransaction);                         <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>函数首先创建 Activity 事务，设置对应的 callback ，以及对应的生命周期 <code>ActivityLifecycleItem</code>，最终开始调度事务 <code>lientLifecycleManager#scheduleTransaction</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动Activity的事务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IApplicationThread</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> transaction.getClient();<br>    <span class="hljs-comment">// 调用ClientTransaction#schedule()</span><br>    transaction.schedule(); <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-comment">// 调用ApplicationThread#scheduleTransaction()</span><br>    mClient.scheduleTransaction(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    <span class="hljs-comment">// 最终调用ClientTransactionHandler#scheduleTransaction()</span><br>    ActivityThread.<span class="hljs-built_in">this</span>.scheduleTransaction(transaction);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>    transaction.preExecute(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 发送消息，在H类中接收消息</span><br>    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，最终由 AMS 向进程发出 <code>H.EXECUTE_TRANSACTION</code> 命令，这个命令同样会被进程那边接受并处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>            <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ClientTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> (ClientTransaction) msg.obj;<br>                <span class="hljs-comment">// 执行事务</span><br>                mTransactionExecutor.execute(transaction);<br>                <span class="hljs-keyword">if</span> (isSystem()) &#123;<br>                    transaction.recycle();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ClientTransaction transaction)</span> &#123;<br>    <span class="hljs-comment">// 调用TransactionExecutor#executeCallbacks()</span><br>    executeCallbacks(transaction);<br>    <span class="hljs-comment">// 执行lifecycleState</span><br>    executeLifecycleState(transaction);<br><br>    mPendingActions.clear();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数最终会往下调用 <code>ClientTransactionHandler#handleLaunchActivity</code>，最为抽象类的方法，实际调用 <code>ActivityThread#handleLaunchActivity</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Activity <span class="hljs-title function_">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,</span><br><span class="hljs-params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;  <br> 	<span class="hljs-comment">// 在创建Activity之前初始化</span><br>    <span class="hljs-keyword">if</span> (ThreadedRenderer.sRendererEnabled<br>            &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>) &#123;<br>        HardwareRenderer.preload();<br>    &#125;<br>    <span class="hljs-comment">// 获取WMS服务，初始化WindowManager</span><br>    WindowManagerGlobal.initialize();<br>    <span class="hljs-comment">// GraphicsEnvironment提示一个activity正在进程上启动</span><br>    GraphicsEnvironment.hintActivityLaunch();<br>    <span class="hljs-comment">// 启动Activity，调用ActivityThread#performLaunchActivity()</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Activity</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> performLaunchActivity(r, customIntent); <br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>handleLaunchActivity</code> 最终回调目标 <code>Activity</code> 的 <code>onConfigurationChanged</code>，初始化 <code>WindowManagerService</code>，调用 <code>ActivityThread.performLaunchActivity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityThread.performLaunchActivity() &#123;<br>    <span class="hljs-comment">//类似 Application 的创建过程，通过 classLoader 加载 activity.</span><br>    activity = mInstrumentation.newActivity(classLoader, <br>               component.getClassName(), r.intent);<br>    <span class="hljs-comment">//因为 Activity 有界面，所以其 Context 是 ContextThemeWrapper 类型，但实现类仍是ContextImpl.</span><br>    <span class="hljs-type">Context</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> createBaseContextForActivity(r, activity);<br>    activity.attach(context,mInstrumentation,application,...);<br>    <span class="hljs-comment">//与 Window 进行关联</span><br>    <br>    <span class="hljs-comment">//调用 activity 的 onCreate()方法。</span><br>    mInstrumentation.callActivityOnCreate(activity,...)<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callActivityOnCreate</span><span class="hljs-params">(Activity activity, Bundle icicle)</span> &#123;<br>    prePerformCreate(activity);<br>    <span class="hljs-comment">// 调用Activity#performCreate()</span><br>    activity.performCreate(icicle);<br>    postPerformCreate(activity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>callActivityOnCreate</code> 中会回调 <code>Activity.performCreate</code> ，其中调用 <code>Activity</code> 的 <code>onCreate</code> 、<code>Activity.setContentView</code>、<code>ActivityThread.performResumeActivity</code>，<code>performResumeActivity</code> 最终会回调 <code>onResume</code>。</p>
<p>总之，到这里之后，新应用的进程算是创建完成了。</p>
<h1 id="结余"><a href="#结余" class="headerlink" title="结余"></a>结余</h1><p>弯弯绕绕一大圈，有不少的同名函数，在整理这些资料的时候也是被绕晕了好几次了，希望最终写出来的流程没有太混乱吧。如果有哪里写的不对，还请师傅们多多指教。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hgy413/article/details/100071667">https://blog.csdn.net/hgy413/article/details/100071667</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hgy413/article/details/95465321">https://blog.csdn.net/hgy413/article/details/95465321</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151010577">https://zhuanlan.zhihu.com/p/151010577</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7028124957141893150">https://juejin.cn/post/7028124957141893150</a><br><a target="_blank" rel="noopener" href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.md">https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.md</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/g984160547/article/details/120676574">https://blog.csdn.net/g984160547/article/details/120676574</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_14876133/article/details/141362098">https://blog.csdn.net/qq_14876133/article/details/141362098</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f95fd575a57c">VirtualApp拆解之二：Activity启动流程 - 简书</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/05/24/VirtualApp%E5%8E%9F%E7%90%86%E9%80%9F%E8%A7%88%20-%20%E5%AE%B9%E5%99%A8%E5%86%85%20APP%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">← Next VirtualApp原理速览 - 容器内 APP 启动流程</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/05/24/VirtualApp%20%E5%8E%9F%E7%90%86%E9%80%9F%E8%A7%88%20-%20%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB/">VirtualApp 原理速览 - 框架体系 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Activity-%E5%8E%9F%E7%94%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Activity 原生启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2-Launcher"><span class="toc-number">1.1.</span> <span class="toc-text">系统界面 Launcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">启动应用流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E4%BD%99"><span class="toc-number">2.</span> <span class="toc-text">结余</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>