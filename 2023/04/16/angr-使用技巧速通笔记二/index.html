<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Angr 使用技巧速通笔记(二) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Angr 使用技巧速通笔记(二)</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-04-16T10:36:49.000Z" id="date"> 2023-04-16</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.983Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一章的时候大概讲了 <code>Angr</code> 的一些基本概念和使用，我思量着应该要弄点实际的东西来练练才能把这个工具用熟捻。</p>
<p>最经典的使用案例无疑是 <code>angr_ctf</code> 中的那些了：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf">https://github.com/jakespringer/angr_ctf</a></p>
</blockquote>
<p>题目本身都不是很难，甚至大多都是能靠人力完成的工作。但是即便如此，自动化也有自动化的意义对不对。毕竟我们现在需要的不是马上就能用它解决各种难题，而是把简单的问题解决，然后才能开始做复杂问题。</p>
<blockquote>
<p>附件使用的是 <a target="_blank" rel="noopener" href="https://github.com/ZERO-A-ONE/AngrCTF/_FITM">https://github.com/ZERO-A-ONE/AngrCTF\_FITM</a> 仓库下编译好的版本。因为原仓库下只有源代码，而且编译还需要另外去配环境，所以这里直接用了这位师傅编译好的附件。</p>
</blockquote>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>一般的基本流程如下：</p>
<ul>
<li>创建项目：angr.Project(“.&#x2F;binary”)</li>
<li>创建 state：project.factory.entry_state()</li>
<li>创建 SM：project.factory.simgr(state)</li>
<li>探索路径：sim.explore(find&#x3D;addr)</li>
<li>给出结果：sim.found</li>
</ul>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>当然还是得从最简单的开始，题目本身是一个直接用 IDA 读就能读明白的简单程序，但出于练习目的，还是得手写一下脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+1Ch] [ebp-1Ch]<br>  char v5[9]; // [esp+23h] [ebp-15h] BYREF<br>  unsigned int v6; // [esp+2Ch] [ebp-Ch]<br><br>  v6 = __readgsdword(0x14u);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%8s&quot;, v5);<br>  for ( i = 0; i &lt;= 7; ++i )<br>    v5[i] = complex_function(v5[i], i);<br>  if ( !strcmp(v5, &quot;JACEJGCS&quot;) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先需要创建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./00_angr_find&quot;,auto_load_libs=False)<br></code></pre></td></tr></table></figure>

<p>创建 state：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">state=project.factory.entry_state()<br></code></pre></td></tr></table></figure>

<p>创建 SM：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim=project.factory.simgr(state)<br></code></pre></td></tr></table></figure>

<p>搜索路径：</p>
<p>探索路径时需要给出需要查找到的路径地址，这里我们通过 IDA 可以确定程序输出 “Good Job.” 时的地址为 <code>0x08048675</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim.explore(find=0x08048675)<br></code></pre></td></tr></table></figure>

<p>求解结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if sim.found:<br>    res=sim.found[0]<br>    res=res.posix.dumps(0)<br>    print(res)<br></code></pre></td></tr></table></figure>

<p>简单说明一下代码。</p>
<ul>
<li><code>sim.found[0]</code> 代表了探索路径时得到的一条可解的路径。</li>
<li><code>res.posix.dumps(0)</code> 表示去获取对应路径中，<code>stdin</code> 的内容。</li>
</ul>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>程序本身很大，IDA 虽然也有办法反编译，但是速度极慢，但用 <code>Angr</code> 设定好参数就很快了。</p>
<p>前几个步骤是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./01_angr_avoid&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br></code></pre></td></tr></table></figure>

<p>我们不妨试试，如果按照上一题的做法会如何：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim.explore(find=0x080485E0)<br>if sim.found:<br>    res=sim.found[0]<br>    res=res.posix.dumps(0)<br>    print(res)<br></code></pre></td></tr></table></figure>

<p>结果会发现等了很久也没有算出结果，因为分支实在太多了。</p>
<p>因此要对代码做一点改进：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#080485E0                 push    offset aGoodJob ; &quot;Good Job.&quot;<br><br># .text:080485A8 push ebp<br># .text:080485A9 mov ebp, esp<br># .text:080485AB mov should_succeed, 0<br># .text:080485B2 nop<br># .text:080485B3 pop ebp<br># .text:080485B4 retn<br>sim.explore(find=0x080485E0,avoid=0x080485A8)<br></code></pre></td></tr></table></figure>

<p>其实只是给 <code>explore</code> 增加了一个 <code>avoid</code> 的参数。当代码模拟执行遇到了该地址时，将会把这段路径放入到 <code>avoided</code> 的一个列表中，用来表示被避开的路径，然后其他照旧，继续执行。</p>
<p>之所以通过添加这样的操作就能够得到答案，其实很简单，是为了避免路径爆炸而必要的。</p>
<p>我们可以用这么一个二插树来表示路径：</p>
<p class='item-img' data-src='/upload/attach/202304/924548_4SV4DWJAP78N75D.png'><img src="/upload/attach/202304/924548_4SV4DWJAP78N75D.png"></p>
<p>我们用 <code>1</code> 来表示正确的路径，<code>0</code> 表示错误的路径。可以看见，在这个树中一共有 8 条不同的路径，而正确的路径只有一个。</p>
<p>假设所有涉及到 <code>0</code> 的路径都会进入到某个地址 <code>x</code> 处。那么如果没有使用 <code>avoid</code> 参数，<code>Angr</code> 就会遍历这 8 条路径，然后求解出最左的那条路径所需的输入。</p>
<p>而如果我们添加了 <code>avoid=x</code> ，那么当 <code>Angr</code> 从根节点进入到右子树时，由于接下来立刻进入到 <code>x</code> 地址处，因此停止分析这条路径，将其加入到 <code>avoided</code> 中，从而将下面的 4 条路径全都舍弃，将所需的时间直接减少了一半。</p>
<p>同理，当它进入左子树时，仍然存在分叉，而进入右子树的分叉会因为相同的原因被舍弃，从而再次减少一半的时间。</p>
<p>在路径极其庞大的情况下，比如说 2^31 条路径，通过这种方法能够极大程度降低消耗。</p>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+18h] [ebp-40h]<br>  int j; // [esp+1Ch] [ebp-3Ch]<br>  char v6[20]; // [esp+24h] [ebp-34h] BYREF<br>  char v7[20]; // [esp+38h] [ebp-20h] BYREF<br>  unsigned int v8; // [esp+4Ch] [ebp-Ch]<br><br>  v8 = __readgsdword(0x14u);<br>  for ( i = 0; i &lt;= 19; ++i )<br>    v7[i] = 0;<br>  qmemcpy(v7, &quot;VXRRJEUR&quot;, 8);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%8s&quot;, v6);<br>  for ( j = 0; j &lt;= 7; ++j )<br>    v6[j] = complex_function(v6[j], j + 8);<br>  if ( !strcmp(v6, v7) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还是这个模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./02_angr_find_condition&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br></code></pre></td></tr></table></figure>

<p>这题的情况和 <code>00_angr_find</code> 有些不太一样。尽管 IDA 将它们反编译后的结果看起来很像，但是在汇编中却有很大差别：</p>
<p class='item-img' data-src='/upload/attach/202304/924548_F3PMQU8QZU2N6KJ.png'><img src="/upload/attach/202304/924548_F3PMQU8QZU2N6KJ.png"></p>
<p>可以看见，这行输出在 <code>main</code> 函数里到处都是，所以其实很难找到真正的那条路径的地址。</p>
<p>同理的，“Try again.” 也一样，因此需要修改 <code>find</code> 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def succ(state):<br>    res=state.posix.dumps(1)<br>    if b&quot;Good Job.&quot; in res:<br>        return True<br>    else:<br>        return False<br><br>sim.explore(find=succ)<br></code></pre></td></tr></table></figure>

<p>可以发现，<code>find</code> 参数除了能是一个具体的地址外，还可以是一个函数。该函数返回 <code>True</code> 时会将路径记录下来，返回 <code>False</code> 时则表示路径并非我们想找的。</p>
<p>而区别路径的关键在于 <code>state.posix.dumps(1)</code> ，通过该方法，可以将 <code>stdout</code> 中的内容 dump 出来进行比较。如果输出包含了 <code>Good Job.</code> ，我们就认为是想要的路径。这样就能避开直接使用地址了。</p>
<p>当然了，<code>avoid</code> 也可以这么用，读者可以自行试试。</p>
<h2 id="03-angr-simbolic-registers"><a href="#03-angr-simbolic-registers" class="headerlink" title="03_angr_simbolic_registers"></a>03_angr_simbolic_registers</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int v3; // ebx<br>  int v4; // eax<br>  int v5; // edx<br>  int v6; // ST1C_4<br>  unsigned int v7; // ST14_4<br>  unsigned int v9; // [esp+8h] [ebp-10h]<br>  unsigned int v10; // [esp+Ch] [ebp-Ch]<br><br>  printf(&quot;Enter the password: &quot;);<br>  v4 = get_user_input();<br>  v6 = v5;<br>  v7 = complex_function_1(v4);<br>  v9 = complex_function_2(v3);<br>  v10 = complex_function_3(v6);<br>  if ( v7  v9  v10 )<br>    puts(&quot;Try again.&quot;);<br>  else<br>    puts(&quot;Good Job.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还是老三样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./03_angr_symbolic_registers&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br></code></pre></td></tr></table></figure>

<p>有些特殊的地方是，输入使用 <code>get_user_input</code> ，而该函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int get_user_input()<br>&#123;<br>  int v1; // [esp+0h] [ebp-18h]<br>  int v2; // [esp+4h] [ebp-14h]<br>  int v3; // [esp+8h] [ebp-10h]<br>  unsigned int v4; // [esp+Ch] [ebp-Ch]<br><br>  v4 = __readgsdword(0x14u);<br>  __isoc99_scanf(&quot;%x %x %x&quot;, &amp;v1, &amp;v2, &amp;v3);<br>  return v1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前文曾提到过，<code>Angr</code> 对 <code>scanf</code> 这类使用格式化字符串的函数支持并不是很好，不过或许是最近的版本更新，直接这样写也同样能得到结果了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim.explore(find=0x80489E9)<br>if sim.found:<br>    res=sim.found[0]<br>    res=res.posix.dumps(0)<br>    print(res)# b&#x27;b9ffd04e ccf63fe8 8fd4d959&#x27;<br>else:<br>    print(&quot;No&quot;)<br></code></pre></td></tr></table></figure>

<p>不过既然是学习，还是照例看看最标准的写法应该是什么吧。</p>
<p>根据汇编可以看到，该函数的实际操作是将值储存在寄存器中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:0804891E                 lea     ecx, [ebp+var_10]<br>.text:08048921                 push    ecx<br>.text:08048922                 lea     ecx, [ebp+var_14]<br>.text:08048925                 push    ecx<br>.text:08048926                 lea     ecx, [ebp+var_18]<br>.text:08048929                 push    ecx<br>.text:0804892A                 push    offset aXXX     ; &quot;%x %x %x&quot;<br>.text:0804892F                 call    ___isoc99_scanf<br>.text:08048934                 add     esp, 10h<br>.text:08048937                 mov     ecx, [ebp+var_18]<br>.text:0804893A                 mov     eax, ecx<br>.text:0804893C                 mov     ecx, [ebp+var_14]<br>.text:0804893F                 mov     ebx, ecx<br>.text:08048941                 mov     ecx, [ebp+var_10]<br>.text:08048944                 mov     edx, ecx<br></code></pre></td></tr></table></figure>

<p>因此我们可以直接将该函数钩取，然后手动设置寄存器的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./03_angr_symbolic_registers&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x08048980)<br></code></pre></td></tr></table></figure>

<p>由于现在我们再从 <code>entry_point</code> 进入了，而需要跳过 <code>get_user_input</code> 函数，因此使用 <code>blank_state</code> 来初始化状态，并将开始地址设定在该函数之后的第一条指令处。</p>
<p>接下来创建三个位置的符号向量，将他们设定为寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import claripy<br>input1=claripy.BVS(&quot;input1&quot;,32)<br>input2=claripy.BVS(&quot;input2&quot;,32)<br>input3=claripy.BVS(&quot;input3&quot;,32)<br>state.regs.eax=input1<br>state.regs.ebx=input2<br>state.regs.edx=input3<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x80489E9)<br></code></pre></td></tr></table></figure>

<p>此处引入另外一个 <code>claripy</code> 包来创建符号向量： <code>claripy.BVS(name,size)</code> 。创建完成后即可生成 SM 并开始探索了。</p>
<p>完成探索后，最后需要求解符号向量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if sim.found:<br>    res=sim.found[0]<br>    res1=res.solver.eval(input1)<br>    res2=res.solver.eval(input2)<br>    res3=res.solver.eval(input3)<br>    print(hex(res1)+&quot; &quot;+hex(res2)+&quot; &quot;+hex(res3))#0xb9ffd04e 0xccf63fe8 0x8fd4d959<br>else:<br>    print(&quot;No&quot;)<br></code></pre></td></tr></table></figure>

<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int handle_user()<br>&#123;<br>  int v1; // [esp+8h] [ebp-10h] BYREF<br>  int v2[3]; // [esp+Ch] [ebp-Ch] BYREF<br><br>  __isoc99_scanf(&quot;%u %u&quot;, v2, &amp;v1);<br>  v2[0] = complex_function0(v2[0]);<br>  v1 = complex_function1(v1);<br>  if ( v2[0] == 1999643857 &amp;&amp; v1 == -1136455217 )<br>    return puts(&quot;Good Job.&quot;);<br>  else<br>    return puts(&quot;Try again.&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这一步其实就差不多轻车熟路一把梭搞定了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./04_angr_symbolic_stack&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x080486E4)<br>if sim.found:<br>    res=sim.found[0]<br>    res=res.posix.dumps(0)<br>    print(res)#b&#x27;1704280884 2382341151&#x27;<br></code></pre></td></tr></table></figure>

<p>不过这道题实际上和上一题类似，但输入值储存在栈中，因此标准做法其实是将内存符号化进行求解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./04_angr_symbolic_stack&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x08048694)<br><br>import claripy<br>input1=claripy.BVS(&quot;input1&quot;,32)<br>input2=claripy.BVS(&quot;input2&quot;,32)<br>state.regs.ebp=state.regs.esp<br>state.regs.esp-=0x1c<br>state.memory.store(state.regs.ebp-0xc,input1)<br>state.memory.store(state.regs.ebp-0x10,input2)<br><br>sim=project.factory.simgr(state)<br>sim.explore(find=0x080486E4)<br>if sim.found:<br>    res=sim.found[0]<br>    res=res.solver.eval(input1)<br>    print(res)<br>    res=sim.found[0]<br>    res=res.solver.eval(input2)<br>    print(res)<br></code></pre></td></tr></table></figure>

<p>通过 <code>state.memory.store(addr,value)</code> 可以对内存进行符号化，从而在路径发现以后进行求解。</p>
<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+Ch] [ebp-Ch]<br><br>  memset(&amp;user_input, 0, 33);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%8s %8s %8s %8s&quot;, &amp;user_input, &amp;unk_A1BA1C8, &amp;unk_A1BA1D0, &amp;unk_A1BA1D8);<br>  for ( i = 0; i &lt;= 31; ++i )<br>    *(i + 169583040) = complex_function(*(i + 169583040), i);<br>  if ( !strncmp(&amp;user_input, &quot;NJPURZPCDYEAXCSJZJMPSOMBFDDLHBVN&quot;, 32) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这道题同样因为现在的 <code>Angr</code> 功能强大而不需要以前那样复杂的技巧了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./05_angr_symbolic_memory&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x0804866D)<br><br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))#b&#x27;NAXTHGNR JVSFTPWE LMGAUHWC XMDCPALU&#x27;<br></code></pre></td></tr></table></figure>

<p>而题目的本意是让我们将内存符号化，其实和上一题一样，直接对内存进行存储就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./05_angr_symbolic_memory&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x080485FE)<br><br>import claripy<br>pwd1=claripy.BVS(&quot;pwd1&quot;,64)<br>pwd2=claripy.BVS(&quot;pwd2&quot;,64)<br>pwd3=claripy.BVS(&quot;pwd3&quot;,64)<br>pwd4=claripy.BVS(&quot;pwd4&quot;,64)<br>state.memory.store(0x0A1BA1C0,pwd1)<br>state.memory.store(0x0A1BA1C0+8,pwd2)<br>state.memory.store(0x0A1BA1C0+8+8,pwd3)<br>state.memory.store(0x0A1BA1C0+8+8+8,pwd4)<br><br>sim=project.factory.simgr(state)<br>sim.explore(find=0x0804866D)<br><br>if sim.found:<br>    res=sim.found[0]<br>    print(res.solver.eval(pwd1))<br>    print(res.solver.eval(pwd2))<br>    print(res.solver.eval(pwd3))<br>    print(res.solver.eval(pwd4))<br></code></pre></td></tr></table></figure>

<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  _BYTE *v3; // ebx<br>  _BYTE *v4; // ebx<br>  int v6; // [esp-18h] [ebp-24h]<br>  int v7; // [esp-14h] [ebp-20h]<br>  int v8; // [esp-10h] [ebp-1Ch]<br>  int v9; // [esp-8h] [ebp-14h]<br>  int v10; // [esp-4h] [ebp-10h]<br>  int v11; // [esp+0h] [ebp-Ch]<br>  int i; // [esp+0h] [ebp-Ch]<br><br>  buffer0 = malloc(9, v6, v7, v8);<br>  buffer1 = malloc(9, v9, v10, v11);<br>  memset(buffer0, 0, 9);<br>  memset(buffer1, 0, 9);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%8s %8s&quot;, buffer0, buffer1);<br>  for ( i = 0; i &lt;= 7; ++i )<br>  &#123;<br>    v3 = (_BYTE *)(buffer0 + i);<br>    *v3 = complex_function(*(char *)(buffer0 + i), i);<br>    v4 = (_BYTE *)(buffer1 + i);<br>    *v4 = complex_function(*(char *)(buffer1 + i), i + 32);<br>  &#125;<br>  if ( !strncmp(buffer0, &quot;UODXLZBI&quot;, 8) &amp;&amp; !strncmp(buffer1, &quot;UAORRAYF&quot;, 8) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  free(buffer0);<br>  free(buffer1);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和上一题不同的地方在于，这次的存储位置为堆内存，我们不能直接给出一个地址然后去存储。</p>
<p>一把梭还是可行的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./06_angr_symbolic_dynamic_memory&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x08048759)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br></code></pre></td></tr></table></figure>

<p>而标准做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./06_angr_symbolic_dynamic_memory&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x08048699)<br>buff0=0x0ABCC8A4<br>buff1=0x0ABCC8AC<br><br>import claripy<br>pwd1=claripy.BVS(&quot;pwd1&quot;,64)<br>pwd2=claripy.BVS(&quot;pwd2&quot;,64)<br><br>state.memory.store(buff0,0xffffff00,endness=project.arch.memory_endness)<br>state.memory.store(buff1,0xffffff80,endness=project.arch.memory_endness)<br><br>state.memory.store(0xffffff00,pwd1)<br>state.memory.store(0xffffff80,pwd2)<br><br>sim=project.factory.simgr(state)<br>sim.explore(find=0x08048759)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.solver.eval(pwd1))<br>    print(res.solver.eval(pwd2))<br></code></pre></td></tr></table></figure>

<p>通过这题就能够理解符号执行的一个好处了。由于它并不是真的去执行，只是模拟执行代码而已，所以对地址本身没有限制，完全可以随意设定内存的使用方法。</p>
<p>另外 <code>endness</code> 参数用于指定储存的端序，而 <code>project.arch.memory_endness</code> 将会反映程序所在平台的默认端序，此处为小端序。</p>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int result; // eax<br>  int i; // [esp+Ch] [ebp-Ch]<br><br>  memset(&amp;buffer, 0, 64);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%64s&quot;, &amp;buffer);<br>  ignore_me(&amp;buffer, 64);<br>  memset(&amp;buffer, 0, 64);<br>  fp = fopen(&quot;OJKSQYDP.txt&quot;, &quot;rb&quot;);<br>  fread(&amp;buffer, 1, 64, fp);<br>  fclose(fp);<br>  unlink(&quot;OJKSQYDP.txt&quot;);<br>  for ( i = 0; i &lt;= 7; ++i )<br>    *(_BYTE *)(i + 134520992) = complex_function(*(char *)(i + 134520992), i);<br>  if ( strncmp(&amp;buffer, &quot;AQWLCTXB&quot;, 9) )<br>  &#123;<br>    puts(&quot;Try again.&quot;);<br>    exit(1);<br>  &#125;<br>  puts(&quot;Good Job.&quot;);<br>  exit(0);<br>  _libc_csu_init();<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以发现程序调用了 <code>fopen</code> 去打开文件，对于这种情况，<code>Angr</code> 也同样提供了模拟文件的系统。</p>
<p>同样的，照旧一把梭也能搞定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./07_angr_symbolic_file&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x080489B0)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>#b&#x27;AZOMMMZM\x00@\x04\x00\x01\x01\x01\x01\x01\x00\x00\x00\x02\x00\x01\x00\x80\x04\x80\x00\x02\x01\x04\x00\x02\x80\x08\x01\x00\x02\x01\x01\x01@\x01\x00\x08\x08\x04\x80\x04\x01\x80\x01\x04\x80\x02\x00\x00@\x00\x00\x00\x00\x00\x00&#x27;<br></code></pre></td></tr></table></figure>

<p>不过还是来看看它的模拟文件系统吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./07_angr_symbolic_file&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x080488EA)<br>filename = &#x27;OJKSQYDP.txt&#x27;<br>pwd1=claripy.BVS(&quot;pwd1&quot;,64*8)<br><br>pwdfile=angr.storage.SimFile(filename,content=pwd1,size=64)<br>state.fs.insert(filename,pwdfile)<br><br>sim=project.factory.simgr(state)<br>sim.explore(find=0x080489B0)<br>if sim.found:<br>    res=sim.found[0]<br>    print(hex(res.solver.eval(pwd1)))<br><br>#0x415a4f4d4d4d5a4d0000000000000000000000000002000020000000000200000000000000008000000000401002000000000000000000000004001000000000<br></code></pre></td></tr></table></figure>

<p>前几个还是照旧，但是也有一些新东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwdfile=angr.storage.SimFile(filename,content=pwd1,size=64)<br>state.fs.insert(filename,pwdfile)<br></code></pre></td></tr></table></figure>

<p><code>angr.storage.SimFile</code> 提供了一个模拟文件系统，通过 <code>state.fs.insert</code> 可以将该模拟出来的文件插入到 <code>state</code> 符号中。这样在模拟执行时就会用该文件替代真实情况下的文件了。</p>
<p>而 <code>angr.storage.SimFile</code> 的 <code>filename</code> 参数表示文件名，<code>content</code> 参数表示文件内容，<code>size</code> 参数表示文件大小，单位为字节。</p>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+Ch] [ebp-Ch]<br><br>  qmemcpy(&amp;password, &quot;AUPDNNPROEZRJWKB&quot;, 16);<br>  memset(&amp;buffer, 0, 17);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%16s&quot;, &amp;buffer);<br>  for ( i = 0; i &lt;= 15; ++i )<br>    *(i + 134520912) = complex_function(*(i + 134520912), 15 - i);<br>  if ( check_equals_AUPDNNPROEZRJWKB(&amp;buffer, 16) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">BOOL __cdecl check_equals_AUPDNNPROEZRJWKB(int a1, unsigned int a2)<br>&#123;<br>  int v3; // [esp+8h] [ebp-8h]<br>  unsigned int i; // [esp+Ch] [ebp-4h]<br><br>  v3 = 0;<br>  for ( i = 0; i &lt; a2; ++i )<br>  &#123;<br>    if ( *(i + a1) == *(i + 134520896) )<br>      ++v3;<br>  &#125;<br>  return v3 == a2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里就能遇到之前所说的 “路径爆炸” 问题了。</p>
<p>照例试试一把梭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./08_angr_constraints&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x08048694)<br>if sim.found:<br>    print(&quot;yes&quot;)<br></code></pre></td></tr></table></figure>

<p>会发现这次就没办法那么顺利得到答案了，<code>Angr</code> 求解了半天却一直没有给出 “yes” 的回答，因此这次我们必须手动去优化求解的过程。</p>
<p>分析 <code>check_equals_AUPDNNPROEZRJWKB</code> 函数可以发现，该函数实际上是在对输入和 <code>password</code> 对比，而 <code>password</code> 的值是固定的 <code>AUPDNNPROEZRJWKB</code> 。</p>
<p>因此第一种缓解路径爆炸的方法是，只需要探索到进入该路径即可。而此后的求解过程通过人为的方法手动增加。</p>
<p>首先还是创建状态，这里我们跳过了 <code>scanf</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./08_angr_constraints&quot;,auto_load_libs=False)<br>state=project.factory.blank_state(addr=0x08048625)<br></code></pre></td></tr></table></figure>

<p>接下来我们为 <code>buffer</code> 创建符号，并开始探索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import claripy<br>pwd=claripy.BVS(&quot;pwd&quot;,16*8)<br>state.memory.store(0x0804A050,pwd)<br><br>sim=project.factory.simgr(state)<br>sim.explore(find=0x08048565)<br></code></pre></td></tr></table></figure>

<p>此处地址 <code>0x08048565</code> 对应了 <code>check_equals_AUPDNNPROEZRJWKB</code> 函数的第一行指令。这样就不必进入到会引发路径爆炸的循环中了。</p>
<p>最后，在找到路径以后，为求解器主动添加条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if sim.found:<br>    res=sim.found[0]<br>    now_str=state.memory.load(0x0804A050,16)<br>    res.solver.add(&quot;AUPDNNPROEZRJWKB&quot;==now_str)<br>    print(res.solver.eval(pwd)) <br></code></pre></td></tr></table></figure>

<p>我们需要保证的是，在进入 <code>check_equals_AUPDNNPROEZRJWKB</code> 函数时，<code>buffer</code> 处的内容和字符串 <code>AUPDNNPROEZRJWKB</code> 相同，因此直接添加条件即可求解。</p>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  BOOL v3; // eax<br>  int i; // [esp+8h] [ebp-10h]<br>  int j; // [esp+Ch] [ebp-Ch]<br><br>  qmemcpy(&amp;password, &quot;XYMKBKUHNIQYNQXE&quot;, 16);<br>  memset(&amp;buffer, 0, 17);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%16s&quot;, &amp;buffer);<br>  for ( i = 0; i &lt;= 15; ++i )<br>    *(_BYTE *)(i + 134520916) = complex_function(*(char *)(i + 134520916), 18 - i);<br>  equals = check_equals_XYMKBKUHNIQYNQXE(&amp;buffer, 16);<br>  for ( j = 0; j &lt;= 15; ++j )<br>    *(_BYTE *)(j + 134520900) = complex_function(*(char *)(j + 134520900), j + 9);<br>  __isoc99_scanf(&quot;%16s&quot;, &amp;buffer);<br>  v3 = equals &amp;&amp; !strncmp(&amp;buffer, &amp;password, 16);<br>  equals = v3;<br>  if ( v3 )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而上一题的操作总归来说是解一时之急，因为函数正好在最后的位置，所以停在那边就足够了。但是如果路径爆炸发生在中途，就不能这么做了，我们需要更好的方法解决它。</p>
<p>首先是路径爆炸会发生在 <code>check_equals_XYMKBKUHNIQYNQXE</code> 函数中，它和上一题的函数是一样的。</p>
<p>前几个还是一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./09_angr_hooks&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br></code></pre></td></tr></table></figure>

<p>接下来是对该函数进行钩取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">@project.hook(0x080486B3, length=5)<br>def skip_check(state):<br>    compare_str=&quot;XYMKBKUHNIQYNQXE&quot;<br>    now_str=state.memory.load(0x0804A054,16)<br>    state.regs.eax=claripy.If(compare_str==now_str,claripy.BVV(1, 32),claripy.BVV(0, 32))<br></code></pre></td></tr></table></figure>

<p>钩取方法可以通过 <code>@project.hook</code> 宏完成。第一个参数为对应的机器码地址，第二个参数为钩取的指令长度。此处因为我们只需要钩取 <code>call</code> 指令，因此长度为 5。</p>
<p>而钩子下面对应的需要定义钩子函数，此处我们将 <code>buffer</code> 的内容读取出来进行比较，并根据结果使用 <code>claripy.If</code> 来设置 eax 寄存器。</p>
<p>最后探索路径即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim=project.factory.simgr(state)<br>sim.explore(find=0x08048768)<br><br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br></code></pre></td></tr></table></figure>

<p>此方法为第二个缓解路径爆炸的方法，即直接对地址进行钩取。</p>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+20h] [ebp-28h]<br>  char v5[17]; // [esp+2Bh] [ebp-1Dh] BYREF<br>  unsigned int v6; // [esp+3Ch] [ebp-Ch]<br><br>  v6 = __readgsdword(0x14u);<br>  memcpy(&amp;password, &quot;ORSDDWXHZURJRBDH&quot;, 16);<br>  memset(v5, 0, sizeof(v5));<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%16s&quot;, v5);<br>  for ( i = 0; i &lt;= 15; ++i )<br>    v5[i] = complex_function(v5[i], 18 - i);<br>  if ( check_equals_ORSDDWXHZURJRBDH(v5, 16) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第 10 题看起来和上一题一样，但是还是那个问题，如果调用点很多该怎么办？虽然 IDA 分析出的结果相似，但是通过交叉引用可以发现：</p>
<p class='item-img' data-src='/upload/attach/202304/924548_QSF2Z33KHD4F2JU.png'><img src="/upload/attach/202304/924548_QSF2Z33KHD4F2JU.png"></p>
<p>显然不太可能每次都对地址进行钩取，因此需要有一个方法直接钩取函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./10_angr_simprocedures&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br></code></pre></td></tr></table></figure>

<p>接下来钩取函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class ReplaceCmp(angr.SimProcedure):<br>    def run(self,arg1,arg2):<br>        cmp_str=&quot;ORSDDWXHZURJRBDH&quot;<br>        input_str=self.state.memory.load(arg1,arg2)<br>        return claripy.If(cmp_str==input_str,claripy.BVV(1,32),claripy.BVV(0,32))<br><br>project.hook_symbol(&quot;check_equals_ORSDDWXHZURJRBDH&quot;, ReplaceCmp())<br></code></pre></td></tr></table></figure>

<p>首先需要声明一个类，并定义 <code>run</code> 方法，而该方法将取代想要钩取的函数。其参数会和钩取的函数有相同的参数列表，但除此之外还需要一个 <code>self</code> 。</p>
<p>至于 <code>run</code> 函数的实现则各不相同了。这里我们就直接模仿比较函数的最终效果，返回比较的结果。</p>
<p>然后调用 <code>project.hook_symbol</code> 方法直接以函数名为参数对函数进行钩取即可。</p>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+20h] [ebp-28h]<br>  char v6[20]; // [esp+28h] [ebp-20h] BYREF<br>  unsigned int v7; // [esp+3Ch] [ebp-Ch]<br><br>  v7 = __readgsdword(0x14u);<br>  print_msg();<br>  memset(v6, 0, sizeof(v6));<br>  qmemcpy(v6, &quot;DCLUESMR&quot;, 8);<br>  for ( i = 0; i &lt;= 7; ++i )<br>    v6[i] = complex_function(v6[i], i);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%u %u&quot;, &amp;buffer0, &amp;buffer1);<br>  if ( !strncmp(&amp;buffer0, v6, 4) &amp;&amp; !strncmp(&amp;buffer1, &amp;v6[4], 4) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现一把梭能解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./11_angr_sim_scanf&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br>sim.explore(find=0x0804FCA1)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>    #b&#x27;1146242628 1296386129&#x27;<br></code></pre></td></tr></table></figure>

<p>不过原题的目的是让我们去钩取 <code>scanf</code> 函数。其实做法和上一题一样，这里就不再重复了。不过有一点我们必须抱有疑问，我们知道这类函数的参数数量是不确定的，但如果想要钩取一个函数，我们就需要给定一个确定的参数列表，这样才能定义 <code>run</code> 方法。</p>
<p>这个问题我们留待以后阅读源代码再做考虑。至少目前来看，<code>Angr</code> 已经完善了 <code>scanf</code> 函数的 hook 了，我们可以直接一把梭解决这个问题。</p>
<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// bad sp value at call has been detected, the output may be wrong!<br>int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int v3; // ebx<br>  int v5; // [esp-10h] [ebp-5Ch]<br>  int v6; // [esp-Ch] [ebp-58h]<br>  int v7; // [esp-8h] [ebp-54h]<br>  int v8; // [esp-4h] [ebp-50h]<br>  const char **v9; // [esp+0h] [ebp-4Ch]<br>  int v10; // [esp+4h] [ebp-48h]<br>  int v11; // [esp+8h] [ebp-44h]<br>  int v12; // [esp+Ch] [ebp-40h]<br>  int v13; // [esp+10h] [ebp-3Ch]<br>  int v14; // [esp+10h] [ebp-3Ch]<br>  int v15; // [esp+14h] [ebp-38h]<br>  int i; // [esp+14h] [ebp-38h]<br>  int v17; // [esp+18h] [ebp-34h]<br>  int v18[9]; // [esp+1Ch] [ebp-30h] BYREF<br>  unsigned int v19; // [esp+40h] [ebp-Ch]<br>  int *p_argc; // [esp+44h] [ebp-8h]<br><br>  p_argc = &amp;argc;<br>  v9 = argv;<br>  v19 = __readgsdword(0x14u);<br>  print_msg();<br>  memset(<br>    v18 + 3,<br>    0,<br>    33,<br>    v5,<br>    v6,<br>    v7,<br>    v8,<br>    v9,<br>    v10,<br>    v11,<br>    v12,<br>    v13,<br>    v15,<br>    v17,<br>    v18[0],<br>    v18[1],<br>    v18[2],<br>    v18[3],<br>    v18[4],<br>    v18[5]);<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%32s&quot;, v18 + 3);<br>  v14 = 0;<br>  for ( i = 0; i &lt;= 31; ++i )<br>  &#123;<br>    v3 = *(v18 + i + 3);<br>    if ( v3 == complex_function(87, i + 186) )<br>      ++v14;<br>  &#125;<br>  if ( v14 != 32  v19 )<br>    puts(&quot;Try again.&quot;);<br>  else<br>    puts(&quot;Good Job.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然我们是通过钩取函数来解决某个函数的路径爆炸问题，那么就肯定会遇到这么一种情况：<code>函数的某部分引发路径爆炸，但其他部分在做必要的运算</code> 。</p>
<p>本题就可以发现，循环判断语句嵌在 <code>main</code> 函数中，我们显然不能直接把整个 <code>main</code> 函数 hook 掉，那样就和直接读代码逆向没区别了。</p>
<p><code>Angr</code> 提供了一种名为 <code>Veritesting</code> 的算法，它能够让符号执行引起在 <code>动态符号执行DSE</code> 和 <code>静态符号执行SSE</code> 之间协同工作从而减少路径爆炸的问题。</p>
<p>在 <code>Angr</code> 中只需要为 <code>project.factory.simgr</code> 添加一个参数 <code>veritesting=True</code> 即可开启。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./12_angr_veritesting&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state,veritesting=True)<br><br>sim.explore(find=0x08048684)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>b&#x27;CXSNIDYTOJEZUPKFAVQLGBWRMHCXSNID&#x27;<br></code></pre></td></tr></table></figure>

<p>不过不得不说的是，这个方法看起来好像很万能，其实并没有想象中的那么好用。对于本题的这个体量来说，笔者执行了约 5 次才有一次能够迅速的算出结果。可想而知，对于体积稍微大一些，类似的循环稍微多一些的程序来说，这个方法并不能带来多大的提升，反而会让人难以猜测程序究竟是卡在路径爆炸中还是仍然处于计算。</p>
<p>因此对于一些简单的问题，笔者虽然推荐这个方法，但只要问题稍微复杂一点，它甚至会增加人力负担。</p>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  int i; // [esp+1Ch] [ebp-3Ch]<br>  int j; // [esp+20h] [ebp-38h]<br>  char v6[20]; // [esp+24h] [ebp-34h] BYREF<br>  char v7[20]; // [esp+38h] [ebp-20h] BYREF<br>  unsigned int v8; // [esp+4Ch] [ebp-Ch]<br><br>  v8 = __readgsdword(0x14u);<br>  print_msg();<br>  for ( i = 0; i &lt;= 19; ++i )<br>    v7[i] = 0;<br>  qmemcpy(v7, &quot;LJVNEPAU&quot;, 8);<br>  printf(&quot;Enter the password: &quot;);<br>  _isoc99_scanf(&quot;%8s&quot;, v6);<br>  for ( j = 0; j &lt;= 7; ++j )<br>    v6[j] = complex_function(v6[j], j);<br>  if ( !strcmp(v6, v7) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序本身也并不复杂，和上一题的主要区别在于，这次使用了静态编译去生成二进制文件。</p>
<p>本身 <code>Angr</code> 是在库函数装载时钩取这些函数的，静态编译的程序没有这个过程，因此道理上就会被主动分析，这就会带来很大的消耗了，因此本题需要钩取那些静态编译生成的库函数。</p>
<p>其实差异不大，在上一篇文章中提到过，<code>angr</code> 内置了多个库函数，既然现在它无法自动钩取，由我们手动去做这件事就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./13_angr_static_binary&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br><br>project.hook(0x0804ED40,angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;printf&#x27;]())<br>project.hook(0x0804ED80,angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;scanf&#x27;]())<br>project.hook(0x0804F350,angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;puts&#x27;]())<br>project.hook(0x08048D10,angr.SIM_PROCEDURES[&#x27;glibc&#x27;][&#x27;__libc_start_main&#x27;]())<br>project.hook(0x0805B450,angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;strcmp&#x27;]())<br><br>sim=project.factory.simgr(state,veritesting=True)<br>sim.explore(find=0x080489E1)<br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))#LYZGMMMV<br></code></pre></td></tr></table></figure>

<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p class='item-img' data-src='/upload/attach/202304/924548_TFGB8RM53J9KKPU.png'><img src="/upload/attach/202304/924548_TFGB8RM53J9KKPU.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">BOOL __cdecl validate(int a1, int a2)<br>&#123;<br>  _BYTE *v3; // esi<br>  char v4[20]; // [esp+4h] [ebp-24h] BYREF<br>  int j; // [esp+18h] [ebp-10h]<br>  int i; // [esp+1Ch] [ebp-Ch]<br><br>  if ( a2 &lt;= 7 )<br>    return 0;<br>  for ( i = 0; i &lt;= 19; ++i )<br>    v4[i] = 0;<br>  qmemcpy(v4, &quot;WLKGLJWH&quot;, 8);<br>  for ( j = 0; j &lt;= 7; ++j )<br>  &#123;<br>    v3 = (j + a1);<br>    *v3 = complex_function(*(j + a1), j);<br>  &#125;<br>  return strcmp(a1, v4) == 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这道题的特殊情况在于程序加载了额外的动态库并使用其中的函数。由于这个动态库是用户编写的，<code>Angr</code> 不能找到替代品去 hook 。而我们其实也不方便直接加载它，因为通过 <code>auto_load_libs</code> 会把其他无关紧要的东西一起加载进来。</p>
<p>不过好在，这道题的主要逻辑全都放在了动态库中，这就能简化我们的操作了。</p>
<p>我们可以使用 <code>call_state</code> 来完成操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./lib14_angr_shared_library.so&quot;,auto_load_libs=False)<br>state=project.factory.call_state(0x000006D7+0x400000,arg1,claripy.BVV(8, 32))<br></code></pre></td></tr></table></figure>

<ul>
<li>参数一：入口点地址</li>
<li>参数二：该函数对应的参数 1</li>
<li>参数三：该函数对应的参数 2</li>
<li>……</li>
</ul>
<p>另外，我们将该函数的加载基址设到了 <code>0x400000</code> 。</p>
<p>然后就是对参数的内容进行符号化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwd = claripy.BVS(&#x27;pwd&#x27;, 8*8)<br>state.memory.store(arg1, pwd)<br></code></pre></td></tr></table></figure>

<p>最后就是求解方程了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim=project.factory.simgr(state)<br><br>sim.explore(find=0x783+0x400000)<br>if sim.found:<br>    res=sim.found[0]<br>    res.add_constraints(res.regs.eax!=0)<br>    print(res.solver.eval(pwd))#6293577405752494919<br></code></pre></td></tr></table></figure>

<p>不过因为校验返回值的内容并不在库文件，所以我们需要手动通过 <code>add_constraints</code> 来为状态添加约束。</p>
<p>当然，用 <code>res.solver.add</code> 也是可以的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sim.explore(find=0x783+0x400000)<br>if sim.found:<br>    res=sim.found[0]<br>    res.solver.add(res.regs.eax!=0)<br>    print(res.solver.eval(pwd))#6293577405752494919<br></code></pre></td></tr></table></figure>

<p>不过需要区别的是，<code>add_constraints</code> 的约束是对状态所做的，而 <code>res.solver.add</code> 是对约束器做的。在本题中两个方法都行，但不能混用。</p>
<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  char v4; // [esp+Ch] [ebp-1Ch] BYREF<br>  char *v5; // [esp+1Ch] [ebp-Ch]<br><br>  v5 = try_again;<br>  print_msg();<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%u %20s&quot;, &amp;key, &amp;v4);<br>  if ( key == 19511649 )<br>    puts(v5);<br>  else<br>    puts(try_again);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这次的题目就比较特殊了，它要求我们用 <code>Angr</code> 自动求解一个 payload，使得最终会溢出到变量 <code>v5</code> 来修改 <code>puts</code> 的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./15_angr_arbitrary_read&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br><br>def check_puts(state):<br>    puts_parameter = state.memory.load(state.regs.esp + 4, 4, endness=project.arch.memory_endness)<br>    is_vulnerable_expression = puts_parameter == 0x594e4257<br>    if is_vulnerable_expression!=0:<br>        return True<br>    else:<br>        return False<br><br>def is_successful(state):<br>    puts_address = 0x8048370<br>    if state.addr == puts_address:<br>        return check_puts(state)<br>    else:<br>        return False<br><br>sim.explore(find=is_successful)<br><br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br></code></pre></td></tr></table></figure>

<p>其实思路很朴素，在函数调用 <code>pust</code> 时检查一下参数，看看它是不是 <code>Good Job</code> 字符串的地址即可。</p>
<p>不得不说，<code>Angr</code> 的功能确实强大，连自动化求解 payload 都能做到了。</p>
<h2 id="16-angr-arbitrary-write"><a href="#16-angr-arbitrary-write" class="headerlink" title="16_angr_arbitrary_write"></a>16_angr_arbitrary_write</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  char v4[16]; // [esp+Ch] [ebp-1Ch] BYREF<br>  void *v5; // [esp+1Ch] [ebp-Ch]<br><br>  v5 = &amp;unimportant_buffer;<br>  memset(v4, 0, sizeof(v4));<br>  strncpy(&amp;password_buffer, &quot;PASSWORD&quot;, 12);<br>  print_msg();<br>  printf(&quot;Enter the password: &quot;);<br>  __isoc99_scanf(&quot;%u %20s&quot;, &amp;key, v4);<br>  if ( key == 24173502 )<br>    strncpy(v5, v4, 16);<br>  else<br>    strncpy(&amp;unimportant_buffer, v4, 16);<br>  if ( !strncmp(&amp;password_buffer, &quot;DVTBOGZL&quot;, 8) )<br>    puts(&quot;Good Job.&quot;);<br>  else<br>    puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>目的是显然的，通过 <code>__isoc99_scanf</code> 来溢出，让 <code>v5</code> 指向 <code>password_buffer</code> 。</p>
<p>笔者本来是打算直接直接将结果卡在 <code>strncpy</code> ：</p>
<p class='item-img' data-src='/upload/attach/202304/924548_4PCVDP9B96JPN7E.png'><img src="/upload/attach/202304/924548_4PCVDP9B96JPN7E.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./16_angr_arbitrary_write&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br><br>def is_successful(state):<br>    if state.addr== 0x08048611:<br>        return True<br>    else:<br>        return False<br><br>sim.explore(find=is_successful)<br><br>if sim.found:<br>    print(&quot;yes&quot;)<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>else:<br>    print(&quot;no&quot;)<br></code></pre></td></tr></table></figure>

<p>最后会发现这个写法是有问题的，<code>Angr</code> 最终会给出 <code>No</code> 。可以发现 <code>Angr</code> 对 <code>find</code> 的判断取决于每次进入基本块的第一个地址。</p>
<p>因为它并不以每一条指令进行判断，而是对每次状态执行一次 <code>step</code> 执行完整个基本块后，再调用 <code>find</code> 的条件进行判断。</p>
<blockquote>
<p>不过，如果 <code>find</code> 本身是一个地址的话，却能够正常发现，有点奇怪，这个问题留到以后看源代码吧。</p>
</blockquote>
<p>最后笔者试着这样去完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./16_angr_arbitrary_write&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br><br>def check_v5(state):<br>    arg0=state.memory.load(state.regs.ebp-0xc,4,endness=project.arch.memory_endness)<br>    arg1=state.memory.load(state.regs.ebp-0x1c,4,endness=project.arch.memory_endness)<br>    now_str=state.memory.load(arg1,8)<br>    if state.solver.symbolic(arg0) and state.solver.symbolic(now_str):<br>        does_src_hold_password=arg0==0x4655544c<br>        does_dest_equal_buffer_address=now_str[-1:-64] == &#x27;DVTBOGZL&#x27;<br>        if state.satisfiable(extra_constraints=(does_src_hold_password, does_dest_equal_buffer_address)):<br>            state.add_constraints(does_src_hold_password,does_dest_equal_buffer_address)<br>            return True<br>        else:<br>            return False<br>    else:<br>        return False<br><br><br>def is_successful(state):<br>    if state.addr== 0x08048604:<br>        return check_v5(state)<br>    else:<br>        return False<br><br>sim.explore(find=is_successful)<br><br>if sim.found:<br>    print(&quot;yes&quot;)<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>else:<br>    print(&quot;no&quot;)<br></code></pre></td></tr></table></figure>

<p>它能帮我算出 <code>key</code> 和 <code>v4</code> 的最后四字节，但是中间的前几位却一直算不出结果。如果您知道为什么还请告诉我。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">b&#x27;0024173502 \xf0\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00LTUF&#x27;<br></code></pre></td></tr></table></figure>

<p>最后还是修改了钩子钩取的地址来完成本题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>import claripy<br>project=angr.Project(&quot;./16_angr_arbitrary_write&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state)<br><br>def check_v5(state):<br>    arg0=state.memory.load(state.regs.esp + 4,4,endness=project.arch.memory_endness)<br>    arg1=state.memory.load(state.regs.esp + 8,4,endness=project.arch.memory_endness)<br>    now_str=state.memory.load(arg1,8)<br>    if state.solver.symbolic(arg0) and state.solver.symbolic(now_str):<br>        does_src_hold_password=arg0==0x4655544c<br>        does_dest_equal_buffer_address=now_str[-1:-64] == &#x27;DVTBOGZL&#x27;<br>        if state.satisfiable(extra_constraints=(does_src_hold_password, does_dest_equal_buffer_address)):<br>            state.add_constraints(does_src_hold_password,does_dest_equal_buffer_address)<br>            return True<br>        else:<br>            return False<br>    else:<br>        return False<br><br><br>def is_successful(state):<br>    if state.addr== 0x8048410:<br>        return check_v5(state)<br>    else:<br>        return False<br><br>sim.explore(find=is_successful)<br><br>if sim.found:<br>    res=sim.found[0]<br>    print(res.posix.dumps(0))<br>    #b&#x27;0024173502 DVTBOGZL\x00\x00\x00\x00\x00\x00\x00\x00LTUF&#x27;<br>else:<br>    print(&quot;no&quot;)<br></code></pre></td></tr></table></figure>

<p>可以看见，如果我将判断的地址添加在 <code>0x8048410</code> 处，也就是 <code>strncpy</code> 的 plt 表上，就能够顺利解决这个问题了。</p>
<p>有些迷惑。</p>
<h2 id="17-angr-arbitrary-jump"><a href="#17-angr-arbitrary-jump" class="headerlink" title="17_angr_arbitrary_jump"></a>17_angr_arbitrary_jump</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __cdecl main(int argc, const char **argv, const char **envp)<br>&#123;<br>  print_msg();<br>  printf(&quot;Enter the password: &quot;);<br>  read_input();<br>  puts(&quot;Try again.&quot;);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int read_input()<br>&#123;<br>  char v1[30]; // [esp+1Ah] [ebp-1Eh] BYREF<br><br>  return __isoc99_scanf(&amp;unk_4D4C4860, v1);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>unk_4D4C4860</code> 处为 <code>%s</code></p>
</blockquote>
<p>显然就是一个栈溢出了，但是这次需有让 <code>Angr</code> 自动去覆盖返回地址到 <code>print_good</code> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int print_good()<br>&#123;<br>  puts(&quot;Good Job.&quot;);<br>  exit(0);<br>  return read_input();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样还是最开始那几个，但是注意，本题需要额外添加一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project=angr.Project(&quot;./17_angr_arbitrary_jump&quot;,auto_load_libs=False)<br>state=project.factory.entry_state()<br>sim=project.factory.simgr(state,save_unconstrained=True)<br></code></pre></td></tr></table></figure>

<p><code>save_unconstrained=True</code> 会让 <code>Angr</code> 保存那些不受约束的状态。其实默认情况下的状态就是未约束的。将这些路径保存下来以后，进行遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">d=sim.explore()<br><br>for state in d.unconstrained:<br>    typ=project.arch.memory_endness<br>    next_stack=state.memory.load(state.regs.esp,4,endness=typ)<br>    state.add_constraints(next_stack==0x4D4C4749)<br>    state.add_constraints(state.regs.eip==0x4D4C4785)<br>    print(state.posix.dumps(0))<br>#b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x85GLMIGLM\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00<br></code></pre></td></tr></table></figure>

<p>为状态添加约束，去寻找同时满足 <code>next_stack==0x4D4C4749</code> 和 <code>state.regs.eip==0x4D4C4785</code> 的状态，然后给出该状态对应的 <code>stdin</code> 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实做完这么多题目，尽管感叹 <code>Angr</code> 确实厉害的同时，也不得不承认它仍然有很多的问题，也并没有想象中那么完美。或许要让它走向更加实用的方向还需要一定的积累吧。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/08/28/Frida-gum-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E8%AF%BB/">← 下一篇 Frida-gum 源代码分析解读</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/12/angr-tips-1/">Angr 使用技巧速通笔记(一) 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">2.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#00-angr-find"><span class="toc-number">2.1.</span> <span class="toc-text">00_angr_find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#01-angr-avoid"><span class="toc-number">2.2.</span> <span class="toc-text">01_angr_avoid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-angr-find-condition"><span class="toc-number">2.3.</span> <span class="toc-text">02_angr_find_condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-angr-simbolic-registers"><span class="toc-number">2.4.</span> <span class="toc-text">03_angr_simbolic_registers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-angr-symbolic-stack"><span class="toc-number">2.5.</span> <span class="toc-text">04_angr_symbolic_stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-angr-symbolic-memory"><span class="toc-number">2.6.</span> <span class="toc-text">05_angr_symbolic_memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-angr-symbolic-dynamic-memory"><span class="toc-number">2.7.</span> <span class="toc-text">06_angr_symbolic_dynamic_memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-angr-symbolic-file"><span class="toc-number">2.8.</span> <span class="toc-text">07_angr_symbolic_file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08-angr-constraints"><span class="toc-number">2.9.</span> <span class="toc-text">08_angr_constraints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09-angr-hooks"><span class="toc-number">2.10.</span> <span class="toc-text">09_angr_hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-angr-simprocedures"><span class="toc-number">2.11.</span> <span class="toc-text">10_angr_simprocedures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-angr-sim-scanf"><span class="toc-number">2.12.</span> <span class="toc-text">11_angr_sim_scanf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-angr-veritesting"><span class="toc-number">2.13.</span> <span class="toc-text">12_angr_veritesting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-angr-static-binary"><span class="toc-number">2.14.</span> <span class="toc-text">13_angr_static_binary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-angr-shared-library"><span class="toc-number">2.15.</span> <span class="toc-text">14_angr_shared_library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-angr-arbitrary-read"><span class="toc-number">2.16.</span> <span class="toc-text">15_angr_arbitrary_read</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-angr-arbitrary-write"><span class="toc-number">2.17.</span> <span class="toc-text">16_angr_arbitrary_write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-angr-arbitrary-jump"><span class="toc-number">2.18.</span> <span class="toc-text">17_angr_arbitrary_jump</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">3.</span> <span class="toc-text">结语</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>