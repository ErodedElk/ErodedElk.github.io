<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Angr 使用技巧速通笔记(一) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Angr 使用技巧速通笔记(一)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-12T11:43:25.000Z" id="date"> 2023-04-12</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.983Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在基本了解了模糊测试以后，接下来就开始看看一直心心念念的符号执行吧。听群友说这个东西的概念在九几年就有了，算是个老东西，不过 Angr 本身倒是挺新的，看看这个工具能不能有什么收获吧。</p>
<p>按照计划，一方面是 Angr 的使用技巧，另一方面是 Angr 的源代码阅读。不过因为两者的内容都挺多的，所以本篇只写使用技巧部分，如果未来有这样的预订，或许还会有另外一篇。希望以我这种菜鸡水平也能看得懂吧。</p>
<h1 id="Angr-的基本描述"><a href="#Angr-的基本描述" class="headerlink" title="Angr 的基本描述"></a>Angr 的基本描述</h1><p>首先在开始解释 <code>Angr</code> 的各个模块和使用之前，我们需要先对<strong>它是如何工作的</strong>有一个大概的认识。</p>
<p>我们一般用 <code>Angr</code> 的目的其实就是为了自动化的求解输入，比如说逆向或是 PWN。而它的原理被称之为“符号执行”。</p>
<p><code>Angr</code> 其实并不是真正被运行起来的，它就向一个虚拟机，会读取每一条命令并在虚拟机中模拟该命令的行为。我们类比到更加常用的 <code>z3</code> 库中，每个寄存器都可以相当与 <code>z3</code> 中的一个变量，在模拟执行的过程中，这个变量会被延伸为一个表达式，而当我们成功找到了目标地址之后，通过表达式就可以求解对应的初值应该是什么了。</p>
<p>看着简单，但是您或许听说过，这类符号执行有一个现今仍为解决的麻烦问题：<strong>路径爆炸</strong>。</p>
<p><code>Angr</code> 被称之为 <code>IR-Based</code> 类的符号执行引擎，他会对输入的二进制重建对应的 CFG ，在完成重建后开始模拟执行。而对于分支语句，就需要分支出两个不同的情况：<code>跳转</code> 和 <code>不跳转</code> 。在一般情况下，这不会引发问题，但是我们可以考虑如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">num=xxx<br>for(int i=0;i&lt;1000;i++)//&lt;---- judge 1<br>&#123;<br>    if(num==0x6666)&#123;//&lt;----- judge 2<br>        break;<br>    &#125;<br>    else&#123;<br>    num+=1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当符号执行引起遇到循环语句，由于循环语句本身就需要判断是否应该跳出循环，因此引擎会在这里开始分叉为两个情况。</p>
<p>而如果这个循环里又嵌套了判断条件，那么就需要再次分叉为两条路径。</p>
<p>也就是说，对于一个人为理解起来相当易懂的循环判断，符号执行引擎却会因此分叉出指数级别增长的分支数量。</p>
<p>但这还不是最简单的情况，我们可以更极端一点考虑这么一个情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while(1)<br>&#123;<br>    if(condition)<br>    &#123;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>循环本身是一个死循环，尽管我们靠自己的思维能够理解，它会在未来的某一个跳出循环，但符号执行引擎却不知道这件事，因此每一次遇到判断跳转都需要进行分叉，最后这个路径就会无限增长，最后把内存挤爆，然后程序崩溃。</p>
<p>说了这么多，其实是为了将清楚一件事，“<strong>符号执行引擎是通过按行读取的方式模拟执行每条机器码，并更新对应变量，最后在通过约束求解的方式去逆推输入初值的</strong>”。</p>
<h1 id="Angr-基本模块"><a href="#Angr-基本模块" class="headerlink" title="Angr 基本模块"></a>Angr 基本模块</h1><p>一般来说，使用 Angr 的基本流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import angr<br>project = angr.Project(path_to_binary, auto_load_libs=False)<br>state = project.factory.entry_state()<br>sim = project.factory.simgr(state)<br>sim.explore(find=target)<br>if simulation.found:<br>    res = simulation.found[0]<br>    res = res.posix.dumps(0)<br>    print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(res.decode(&quot;utf-8&quot;)))<br></code></pre></td></tr></table></figure>

<p>笔者一直以来都是套这个模板对二进制程序一把梭，但既然现在要开始正经思考一下怎么办，总要对里面的各种模块有所了解了。</p>
<h2 id="Project-模块"><a href="#Project-模块" class="headerlink" title="Project 模块"></a>Project 模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">project = angr.Project(path_to_binary, auto_load_libs=False)<br></code></pre></td></tr></table></figure>

<p>对于一个使用 <code>angr.Project</code> 加载的二进制程序，<code>angr</code> 会读取它的一些基本属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; project=angr.Project(&quot;02_angr_find_condition&quot;,auto_load_libs=False)  <br>&gt;&gt;&gt; project.filename  <br>&#x27;02_angr_find_condition&#x27;<br>&gt;&gt;&gt; project.arch  <br>&lt;Arch X86 (LE)&gt;<br>&gt;&gt;&gt; hex(project.entry)  <br>&#x27;0x8048450&#x27;<br></code></pre></td></tr></table></figure>

<p>这些信息会由 <code>angr</code> 自动分析，但是如果你有需要，可以通过 <code>angr.Project</code> 中的其他参数手动进行设定。</p>
<h3 id="Loader-模块"><a href="#Loader-模块" class="headerlink" title="Loader 模块"></a>Loader 模块</h3><p>而对于一个 <code>Project</code> 对象，它拥有一个自己的 <code>Loader</code> ，提供如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; project.loader  <br>&lt;Loaded 02_angr_find_condition, maps [0x8048000:0x8407fff]&gt;<br>&gt;&gt;&gt; project.loader.main_object  <br>&lt;ELF Object 02_angr_find_condition, maps [0x8048000:0x804f03f]&gt;<br>&gt;&gt;&gt; project.loader.all_objects  <br>[&lt;ELF Object 02_angr_find_condition, maps [0x8048000:0x804f03f]&gt;, &lt;ExternObject Object cle##externs, maps [0x8100000:0x8100018]&gt;, &lt;ExternObject Object cle##externs, maps [0x8200000:0x8207fff]&gt;, &lt;ELFTLSObjectV2 Object cle##tls, maps [0x8300000:0x8314807]&gt;, &lt;KernelObject Object cle##kernel, maps [0x8400000:0x8407fff]&gt;]<br></code></pre></td></tr></table></figure>

<p>当然实际的属性不止这些，而且在常规的使用中似乎也用不到这些信息，不过这里为了完整性就一起记录一下吧。</p>
<p>Loader 模块主要是负责记录二进制程序的一些基本信息，包括段、符号、链接等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; obj=project.loader.main_object<br>&gt;&gt;&gt; obj.plt  <br>&#123;&#x27;strcmp&#x27;: 134513616, &#x27;printf&#x27;: 134513632, &#x27;__stack_chk_fail&#x27;: 134513648, &#x27;puts&#x27;: 134513664, &#x27;exit&#x27;: 134513680, &#x27;__libc_start_main&#x27;: 134513696, &#x27;__isoc99_scanf&#x27;: 134513  <br>712, &#x27;__gmon_start__&#x27;: 134513728&#125;<br>&gt;&gt;&gt; obj.sections  <br>&lt;Regions: [&lt;Unnamed  offset 0x0, vaddr 0x0, size 0x0&gt;, &lt;.interp  offset 0x154, vaddr 0x8048154, size 0x13&gt;, &lt;.note.ABI-tag  offset 0x168, vaddr 0x8048168, size 0x20&gt;  <br>, &lt;.note.gnu.build-id  offset 0x188, vaddr 0x8048188, size 0x24&gt;, &lt;.gnu.hash  offset 0x1ac, vaddr 0x80481ac, size 0x20&gt;, &lt;.dynsym  offset 0x1cc, vaddr 0x80481cc, siz  <br>e 0xa0&gt;, &lt;.dynstr  offset 0x26c, vaddr 0x804826c, size 0x91&gt;, &lt;.gnu.version  offset 0x2fe, vaddr 0x80482fe, size 0x14&gt;, &lt;.gnu.version_r  offset 0x314, vaddr 0x804831  <br>4, size 0x40&gt;, &lt;.rel.dyn  offset 0x354, vaddr 0x8048354, size 0x8&gt;, &lt;.rel.plt  offset 0x35c, vaddr 0x804835c, size 0x38&gt;, &lt;.init  offset 0x394, vaddr 0x8048394, size  <br>0x23&gt;, &lt;.plt  offset 0x3c0, vaddr 0x80483c0, size 0x80&gt;, &lt;.plt.got  offset 0x440, vaddr 0x8048440, size 0x8&gt;, &lt;.text  offset 0x450, vaddr 0x8048450, size 0x4ea2&gt;, &lt;  <br>.fini  offset 0x52f4, vaddr 0x804d2f4, size 0x14&gt;, &lt;.rodata  offset 0x5308, vaddr 0x804d308, size 0x39&gt;, &lt;.eh_frame_hdr  offset 0x5344, vaddr 0x804d344, size 0x3c&gt;,  <br>&lt;.eh_frame  offset 0x5380, vaddr 0x804d380, size 0x110&gt;, &lt;.init_array  offset 0x5f08, vaddr 0x804ef08, size 0x4&gt;, &lt;.fini_array  offset 0x5f0c, vaddr 0x804ef0c, size  <br>0x4&gt;, &lt;.jcr  offset 0x5f10, vaddr 0x804ef10, size 0x4&gt;, &lt;.dynamic  offset 0x5f14, vaddr 0x804ef14, size 0xe8&gt;, &lt;.got  offset 0x5ffc, vaddr 0x804effc, size 0x4&gt;, &lt;.go  <br>t.plt  offset 0x6000, vaddr 0x804f000, size 0x28&gt;, &lt;.data  offset 0x6028, vaddr 0x804f028, size 0x15&gt;, &lt;.bss  offset 0x603d, vaddr 0x804f03d, size 0x3&gt;, &lt;.comment   <br>offset 0x603d, vaddr 0x0, size 0x34&gt;, &lt;.shstrtab  offset 0x67fa, vaddr 0x0, size 0x10a&gt;, &lt;.symtab  offset 0x6074, vaddr 0x0, size 0x4d0&gt;, &lt;.strtab  offset 0x6544, va  <br>ddr 0x0, size 0x2b6&gt;]&gt;<br></code></pre></td></tr></table></figure>

<p>对外部库的链接也同样支持查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; project.loader.find_symbol(&#x27;strcmp&#x27;) &amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>&lt;Symbol &quot;strcmp&quot; in cle##externs at 0x8100000&gt;<br>&gt;&gt;&gt; project.loader.find_symbol(&#x27;strcmp&#x27;).rebased_addr  <br>135266304  <br>&gt;&gt;&gt; project.loader.find_symbol(&#x27;strcmp&#x27;).linked_addr  <br>0  <br>&gt;&gt;&gt; project.loader.find_symbol(&#x27;strcmp&#x27;).relative_addr  <br>0<br></code></pre></td></tr></table></figure>

<p>同时也支持一些加载选项：</p>
<ul>
<li>auto_load_libs：是否自动加载程序的依赖</li>
<li>skip_libs：避免加载的库</li>
<li>except_missing_libs：无法解析共享库时是否抛出异常</li>
<li>force_load_libs：强制加载的库</li>
<li>ld_path：共享库的优先搜索搜寻路径</li>
</ul>
<p>我们知道，在一般情况下，加载程序都会将 <code>auto_load_libs</code> 置为 <code>False</code> ，这是因为如果将外部库一并加载，那么 <code>Angr</code> 就也会跟着一起去分析那些库了，这对性能的消耗是比较大的。</p>
<p>而对于一些比较常规的函数，比如说 <code>malloc</code> 、<code>printf</code>、<code>strcpy</code> 等，<code>Angr</code> 内置了一些替代函数去 hook 这些系统库函数，因此即便不去加载 <code>libc.so.6</code> ，也能保证分析的正确性。这部分内容接下来会另说。</p>
<h3 id="factory-模块"><a href="#factory-模块" class="headerlink" title="factory 模块"></a>factory 模块</h3><p>该模块主要负责将 <code>Project</code> 实例化。</p>
<p>我们知道，加载一个二进制程序只是符号执行能够开始的第一步，为了实现符号执行，我们还需要为这个二进制程序去构建符号、执行流等操作。这些操作会由 <code>Angr</code> 帮我们完成，而它也提供一些方法能够让我们获取到它构造的一些细节。</p>
<h4 id="Block-模块"><a href="#Block-模块" class="headerlink" title="Block 模块"></a>Block 模块</h4><p><code>Angr</code> 对程序进行抽象的一个关键步骤就是从二进制机器码去重构 CFG ，而 <code>Block</code> 模块提供了和它抽象出的基本块间的交互接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; project.factory.block(project.entry)  <br>&lt;Block for 0x8048450, 33 bytes&gt;  <br>&gt;&gt;&gt; project.factory.block(project.entry).pp()  <br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_start:  <br>8048450 &amp;nbsp;xor &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ebp, ebp  <br>8048452 &amp;nbsp;pop &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;esi  <br>8048453 &amp;nbsp;mov &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ecx, esp  <br>8048455 &amp;nbsp;and &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;esp, 0xfffffff0  <br>8048458 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;eax  <br>8048459 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;esp  <br>804845a &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;edx  <br>804845b &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;__libc_csu_fini  <br>8048460 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;__libc_csu_init  <br>8048465 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;ecx  <br>8048466 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;esi  <br>8048467 &amp;nbsp;push &amp;nbsp;&amp;nbsp;&amp;nbsp;main  <br>804846c &amp;nbsp;call &amp;nbsp;&amp;nbsp;&amp;nbsp;__libc_start_main<br>&gt;&gt;&gt; project.factory.block(project.entry).instruction_addrs  <br>(134513744, 134513746, 134513747, 134513749, 134513752, 134513753, 134513754, 134513755, 134513760, 134513765, 134513766, 134513767, 134513772)<br></code></pre></td></tr></table></figure>

<p>可以看出 <code>Angr</code> 用 <code>call</code> 指令作为一个基本块的结尾。在 <code>Angr</code> 中，它所识别的基本块和 IDA 里看见的 CFG 有些许不同，它会把所有的跳转都尽可能的当作一个基本块的结尾。</p>
<blockquote>
<p>当然也有无法识别的情况，比如说使用寄存器进行跳转，而寄存器的值是上下文有关的，它有可能是函数开始时传入的一个回调函数，而参数有可能有很多种，因此并不是总能够识别出结果的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; block.  <br>block.BLOCK_MAX_SIZE &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.capstone &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.instructions &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.reset_initial_regs() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.size  <br>block.addr &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.codenode &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.parse( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.serialize() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.thumb  <br>block.arch &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.disassembly &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.parse_from_cmessage( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.serialize_to_cmessage() &amp;nbsp;block.vex  <br>block.bytes &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.instruction_addrs &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.pp( &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.set_initial_regs() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;block.vex_nostmt<br></code></pre></td></tr></table></figure>

<h4 id="State-模块"><a href="#State-模块" class="headerlink" title="State 模块"></a>State 模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; state=project.factory.entry_state()<br>&lt;SimState @ 0x8048450&gt;<br>&gt;&gt;&gt; state.regs.eip  <br>&lt;BV32 0x8048450&gt;<br>&gt;&gt;&gt; state.mem[project.entry].int.resolved  <br>&lt;BV32 0x895eed31&gt;<br>&gt;&gt;&gt; state.mem[0x1000].long = 4<br>&gt;&gt;&gt; state.mem[0x1000].long.resolved  <br>&lt;BV32 0x4&gt;<br></code></pre></td></tr></table></figure>

<p>这个 <code>state</code> 包括了符号实行中所需要的所有符号。</p>
<p>通过 <code>state.regs.eip</code> 可以看出，所有的寄存器都会替换为一个符号。该符号可以由模块自行推算，也可以人为的进行更改。也正因如此，<code>Angr</code> 能够通过条件约束对符号的值进行解方程，从而去计算输入，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; bv = state.solver.BVV(0x2333, 32) &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>&lt;BV32 0x2333&gt;<br>&gt;&gt;&gt; state.solver.eval(bv)  <br>9011<br></code></pre></td></tr></table></figure>

<p>另外还存在一些值，它只有在运行时才能够得知，对于这些值，<code>Angr</code> 会将它标记为 <code>UNINITIALIZED</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; state.regs.edi  <br>WARNING &amp;nbsp; 2023-04-12 17:28:41,490  angr.storage.memory_mixins.default_filler_mixin  The program is accessing register with an unspecified value. This could indicate  <br>unwanted behavior.<br>WARNING &amp;nbsp; 2023-04-12 17:28:41,491  angr.storage.memory_mixins.default_filler_mixin  angr will cope with this by generating an unconstrained symbolic variable and con  <br>tinuing. You can resolve this by:<br>WARNING &amp;nbsp; 2023-04-12 17:28:41,491  angr.storage.memory_mixins.default_filler_mixin  1) setting a value to the initial state  <br>WARNING &amp;nbsp; 2023-04-12 17:28:41,492  angr.storage.memory_mixins.default_filler_mixin  2) adding the state option ZERO_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to make un  <br>known regions hold null<br>WARNING &amp;nbsp; 2023-04-12 17:28:41,492  angr.storage.memory_mixins.default_filler_mixin  3) adding the state option SYMBOL_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to suppr  <br>ess these messages. <br>WARNING &amp;nbsp; 2023-04-12 17:28:41,492  angr.storage.memory_mixins.default_filler_mixin  Filling register edi with 4 unconstrained bytes referenced from 0x8048450 (_start  <br>+0x0 in 02_angr_find_condition (0x8048450))&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>&lt;BV32 reg_edi_1_32&#123;UNINITIALIZED&#125;&gt;<br></code></pre></td></tr></table></figure>

<p>另外值得一提的是，除了 <code>entry_state</code> 外还有其他状态可用于初始化：</p>
<ul>
<li>blank_state：构造一个“空白板”空白状态，其中大部分数据未初始化。当访问未初始化的数据时，将返回一个不受约束的符号值。</li>
<li>entry_state：造一个准备在主二进制文件的入口点执行的状态。</li>
<li>full_init_state：构造一个准备好通过任何需要在主二进制文件入口点之前运行的初始化程序执行的状态，例如，共享库构造函数或预初始化程序。完成这些后，它将跳转到入口点。</li>
<li>call_state：构造一个准备好执行给定函数的状态。</li>
</ul>
<p>这些构造函数都能通过参数 <code>addr</code> 来指定初始时的 <code>rip/eip</code> 地址。而 <code>call_state</code> 可以用这种方式来构造传参：<code>call_state(addr,&amp;nbsp;arg1,&amp;nbsp;arg2,&amp;nbsp;...)</code></p>
<h4 id="Simulation-Managers-模块"><a href="#Simulation-Managers-模块" class="headerlink" title="Simulation Managers 模块"></a>Simulation Managers 模块</h4><p>SM(Simulation Managers)是一个用来管理 <code>State</code> 的模块，它需要为符号指出如何运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; simgr = project.factory.simulation_manager(state)  <br>&lt;SimulationManager with 1 active&gt;  <br>&gt;&gt;&gt; simgr.active  <br>[&lt;SimState @ 0x8048450&gt;]<br></code></pre></td></tr></table></figure>

<p>通过 <code>step</code> 可以让这组模拟执行一个基本块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; simgr.step()  <br>&lt;SimulationManager with 1 active&gt;  <br>&gt;&gt;&gt; simgr.active  <br>[&lt;SimState @ 0x8048420&gt;]<br>&gt;&gt;&gt; simgr.active[0].regs.eip  <br>&lt;BV32 0x8048420&gt;<br></code></pre></td></tr></table></figure>

<p>此时的 <code>eip</code> 对应了 <code>__libc_start_main</code> 的地址。</p>
<p>同样也可以查看此时的模拟内存状态，可以发现它储存了函数的返回地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; simgr.active[0].mem[simgr.active[0].regs.esp].int.resolved &amp;nbsp;&amp;nbsp;  <br>&lt;BV32 0x8048471&gt;<br></code></pre></td></tr></table></figure>

<p>而我们比较熟悉的 <code>simgr</code> 其实就是 <code>simulation_manager</code> 简写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; project.factory.simgr()  <br>&lt;SimulationManager with 1 active&gt;  <br>&gt;&gt;&gt; project.factory.simulation_manager() &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>&lt;SimulationManager with 1 active&gt;<br></code></pre></td></tr></table></figure>

<h4 id="SimProcedure"><a href="#SimProcedure" class="headerlink" title="SimProcedure"></a>SimProcedure</h4><p>在前文中提到过 <code>Angr</code> 会 hook 一些常用的库函数来提高效率。它支持一下这些外部库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; angr.procedures.  <br>angr.procedures.SIM_LIBRARIES &amp;nbsp;&amp;nbsp;angr.procedures.glibc &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.java_util &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.ntdll &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.uclibc  <br>angr.procedures.SIM_PROCEDURES &amp;nbsp;angr.procedures.gnulib &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.posix &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.win32  <br>angr.procedures.SimProcedures &amp;nbsp;&amp;nbsp;angr.procedures.java &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libstdcpp &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.procedure_dict &amp;nbsp;angr.procedures.win_user32  <br>angr.procedures.advapi32 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.java_io &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.linux_kernel &amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.stubs &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>angr.procedures.cgc &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.java_jni &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.linux_loader &amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.testing &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>angr.procedures.definitions &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.java_lang &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.msvcr &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.tracer<br></code></pre></td></tr></table></figure>

<p>以 libc 为例就可以看到，它支持了一部分 libc 中的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; angr.procedures.libc.  <br>angr.procedures.libc.abort &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.fprintf &amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.getuid &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.setvbuf &amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.strstr  <br>angr.procedures.libc.access &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.fputc &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.malloc &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;angr.procedures.libc.snprintf &amp;nbsp;&amp;nbsp;angr.procedures.libc.strtol<br>......<br>由于函数过多，这里就不展示了<br></code></pre></td></tr></table></figure>

<p>因此如果程序中调用了这部分函数，默认情况下就会由 <code>angr.procedures.libc</code> 中实现的函数进行接管。但是请务必注意，官方文档中也有提及，一部分函数的实现并不完善，比如说对 <code>scanf</code> 的格式化字符串支持并不是很好，因此有的时候需要自己编写函数来 hook 它。</p>
<h4 id="hook-模块"><a href="#hook-模块" class="headerlink" title="hook 模块"></a>hook 模块</h4><p>紧接着上文提到的问题，<code>Angr</code> 接受由用户自定义函数来进行 hook 的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; func=angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;scanf&#x27;]<br>&gt;&gt;&gt; project.hook(0x10000, func())<br>&gt;&gt;&gt; project.hooked_by(0x10000) &amp;nbsp;&amp;nbsp;&amp;nbsp;  <br>&lt;SimProcedure scanf&gt;<br>&gt;&gt;&gt; project.unhook(0x10000)<br>&gt;&gt;&gt; project.hooked_by(0x10000)  <br>WARNING &amp;nbsp; 2023-04-12 19:20:39,782  angr.project &amp;nbsp;&amp;nbsp; Address 0x10000 is not hooked<br></code></pre></td></tr></table></figure>

<p>第一种方案是直接对地址进行 hook，通过直接使用 <code>project.hook(addr,function())</code> 的方法直接钩取。</p>
<p>同时，<code>Angr</code> 对于有符号的二进制程序也运行直接对符号本身进行钩取：<code>project.hook_symbol(name,function)</code> 。</p>
<h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><blockquote>
<p>angr 系列教程(一）核心概念及模块解读<br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7117">https://xz.aliyun.com/t/7117</a></p>
<p>angr documentation<br><a target="_blank" rel="noopener" href="https://docs.angr.io/en/latest/quickstart.html">https://docs.angr.io/en/latest/quickstart.html</a></p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/16/angr-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E9%80%9F%E9%80%9A%E7%AC%94%E8%AE%B0%E4%BA%8C/">← Next Angr 使用技巧速通笔记(二)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/12/aflsourcecodeview/">AFL 源代码速通笔记 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Angr-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">Angr 的基本描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Angr-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">Angr 基本模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">Project 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">Loader 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#factory-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.2.</span> <span class="toc-text">factory 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">Block 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">State 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simulation-Managers-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">Simulation Managers 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimProcedure"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">SimProcedure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hook-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">hook 模块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text">参考阅读</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>