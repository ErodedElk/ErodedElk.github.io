<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>AFL 源代码速通笔记 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>AFL 源代码速通笔记</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-12T11:42:17.000Z" id="date"> 2023-04-12</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.982Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h1 id="AFL-源代码速通笔记"><a href="#AFL-源代码速通笔记" class="headerlink" title="AFL 源代码速通笔记"></a>AFL 源代码速通笔记</h1><p>因为认识的师傅们都开始卷 fuzz 了，迫于生活压力，于是也开始看这方面的内容了。由于 AFL 作为一个现在仍然适用且比较经典的 fuzzer，因此笔者也打算从它开始。</p>
<blockquote>
<p>本来，本篇博文叫做 《AFL 源代码阅读笔记》，结果跟着大佬们的笔记去读（sakura师傅的笔记确实是神中神，本文也有很多地方照搬了师傅的原文，因为说实话我觉得自己也写不到那么详细），囫囵吞枣般速通了，前前后后三天时间这样，但感觉自己尚且没有自己实现的能力，还是比较令人失望的（我怎么这么菜）</p>
</blockquote>
<hr>
<h2 id="afl-gcc-原理"><a href="#afl-gcc-原理" class="headerlink" title="afl-gcc 原理"></a>afl-gcc 原理</h2><p>首先，一般我们用 afl 去 fuzz 一些项目的时候都需要用 afl-gcc 去代替 gcc 进行编译。先说结论，这一步的目的其实是为了<strong>向代码中插桩</strong>，完成插桩后其实还是<strong>调用原生的 gcc 进行编译</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">其实这个描述有些偏颇，插桩其实是 afl-as 负责的，不过在这里，笔者将 afl-gcc 和 afl-as 放到同一节，因此用了这样的表述，下文会具体分析 afl-as 的原理。<br></code></pre></td></tr></table></figure>

<p>首先需要说明的是，gcc 对代码的编译流程的分层次的：</p>
<blockquote>
<p>源代码–&gt;预编译后的源代码–&gt;汇编代码–&gt;机器码–&gt;链接后的二进制文件</p>
</blockquote>
<p>其中，从源代码到汇编代码的步骤由 gcc 完成；而汇编代码到机器码的部分由 as 完成。</p>
<p>而 afl-gcc 的源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int main(int argc, char** argv) &#123;<br>  .......<br><br>  find_as(argv[0]);<br>  edit_params(argc, argv);<br>  execvp(cc_params[0], (char**)cc_params);<br>  FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, cc_params[0]);<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>find_as：查找 as 这个二进制程序，用 afl-as 替换它</li>
<li>edit_params：修改参数</li>
<li>execvp：调用原生 gcc 对代码进行编译</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void edit_params(u32 argc, char** argv) &#123;<br>    ......<br>#else<br><br>    if (!strcmp(name, &quot;afl-g++&quot;)) &#123;<br>      u8* alt_cxx = getenv(&quot;AFL_CXX&quot;);<br>      cc_params[0] = alt_cxx ? alt_cxx : (u8*)&quot;g++&quot;;<br>    &#125; else if (!strcmp(name, &quot;afl-gcj&quot;)) &#123;<br>      u8* alt_cc = getenv(&quot;AFL_GCJ&quot;);<br>      cc_params[0] = alt_cc ? alt_cc : (u8*)&quot;gcj&quot;;<br>    &#125; else &#123;<br>      u8* alt_cc = getenv(&quot;AFL_CC&quot;);<br>      cc_params[0] = alt_cc ? alt_cc : (u8*)&quot;gcc&quot;;<br>    &#125;<br><br>#endif /* __APPLE__ */<br><br>  &#125;<br><br>  while (--argc) &#123;<br>    u8* cur = *(++argv);<br><br>    if (!strncmp(cur, &quot;-B&quot;, 2)) &#123;<br><br>      if (!be_quiet) WARNF(&quot;-B is already set, overriding&quot;);<br><br>      if (!cur[2] &amp;&amp; argc &gt; 1) &#123; argc--; argv++; &#125;<br>      continue;<br><br>    &#125;<br><br>    if (!strcmp(cur, &quot;-integrated-as&quot;)) continue;<br><br>    if (!strcmp(cur, &quot;-pipe&quot;)) continue;<br><br>#if defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)<br>    if (!strcmp(cur, &quot;-m32&quot;)) m32_set = 1;<br>#endif<br><br>    if (!strcmp(cur, &quot;-fsanitize=address&quot;) <br>        !strcmp(cur, &quot;-fsanitize=memory&quot;)) asan_set = 1;<br><br>    if (strstr(cur, &quot;FORTIFY_SOURCE&quot;)) fortify_set = 1;<br><br>    cc_params[cc_par_cnt++] = cur;<br><br>  &#125;<br><br>  cc_params[cc_par_cnt++] = &quot;-B&quot;;<br>  cc_params[cc_par_cnt++] = as_path;<br><br>  if (clang_mode)<br>    cc_params[cc_par_cnt++] = &quot;-no-integrated-as&quot;;<br><br>  if (getenv(&quot;AFL_HARDEN&quot;)) &#123;<br><br>    cc_params[cc_par_cnt++] = &quot;-fstack-protector-all&quot;;<br><br>    if (!fortify_set)<br>      cc_params[cc_par_cnt++] = &quot;-D_FORTIFY_SOURCE=2&quot;;<br><br>  &#125;<br><br>  if (asan_set) &#123;<br><br>    /* Pass this on to afl-as to adjust map density. */<br><br>    setenv(&quot;AFL_USE_ASAN&quot;, &quot;1&quot;, 1);<br><br>  &#125; else if (getenv(&quot;AFL_USE_ASAN&quot;)) &#123;<br><br>    if (getenv(&quot;AFL_USE_MSAN&quot;))<br>      FATAL(&quot;ASAN and MSAN are mutually exclusive&quot;);<br><br>    if (getenv(&quot;AFL_HARDEN&quot;))<br>      FATAL(&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;);<br><br>    cc_params[cc_par_cnt++] = &quot;-U_FORTIFY_SOURCE&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fsanitize=address&quot;;<br><br>  &#125; else if (getenv(&quot;AFL_USE_MSAN&quot;)) &#123;<br><br>    if (getenv(&quot;AFL_USE_ASAN&quot;))<br>      FATAL(&quot;ASAN and MSAN are mutually exclusive&quot;);<br><br>    if (getenv(&quot;AFL_HARDEN&quot;))<br>      FATAL(&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;);<br><br>    cc_params[cc_par_cnt++] = &quot;-U_FORTIFY_SOURCE&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fsanitize=memory&quot;;<br>  &#125;<br><br>  if (!getenv(&quot;AFL_DONT_OPTIMIZE&quot;)) &#123;<br><br>#if defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)<br><br>    /* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself<br>       works OK. This has nothing to do with us, but let&#x27;s avoid triggering<br>       that bug. */<br><br>    if (!clang_mode  !m32_set)<br>      cc_params[cc_par_cnt++] = &quot;-g&quot;;<br>#else<br>      cc_params[cc_par_cnt++] = &quot;-g&quot;;<br>#endif<br><br>    cc_params[cc_par_cnt++] = &quot;-O3&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-funroll-loops&quot;;<br><br>    /* Two indicators that you&#x27;re building for fuzzing; one of them is<br>       AFL-specific, the other is shared with libfuzzer. */<br><br>    cc_params[cc_par_cnt++] = &quot;-D__AFL_COMPILER=1&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;;<br><br>  &#125;<br><br>  if (getenv(&quot;AFL_NO_BUILTIN&quot;)) &#123;<br><br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strcmp&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strncmp&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strcasecmp&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strncasecmp&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-memcmp&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strstr&quot;;<br>    cc_params[cc_par_cnt++] = &quot;-fno-builtin-strcasestr&quot;;<br><br>  &#125;<br>  cc_params[cc_par_cnt] = NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>挺长的，不过逻辑基本上都是重复的，主要做两件事：</p>
<ul>
<li>给 gcc 添加一些额外的参数</li>
<li>根据参数设置一些 flag</li>
</ul>
<p>在完成了汇编以后，接下来会使用 afl-as 对生成的汇编代码进行插桩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int main(int argc, char** argv) &#123;<br>  ......<br><br>  gettimeofday(&amp;tv, &amp;tz);<br>  rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();<br>  srandom(rand_seed);<br><br>  edit_params(argc, argv);<br><br>  ......<br><br>  if (!just_version) add_instrumentation();<br><br>  if (!(pid = fork())) &#123;<br><br>    execvp(as_params[0], (char**)as_params);<br>    FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, as_params[0]);<br><br>  &#125;<br><br>  if (pid &lt; 0) PFATAL(&quot;fork() failed&quot;);<br><br>  if (waitpid(pid, &amp;status, 0) &lt;= 0) PFATAL(&quot;waitpid() failed&quot;);<br><br>  if (!getenv(&quot;AFL_KEEP_ASSEMBLY&quot;)) unlink(modified_file);<br><br>  exit(WEXITSTATUS(status));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>afl-as</code> 中，仍然使用 <code>edit_params</code> 编辑和修改参数，并使用 <code>add_instrumentation</code> 来对生成的汇编代码进行插桩。完成插桩后，用 fork 生成子进程，并调用原生的 as 进行编译。</p>
<p>插桩逻辑也很朴素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void add_instrumentation(void) &#123;<br>    ......<br><br>    /* If we&#x27;re in the right mood for instrumenting, check for function<br>       names or conditional labels. This is a bit messy, but in essence,<br>       we want to catch:<br><br>         ^main:      - function entry point (always instrumented)<br>         ^.L0:       - GCC branch label<br>         ^.LBB0_0:   - clang branch label (but only in clang mode)<br>         ^\tjnz foo  - conditional branches<br><br>       ...but not:<br><br>         ^# BB#0:    - clang comments<br>         ^ # BB#0:   - ditto<br>         ^.Ltmp0:    - clang non-branch labels<br>         ^.LC0       - GCC non-branch labels<br>         ^.LBB0_0:   - ditto (when in GCC mode)<br>         ^\tjmp foo  - non-conditional jumps<br><br>       Additionally, clang and GCC on MacOS X follow a different convention<br>       with no leading dots on labels, hence the weird maze of #ifdefs<br>       later on.<br><br>     */<br><br>    if (skip_intel  skip_app  skip_csect  !instr_ok <br>        line[0] == &#x27;#&#x27;  line[0] == &#x27; &#x27;) continue;<br><br>    /* Conditional branch instruction (jnz, etc). We append the instrumentation<br>       right after the branch (to instrument the not-taken path) and at the<br>       branch destination label (handled later on). */<br><br>    if (line[0] == &#x27;\t&#x27;) &#123;<br><br>      if (line[1] == &#x27;j&#x27; &amp;&amp; line[2] != &#x27;m&#x27; &amp;&amp; R(100) &lt; inst_ratio) &#123;<br><br>        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,<br>                R(MAP_SIZE));<br><br>        ins_lines++;<br><br>      &#125;<br><br>      continue;<br><br>    &#125;<br><br>    /* Label of some sort. This may be a branch destination, but we need to<br>       tread carefully and account for several different formatting<br>       conventions. */<br><br>#ifdef __APPLE__<br><br>    /* Apple: L&lt;whatever&gt;&lt;digit&gt;: */<br><br>    if ((colon_pos = strstr(line, &quot;:&quot;))) &#123;<br><br>      if (line[0] == &#x27;L&#x27; &amp;&amp; isdigit(*(colon_pos - 1))) &#123;<br><br>#else<br><br>    /* Everybody else: .L&lt;whatever&gt;: */<br><br>    if (strstr(line, &quot;:&quot;)) &#123;<br><br>      if (line[0] == &#x27;.&#x27;) &#123;<br><br>#endif /* __APPLE__ */<br><br>        /* .L0: or LBB0_0: style jump destination */<br><br>#ifdef __APPLE__<br><br>        /* Apple: L&lt;num&gt; / LBB&lt;num&gt; */<br><br>        if ((isdigit(line[1])  (clang_mode &amp;&amp; !strncmp(line, &quot;LBB&quot;, 3)))<br>            &amp;&amp; R(100) &lt; inst_ratio) &#123;<br><br>#else<br>        /* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */<br>        if ((isdigit(line[2])  (clang_mode &amp;&amp; !strncmp(line + 1, &quot;LBB&quot;, 3)))<br>            &amp;&amp; R(100) &lt; inst_ratio) &#123;<br>#endif /* __APPLE__ */<br><br>          /* An optimization is possible here by adding the code only if the<br>             label is mentioned in the code in contexts other than call / jmp.<br>             That said, this complicates the code by requiring two-pass<br>             processing (messy with stdin), and results in a speed gain<br>             typically under 10%, because compilers are generally pretty good<br>             about not generating spurious intra-function jumps.<br><br>             We use deferred output chiefly to avoid disrupting<br>             .Lfunc_begin0-style exception handling calculations (a problem on<br>             MacOS X). */<br><br>          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;<br>        &#125;<br>      &#125; else &#123;<br>        /* Function label (always instrumented, deferred mode). */<br>        instrument_next = 1;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  if (ins_lines)<br>    fputs(use_64bit ? main_payload_64 : main_payload_32, outf);<br><br>  if (input_file) fclose(inf);<br>  fclose(outf);<br><br>  if (!be_quiet) &#123;<br><br>    if (!ins_lines) WARNF(&quot;No instrumentation targets found%s.&quot;,<br>                          pass_thru ? &quot; (pass-thru mode)&quot; : &quot;&quot;);<br>    else OKF(&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;,<br>             ins_lines, use_64bit ? &quot;64&quot; : &quot;32&quot;,<br>             getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; : <br>             (sanitizer ? &quot;ASAN/MSAN&quot; : &quot;non-hardened&quot;),<br>             inst_ratio);<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>简单来说就是一个循环读取每行汇编代码，并对特定的汇编代码进行插桩：</p>
<ul>
<li>首先需要保证代码位于 <code>text</code> 内存段</li>
<li>如果是 <code>main</code> 函数或分支跳转指令则进行插桩</li>
<li>如果是注释或强制跳转指令则不插桩</li>
</ul>
<p>插桩的具体代码保存在 <code>afl-as.h</code> 中，在最后一节中笔者会另外介绍，这里我们可以暂时忽略它的实现细节继续往下。</p>
<h2 id="afl-fuzz"><a href="#afl-fuzz" class="headerlink" title="afl-fuzz"></a>afl-fuzz</h2><p>按照顺序，现在程序是编译好了，接下来就要用 <code>afl-fuzz</code> 对它进行模糊测试了。</p>
<p>一般来说，我们会用 <code>afl-fuzz -i input -o output -- programe</code> 启动 fuzzer，对应的，<code>afl-fuzz.c</code> 中的前半部分都在做参数解析的工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int main(int argc, char** argv) &#123;<br>  ......<br><br>  gettimeofday(&amp;tv, &amp;tz);<br>  srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());<br><br>  while ((opt = getopt(argc, argv, &quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;)) &gt; 0)<br><br>    switch (opt) &#123;<br><br>      case &#x27;i&#x27;: /* input dir */<br><br>        if (in_dir) FATAL(&quot;Multiple -i options not supported&quot;);<br>        in_dir = optarg;<br><br>        if (!strcmp(in_dir, &quot;-&quot;)) in_place_resume = 1;<br><br>        break;<br><br>      case &#x27;o&#x27;: /* output dir */<br><br>        if (out_dir) FATAL(&quot;Multiple -o options not supported&quot;);<br>        out_dir = optarg;<br>        break;<br><br>    ......<br><br>      case &#x27;V&#x27;: /* Show version number */<br><br>        /* Version number has been printed already, just quit. */<br>        exit(0);<br><br>      default:<br>        usage(argv[0]);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这部分我们大致看一下就行了，主要的关注点自然不在参数解析部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int main(int argc, char** argv) &#123;<br>  ......<br><br>  setup_signal_handlers();<br>  check_asan_opts();<br><br>  if (sync_id) fix_up_sync();<br><br>  if (!strcmp(in_dir, out_dir))<br>    FATAL(&quot;Input and output directories can&#x27;t be the same&quot;);<br><br>  if (dumb_mode) &#123;<br><br>    if (crash_mode) FATAL(&quot;-C and -n are mutually exclusive&quot;);<br>    if (qemu_mode)  FATAL(&quot;-Q and -n are mutually exclusive&quot;);<br><br>  &#125;<br><br>  if (getenv(&quot;AFL_NO_FORKSRV&quot;))    no_forkserver    = 1;<br>  if (getenv(&quot;AFL_NO_CPU_RED&quot;))    no_cpu_meter_red = 1;<br>  if (getenv(&quot;AFL_NO_ARITH&quot;))      no_arith         = 1;<br>  if (getenv(&quot;AFL_SHUFFLE_QUEUE&quot;)) shuffle_queue    = 1;<br>  if (getenv(&quot;AFL_FAST_CAL&quot;))      fast_cal         = 1;<br><br>  if (getenv(&quot;AFL_HANG_TMOUT&quot;)) &#123;<br>    hang_tmout = atoi(getenv(&quot;AFL_HANG_TMOUT&quot;));<br>    if (!hang_tmout) FATAL(&quot;Invalid value of AFL_HANG_TMOUT&quot;);<br>  &#125;<br><br>  if (dumb_mode == 2 &amp;&amp; no_forkserver)<br>    FATAL(&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;);<br><br>  if (getenv(&quot;AFL_PRELOAD&quot;)) &#123;<br>    setenv(&quot;LD_PRELOAD&quot;, getenv(&quot;AFL_PRELOAD&quot;), 1);<br>    setenv(&quot;DYLD_INSERT_LIBRARIES&quot;, getenv(&quot;AFL_PRELOAD&quot;), 1);<br>  &#125;<br><br>  if (getenv(&quot;AFL_LD_PRELOAD&quot;))<br>    FATAL(&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;);<br><br>  save_cmdline(argc, argv);<br><br>  fix_up_banner(argv[optind]);<br><br>  check_if_tty();<br><br>  get_core_count();<br><br>#ifdef HAVE_AFFINITY<br>  bind_to_free_cpu();<br>#endif /* HAVE_AFFINITY */<br><br>  check_crash_handling();<br>  check_cpu_governor();<br><br>  setup_post();<br>  setup_shm();<br>  init_count_class16();<br><br>  setup_dirs_fds();<br>  read_testcases();<br>  load_auto();<br><br>  pivot_inputs();<br><br>  if (extras_dir) load_extras(extras_dir);<br><br>  if (!timeout_given) find_timeout();<br><br>  detect_file_args(argv + optind + 1);<br><br>  if (!out_file) setup_stdio_file();<br><br>  check_binary(argv[optind]);<br><br>  start_time = get_cur_time();<br><br>  if (qemu_mode)<br>    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);<br>  else<br>    use_argv = argv + optind;<br><br>  perform_dry_run(use_argv);<br><br>  cull_queue();<br><br>  show_init_stats();<br><br>  seek_to = find_start_position();<br><br>  write_stats_file(0, 0, 0);<br>  save_auto();<br><br>  if (stop_soon) goto stop_fuzzing;<br><br>  /* Woop woop woop */<br><br>  if (!not_on_tty) &#123;<br>    sleep(4);<br>    start_time += 4000;<br>    if (stop_soon) goto stop_fuzzing;<br>  &#125;<br><br>  while (1) &#123;<br><br>    u8 skipped_fuzz;<br><br>    cull_queue();<br><br>    if (!queue_cur) &#123;<br><br>      queue_cycle++;<br>      current_entry     = 0;<br>      cur_skipped_paths = 0;<br>      queue_cur         = queue;<br><br>      while (seek_to) &#123;<br>        current_entry++;<br>        seek_to--;<br>        queue_cur = queue_cur-&gt;next;<br>      &#125;<br><br>      show_stats();<br><br>      if (not_on_tty) &#123;<br>        ACTF(&quot;Entering queue cycle %llu.&quot;, queue_cycle);<br>        fflush(stdout);<br>      &#125;<br><br>      /* If we had a full queue cycle with no new finds, try<br>         recombination strategies next. */<br><br>      if (queued_paths == prev_queued) &#123;<br><br>        if (use_splicing) cycles_wo_finds++; else use_splicing = 1;<br><br>      &#125; else cycles_wo_finds = 0;<br><br>      prev_queued = queued_paths;<br><br>      if (sync_id &amp;&amp; queue_cycle == 1 &amp;&amp; getenv(&quot;AFL_IMPORT_FIRST&quot;))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    skipped_fuzz = fuzz_one(use_argv);<br><br>    if (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<br><br>      if (!(sync_interval_cnt++ % SYNC_INTERVAL))<br>        sync_fuzzers(use_argv);<br><br>    &#125;<br><br>    if (!stop_soon &amp;&amp; exit_1) stop_soon = 2;<br><br>    if (stop_soon) break;<br><br>    queue_cur = queue_cur-&gt;next;<br>    current_entry++;<br><br>  &#125;<br><br>  if (queue_cur) show_stats();<br><br>  /* If we stopped programmatically, we kill the forkserver and the current runner. <br>     If we stopped manually, this is done by the signal handler. */<br>  if (stop_soon == 2) &#123;<br>      if (child_pid &gt; 0) kill(child_pid, SIGKILL);<br>      if (forksrv_pid &gt; 0) kill(forksrv_pid, SIGKILL);<br>  &#125;<br>  /* Now that we&#x27;ve killed the forkserver, we wait for it to be able to get rusage stats. */<br>  if (waitpid(forksrv_pid, NULL, 0) &lt;= 0) &#123;<br>    WARNF(&quot;error waitpid\n&quot;);<br>  &#125;<br><br>  write_bitmap();<br>  write_stats_file(0, 0, 0);<br>  save_auto();<br><br>stop_fuzzing:<br><br>  SAYF(CURSOR_SHOW cLRD &quot;\n\n+++ Testing aborted %s +++\n&quot; cRST,<br>       stop_soon == 2 ? &quot;programmatically&quot; : &quot;by user&quot;);<br><br>  /* Running for more than 30 minutes but still doing first cycle? */<br><br>  if (queue_cycle == 1 &amp;&amp; get_cur_time() - start_time &gt; 30 * 60 * 1000) &#123;<br><br>    SAYF(&quot;\n&quot; cYEL &quot;[!] &quot; cRST<br>           &quot;Stopped during the first cycle, results may be incomplete.\n&quot;<br>           &quot;    (For info on resuming, see %s/README.)\n&quot;, doc_path);<br><br>  &#125;<br><br>  fclose(plot_file);<br>  destroy_queue();<br>  destroy_extras();<br>  ck_free(target_path);<br>  ck_free(sync_id);<br><br>  alloc_report();<br><br>  OKF(&quot;We&#x27;re done here. Have a nice day!\n&quot;);<br><br>  exit(0);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p>设置一些信号处理函数，比如说退出信号时要主动释放子进程、窗口大小调整时要跟踪变化等。</p>
<h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h3><p>读取环境变量ASAN_OPTIONS和MSAN_OPTIONS，做一些检查</p>
<h3 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h3><p>略</p>
<h3 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h3><p>保存当前的命令</p>
<h3 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h3><p>创建一个 banner</p>
<h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h3><p>检查是否在tty终端上面运行。</p>
<h3 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h3><p>计数logical CPU cores。</p>
<h3 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h3><p>检查崩溃处理函数，确保崩溃后不会进入程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">s32 fd = open(&quot;/proc/sys/kernel/core_pattern&quot;, O_RDONLY);<br>u8  fchar;<br>if (fd &lt; 0) return;<br>ACTF(&quot;Checking core_pattern...&quot;);<br>if (read(fd, &amp;fchar, 1) == 1 &amp;&amp; fchar == &#x27;&#x27;) &#123;<br>  SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>       &quot;Hmm, your system is configured to send core dump notifications to an\n&quot;<br>       &quot;    external utility. This will cause issues: there will be an extended delay\n&quot;<br>       &quot;    between stumbling upon a crash and having this information relayed to the\n&quot;<br>       &quot;    fuzzer via the standard waitpid() API.\n\n&quot;<br><br>       &quot;    To avoid having crashes misinterpreted as timeouts, please log in as root\n&quot; <br>       &quot;    and temporarily modify /proc/sys/kernel/core_pattern, like so:\n\n&quot;<br><br>       &quot;    echo core &gt;/proc/sys/kernel/core_pattern\n&quot;);<br><br>  if (!getenv(&quot;AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES&quot;))<br>    FATAL(&quot;Pipe at the beginning of &#x27;core_pattern&#x27;&quot;);<br>&#125;<br>close(fd);<br></code></pre></td></tr></table></figure>

<p>笔者在 Ubuntu20 上跑 AFL 就会遇到这个问题，因为在默认情况下，系统会将崩溃信息通过管道发送给外部程序，由于这会影响到效率，因此通过 <code>echo core &gt;/proc/sys/kernel/core_pattern</code> 修改保存崩溃信息的方式，将它保存为本地文件。</p>
<h3 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h3><p>检查<code>cpu</code>的调节器，来使得<code>cpu</code>可以处于高效的运行状态。</p>
<h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h3><p>如果用户指定了环境变量 <code>AFL_POST_LIBRARY</code> ，那么就会从对应的路径下加载动态库并加载 <code>afl_postprocess</code> 函数并保存在 <code>post_handler</code> 中。</p>
<h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">EXP_ST void setup_shm(void) &#123;<br>  u8* shm_str;<br>  if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);<br>  memset(virgin_tmout, 255, MAP_SIZE);<br>  memset(virgin_crash, 255, MAP_SIZE);<br>  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT  IPC_EXCL  0600);<br>  if (shm_id &lt; 0) PFATAL(&quot;shmget() failed&quot;);<br>  atexit(remove_shm);<br>  shm_str = alloc_printf(&quot;%d&quot;, shm_id);<br>  /* If somebody is asking us to fuzz instrumented binaries in dumb mode,<br>     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending<br>     fork server commands. This should be replaced with better auto-detection<br>     later on, perhaps? */<br>  if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);<br>  ck_free(shm_str);<br>  trace_bits = shmat(shm_id, NULL, 0);<br>  if (trace_bits == (void *)-1) PFATAL(&quot;shmat() failed&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>初始化 <code>virgin_bits</code> 数组用于保存后续模糊测试中覆盖的路径，<code>virgin_tmout</code> 保存超时的路径，<code>virgin_crash</code> 保存崩溃的路径。</p>
<p>同时建立共享内存 <code>trace_bits</code>，该变量用于储存样例运行时的路径。</p>
<p>同时将共享内存的唯一标识符 <code>shm_id</code> 转为字符串后保存在环境变量 <code>SHM_ENV_VAR</code> 中。</p>
<h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h3><p>初始化<code>count_class_lookup16</code>数组，帮助快速归类统计路径覆盖的数量。</p>
<h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h3><p>创建输出目录。</p>
<h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h3><p>读取测试样例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void read_testcases(void) &#123;<br><br>  struct dirent **nl;<br>  s32 nl_cnt;<br>  u32 i;<br>  u8* fn;<br><br>  /* Auto-detect non-in-place resumption attempts. */<br><br>  fn = alloc_printf(&quot;%s/queue&quot;, in_dir);<br>  if (!access(fn, F_OK)) in_dir = fn; else ck_free(fn);<br><br>  ACTF(&quot;Scanning &#x27;%s&#x27;...&quot;, in_dir);<br><br>  /* We use scandir() + alphasort() rather than readdir() because otherwise,<br>     the ordering  of test cases would vary somewhat randomly and would be<br>     difficult to control. */<br><br>  nl_cnt = scandir(in_dir, &amp;nl, NULL, alphasort);<br><br>  if (nl_cnt &lt; 0) &#123;<br><br>    if (errno == ENOENT  errno == ENOTDIR)<br><br>      SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>           &quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;<br>           &quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;<br>           &quot;    or so. The cases must be stored as regular files directly in the input\n&quot;<br>           &quot;    directory.\n&quot;);<br><br>    PFATAL(&quot;Unable to open &#x27;%s&#x27;&quot;, in_dir);<br><br>  &#125;<br><br>  if (shuffle_queue &amp;&amp; nl_cnt &gt; 1) &#123;<br><br>    ACTF(&quot;Shuffling queue...&quot;);<br>    shuffle_ptrs((void**)nl, nl_cnt);<br><br>  &#125;<br><br>  for (i = 0; i &lt; nl_cnt; i++) &#123;<br><br>    struct stat st;<br><br>    u8* fn = alloc_printf(&quot;%s/%s&quot;, in_dir, nl[i]-&gt;d_name);<br>    u8* dfn = alloc_printf(&quot;%s/.state/deterministic_done/%s&quot;, in_dir, nl[i]-&gt;d_name);<br><br>    u8  passed_det = 0;<br><br>    free(nl[i]); /* not tracked */<br><br>    if (lstat(fn, &amp;st)  access(fn, R_OK))<br>      PFATAL(&quot;Unable to access &#x27;%s&#x27;&quot;, fn);<br><br>    /* This also takes care of . and .. */<br><br>    if (!S_ISREG(st.st_mode)  !st.st_size  strstr(fn, &quot;/README.testcases&quot;)) &#123;<br><br>      ck_free(fn);<br>      ck_free(dfn);<br>      continue;<br><br>    &#125;<br><br>    if (st.st_size &gt; MAX_FILE) <br>      FATAL(&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;, fn,<br>            DMS(st.st_size), DMS(MAX_FILE));<br><br>    /* Check for metadata that indicates that deterministic fuzzing<br>       is complete for this entry. We don&#x27;t want to repeat deterministic<br>       fuzzing when resuming aborted scans, because it would be pointless<br>       and probably very time-consuming. */<br><br>    if (!access(dfn, F_OK)) passed_det = 1;<br>    ck_free(dfn);<br><br>    add_to_queue(fn, st.st_size, passed_det);<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先获取输入样例的文件夹路径 <code>in_dir</code></li>
<li>扫描 <code>in_dir</code>，如果目录下文件的数量少于等于 0 则报错</li>
<li>如果设置了 <code>shuffle_queue</code> 就打乱顺序</li>
<li>遍历所有文件名，保存在 <code>fn</code> 中</li>
<li>过滤掉 <code>.</code> 和 <code>..</code> 这样的路径</li>
<li>如果文件的大小超过了 <code>MAX_FILE</code> 则终止</li>
<li><code>add_to_queue</code></li>
</ul>
<h4 id="add-to-queue"><a href="#add-to-queue" class="headerlink" title="add_to_queue"></a>add_to_queue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void add_to_queue(u8* fname, u32 len, u8 passed_det) &#123;<br><br>  struct queue_entry* q = ck_alloc(sizeof(struct queue_entry));<br>  q-&gt;fname        = fname;<br>  q-&gt;len          = len;<br>  q-&gt;depth        = cur_depth + 1;<br>  q-&gt;passed_det   = passed_det;<br><br>  if (q-&gt;depth &gt; max_depth) max_depth = q-&gt;depth;<br><br>  if (queue_top) &#123;<br><br>    queue_top-&gt;next = q;<br>    queue_top = q;<br><br>  &#125; else q_prev100 = queue = queue_top = q;<br><br>  queued_paths++;<br>  pending_not_fuzzed++;<br><br>  cycles_wo_finds = 0;<br><br>  /* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */<br>  if ((queued_paths - 1) % 100 == 0 &amp;&amp; queued_paths &gt; 1) &#123;<br><br>    q_prev100-&gt;next_100 = q;<br>    q_prev100 = q;<br><br>  &#125;<br>  last_path_time = get_cur_time();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>afl-fuzz</code> 维护一个 <code>queue_entry</code> 的链表，该链表用来保存测试样例，每次调用 <code>add_to_queue</code> 都会将新样例储存到链表头部。</p>
<p>另外还有一个 <code>q_prev100</code> 也是 <code>queue_entry</code> 的链表，但它每 100 个测试样例保存一次。</p>
<h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h3><p>尝试在输入目录下寻找自动生成的字典文件，调用 <code>maybe_add_auto</code> 将相应的字典加入到全局变量 <code>a_extras</code> 中，用于后续字典模式的变异当中。</p>
<h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h3><p>在输出文件夹中创建与输入样例间的硬链接，称之为 <code>orignal</code> 。</p>
<h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h3><p>如果指定了 <code>-x</code> 参数（字典模式），加载对应的字典到全局变量<code>extras</code>当中，用于后续字典模式的变异当中。</p>
<h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h3><p>如果指定了 <code>resuming_fuzz</code> ，即从输出目录当中恢复模糊测试状态，会从之前的模糊测试状态 <code>fuzzer_stats</code> 文件中计算中 <code>timeout</code> 值，保存在 <code>exec_tmout</code> 中。</p>
<h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h3><p>检测输入的命令行中是否包含<code>@@</code>参数，如果包含的话需要将 <code>@@</code> 替换成目录文件 <code>&quot;%s/.cur_input&quot;, out_dir</code> ，使得模糊测试目标程序的命令完整；同时将目录文件 <code>&quot;%s/.cur_input&quot;</code> 路径保存在 <code>out_file</code> 当中，后续变异的内容保存在该文件路径中，用于运行测试目标文件。</p>
<h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h3><p>如果目标程序的输入不是来源于文件而是来源于标准输入的话，则将目录文件 <code>&quot;%s/.cur_input&quot;</code> 文件打开保存在 <code>out_fd</code> 文件句柄中，后续将标准输入重定向到该文件中；结合 <code>detect_file_args</code> 函数实现了将变异的内容保存在 <code>&quot;%s/.cur_input&quot;</code> 文件中，运行目标测试文件并进行模糊测试。</p>
<h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h3><p>检查二进制文件是否合法。</p>
<h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h3><p>将每个测试样例作为输入去运行目标程序，检查程序是否能够正常工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void perform_dry_run(char** argv) &#123;<br><br>  struct queue_entry* q = queue;<br>  u32 cal_failures = 0;<br>  u8* skip_crashes = getenv(&quot;AFL_SKIP_CRASHES&quot;);<br><br>  while (q) &#123;<br><br>    u8* use_mem;<br>    u8  res;<br>    s32 fd;<br><br>    u8* fn = strrchr(q-&gt;fname, &#x27;/&#x27;) + 1;<br><br>    ACTF(&quot;Attempting dry run with &#x27;%s&#x27;...&quot;, fn);<br><br>    fd = open(q-&gt;fname, O_RDONLY);<br>    if (fd &lt; 0) PFATAL(&quot;Unable to open &#x27;%s&#x27;&quot;, q-&gt;fname);<br><br>    use_mem = ck_alloc_nozero(q-&gt;len);<br><br>    if (read(fd, use_mem, q-&gt;len) != q-&gt;len)<br>      FATAL(&quot;Short read from &#x27;%s&#x27;&quot;, q-&gt;fname);<br><br>    close(fd);<br><br>    res = calibrate_case(argv, q, use_mem, 0, 1);<br>    ck_free(use_mem);<br><br>    if (stop_soon) return;<br><br>    if (res == crash_mode  res == FAULT_NOBITS)<br>      SAYF(cGRA &quot;    len = %u, map size = %u, exec speed = %llu us\n&quot; cRST, <br>           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);<br><br>    ......<br><br>    if (q-&gt;var_behavior) WARNF(&quot;Instrumentation output varies across runs.&quot;);<br><br>    q = q-&gt;next;<br><br>  &#125;<br><br>  if (cal_failures) &#123;<br><br>    if (cal_failures == queued_paths)<br>      FATAL(&quot;All test cases time out%s, giving up!&quot;,<br>            skip_crashes ? &quot; or crash&quot; : &quot;&quot;);<br><br>    WARNF(&quot;Skipped %u test cases (%0.02f%%) due to timeouts%s.&quot;, cal_failures,<br>          ((double)cal_failures) * 100 / queued_paths,<br>          skip_crashes ? &quot; or crashes&quot; : &quot;&quot;);<br><br>    if (cal_failures * 5 &gt; queued_paths)<br>      WARNF(cLRD &quot;High percentage of rejected test cases, check settings!&quot;);<br><br>  &#125;<br>  OKF(&quot;All test cases processed.&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对每个测试样例使用 <code>calibrate_case</code> 进行测试，并返回运行结果，然后处理其中异常的情况，比如说程序崩溃或运行超时等。</p>
<h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,<br>                         u32 handicap, u8 from_queue) &#123;<br><br>  static u8 first_trace[MAP_SIZE];<br><br>  u8  fault = 0, new_bits = 0, var_detected = 0, hnb = 0,<br>      first_run = (q-&gt;exec_cksum == 0);<br><br>  u64 start_us, stop_us;<br><br>  s32 old_sc = stage_cur, old_sm = stage_max;<br>  u32 use_tmout = exec_tmout;<br>  u8* old_sn = stage_name;<br><br>  /* Be a bit more generous about timeouts when resuming sessions, or when<br>     trying to calibrate already-added finds. This helps avoid trouble due<br>     to intermittent latency. */<br><br>  if (!from_queue  resuming_fuzz)<br>    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,<br>                    exec_tmout * CAL_TMOUT_PERC / 100);<br><br>  q-&gt;cal_failed++;<br><br>  stage_name = &quot;calibration&quot;;<br>  stage_max  = fast_cal ? 3 : CAL_CYCLES;<br><br>  /* Make sure the forkserver is up before we do anything, and let&#x27;s not<br>     count its spin-up time toward binary calibration. */<br><br>  if (dumb_mode != 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)<br>    init_forkserver(argv);<br><br>  if (q-&gt;exec_cksum) &#123;<br><br>    memcpy(first_trace, trace_bits, MAP_SIZE);<br>    hnb = has_new_bits(virgin_bits);<br>    if (hnb &gt; new_bits) new_bits = hnb;<br><br>  &#125;<br><br>  start_us = get_cur_time_us();<br><br>  for (stage_cur = 0; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>    u32 cksum;<br><br>    if (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();<br><br>    write_to_testcase(use_mem, q-&gt;len);<br><br>    fault = run_target(argv, use_tmout);<br><br>    /* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,<br>       we want to bail out quickly. */<br><br>    if (stop_soon  fault != crash_mode) goto abort_calibration;<br><br>    if (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;<br>      fault = FAULT_NOINST;<br>      goto abort_calibration;<br>    &#125;<br><br>    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<br><br>    if (q-&gt;exec_cksum != cksum) &#123;<br><br>      hnb = has_new_bits(virgin_bits);<br>      if (hnb &gt; new_bits) new_bits = hnb;<br><br>      if (q-&gt;exec_cksum) &#123;<br><br>        u32 i;<br><br>        for (i = 0; i &lt; MAP_SIZE; i++) &#123;<br><br>          if (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;<br><br>            var_bytes[i] = 1;<br>            stage_max    = CAL_CYCLES_LONG;<br><br>          &#125;<br><br>        &#125;<br><br>        var_detected = 1;<br><br>      &#125; else &#123;<br><br>        q-&gt;exec_cksum = cksum;<br>        memcpy(first_trace, trace_bits, MAP_SIZE);<br><br>      &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  stop_us = get_cur_time_us();<br><br>  total_cal_us     += stop_us - start_us;<br>  total_cal_cycles += stage_max;<br><br>  /* OK, let&#x27;s collect some stats about the performance of this test case.<br>     This is used for fuzzing air time calculations in calculate_score(). */<br><br>  q-&gt;exec_us     = (stop_us - start_us) / stage_max;<br>  q-&gt;bitmap_size = count_bytes(trace_bits);<br>  q-&gt;handicap    = handicap;<br>  q-&gt;cal_failed  = 0;<br><br>  total_bitmap_size += q-&gt;bitmap_size;<br>  total_bitmap_entries++;<br><br>  update_bitmap_score(q);<br><br>  /* If this case didn&#x27;t result in new output from the instrumentation, tell<br>     parent. This is a non-critical problem, but something to warn the user<br>     about. */<br><br>  if (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;<br><br>abort_calibration:<br><br>  if (new_bits == 2 &amp;&amp; !q-&gt;has_new_cov) &#123;<br>    q-&gt;has_new_cov = 1;<br>    queued_with_cov++;<br>  &#125;<br><br>  /* Mark variable paths. */<br><br>  if (var_detected) &#123;<br><br>    var_byte_count = count_bytes(var_bytes);<br><br>    if (!q-&gt;var_behavior) &#123;<br>      mark_as_variable(q);<br>      queued_variable++;<br>    &#125;<br><br>  &#125;<br><br>  stage_name = old_sn;<br>  stage_cur  = old_sc;<br>  stage_max  = old_sm;<br><br>  if (!first_run) show_stats();<br><br>  return fault;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数用以对样例进行测试，在后续的测试过程中也会反复调用。此处，其主要的工作是：</p>
<ul>
<li>判断样例是否是首次运行，记录在 <code>first_run</code></li>
<li>设置超时阈值 <code>use_tmout</code></li>
<li>调用 <code>init_forkserver</code> 初始化 <code>fork server</code></li>
<li>多次运行测试样例，记录数据</li>
</ul>
<h5 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h5><p>fork server 是 AFL 中一个重要的机制。</p>
<p><code>afl-fuzz</code> 主动建立一个子进程为 <code>fork server</code>，而模糊测试则是通过 <code>fork server</code> 调用 fork 建立子进程来进行测试。</p>
<blockquote>
<p>参考在源代码注释中的这篇文章可以有更加深入的理解：<br><a target="_blank" rel="noopener" href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p>
</blockquote>
<p>之所以需要设计它，笔者在这里给出一个比较概括的理由：</p>
<p>一般来说，如果我们想要测试输入样例，就需要用 <code>fork+execve</code> 去执行相关的二进制程序，但是执行程序是需要加载代码、动态库、符号解析等各种耗时的行为，这会让 AFL 不够效率。</p>
<p>但是这个过程其实是存在浪费的，可以注意到，如果我们要对相同的二进制程序进行多次不同的输入样本进行测试，那按照原本的操作，我们应该多次执行 <code>fork+execve</code> ，而浪费就出现在这，因为我们明明已经加载好了一切，却又要因此重复加载释放。</p>
<p>因此 <code>fork server</code> 的设计主要就是为了解决这个浪费。它通过向代码中进行插桩的方式，使得在二进制程序中去建立一个 <code>fork server</code>（对，它实际上是由目标程序去建立的），然后这个 <code>fork server</code> 会在完成一切初始化后，停止在某一个地方（往往设定在 <code>main</code> 函数）等待 fuzzer 去喊开始执行。</p>
<p>一旦 fuzzer 喊了开始，就会由这个 <code>fork server</code> 去调用 <code>fork</code> 然后往下执行。而我们知道，<code>fork</code> 由于写时复制的机制存在，它其实并没有过多的开销，可以完全继承原有的所有上下文信息，从而避开了多次 <code>execve</code> 的加载开销。</p>
<p>摘抄一段这部分插桩的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__afl_forkserver:<br><br>  /* Phone home and tell the parent that we&#x27;re OK. */<br><br>  pushl $4          /* length    */<br>  pushl $__afl_temp /* data      */<br>  pushl $199        /* file desc */<br>  call  write<br>  addl  $12, %esp<br><br>__afl_fork_wait_loop:<br><br>  /* Wait for parent by reading from the pipe. This will block until<br>     the parent sends us something. Abort if read fails. */<br><br>  pushl $4          /* length    */<br>  pushl $__afl_temp /* data      */<br>  pushl $198        /* file desc */<br>  call  read<br>  addl  $12, %esp<br><br>  cmpl  $4, %eax<br>  jne   __afl_die<br><br>  /* Once woken up, create a clone of our process. */<br><br>  call fork<br><br>  cmpl $0, %eax<br>  jl   __afl_die<br>  je   __afl_fork_resume<br><br>  /* In parent process: write PID to pipe, then wait for child. <br>     Parent will handle timeouts and SIGKILL the child as needed. */<br><br>  movl  %eax, __afl_fork_pid<br><br>  pushl $4              /* length    */<br>  pushl $__afl_fork_pid /* data      */<br>  pushl $199            /* file desc */<br>  call  write<br>  addl  $12, %esp<br><br>  pushl $2             /* WUNTRACED */<br>  pushl $__afl_temp    /* status    */<br>  pushl __afl_fork_pid /* PID       */<br>  call  waitpid<br>  addl  $12, %esp<br><br>  cmpl  $0, %eax<br>  jle   __afl_die<br><br>  /* Relay wait status to pipe, then loop back. */<br><br>  pushl $4          /* length    */<br>  pushl $__afl_temp /* data      */<br>  pushl $199        /* file desc */<br>  call  write<br>  addl  $12, %esp<br><br>  jmp __afl_fork_wait_loop<br><br>__afl_fork_resume:<br><br>  /* In child process: close fds, resume execution. */<br><br>  pushl $198<br>  call  close<br><br>  pushl $199<br>  call  close<br><br>  addl  $8, %esp<br>  ret<br></code></pre></td></tr></table></figure>

<p><code>fork server</code> 主要是通过管道和 afl-fuzz 中的 <code>fork server</code> 进行通信的，但他们其实不做过多的事情，往往只是通知一下程序运行的状态。因为真正的反馈信息，包括路径的发现等这部分功能是通过共享内存去实现的，它们不需要用 <code>fork server</code> 这种效率较低的方案去记录数据。</p>
<p>剩下的就是关闭一些不需要的文件或管道了，代码姑且贴在这里，以备未来有需要时可以现查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">EXP_ST void init_forkserver(char** argv) &#123;<br><br>  static struct itimerval it;<br>  int st_pipe[2], ctl_pipe[2];<br>  int status;<br>  s32 rlen;<br><br>  ACTF(&quot;Spinning up the fork server...&quot;);<br><br>  if (pipe(st_pipe)  pipe(ctl_pipe)) PFATAL(&quot;pipe() failed&quot;);<br><br>  forksrv_pid = fork();<br><br>  if (forksrv_pid &lt; 0) PFATAL(&quot;fork() failed&quot;);<br><br>  if (!forksrv_pid) &#123;<br><br>    struct rlimit r;<br><br>    /* Umpf. On OpenBSD, the default fd limit for root users is set to<br>       soft 128. Let&#x27;s try to fix that... */<br><br>    if (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + 2) &#123;<br><br>      r.rlim_cur = FORKSRV_FD + 2;<br>      setrlimit(RLIMIT_NOFILE, &amp;r); /* Ignore errors */<br><br>    &#125;<br><br>    if (mem_limit) &#123;<br><br>      r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) &lt;&lt; 20;<br><br>#ifdef RLIMIT_AS<br><br>      setrlimit(RLIMIT_AS, &amp;r); /* Ignore errors */<br><br>#else<br><br>      /* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but<br>         according to reliable sources, RLIMIT_DATA covers anonymous<br>         maps - so we should be getting good protection against OOM bugs. */<br><br>      setrlimit(RLIMIT_DATA, &amp;r); /* Ignore errors */<br><br>#endif /* ^RLIMIT_AS */<br><br><br>    &#125;<br><br>    /* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered<br>       before the dump is complete. */<br><br>    r.rlim_max = r.rlim_cur = 0;<br><br>    setrlimit(RLIMIT_CORE, &amp;r); /* Ignore errors */<br><br>    /* Isolate the process and configure standard descriptors. If out_file is<br>       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */<br><br>    setsid();<br><br>    dup2(dev_null_fd, 1);<br>    dup2(dev_null_fd, 2);<br><br>    if (out_file) &#123;<br><br>      dup2(dev_null_fd, 0);<br><br>    &#125; else &#123;<br><br>      dup2(out_fd, 0);<br>      close(out_fd);<br><br>    &#125;<br><br>    /* Set up control and status pipes, close the unneeded original fds. */<br><br>    if (dup2(ctl_pipe[0], FORKSRV_FD) &lt; 0) PFATAL(&quot;dup2() failed&quot;);<br>    if (dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0) PFATAL(&quot;dup2() failed&quot;);<br><br>    close(ctl_pipe[0]);<br>    close(ctl_pipe[1]);<br>    close(st_pipe[0]);<br>    close(st_pipe[1]);<br><br>    close(out_dir_fd);<br>    close(dev_null_fd);<br>    close(dev_urandom_fd);<br>    close(fileno(plot_file));<br><br>    /* This should improve performance a bit, since it stops the linker from<br>       doing extra work post-fork(). */<br><br>    if (!getenv(&quot;LD_BIND_LAZY&quot;)) setenv(&quot;LD_BIND_NOW&quot;, &quot;1&quot;, 0);<br><br>    /* Set sane defaults for ASAN if nothing else specified. */<br><br>    setenv(&quot;ASAN_OPTIONS&quot;, &quot;abort_on_error=1:&quot;<br>                           &quot;detect_leaks=0:&quot;<br>                           &quot;symbolize=0:&quot;<br>                           &quot;allocator_may_return_null=1&quot;, 0);<br><br>    /* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this<br>       point. So, we do this in a very hacky way. */<br><br>    setenv(&quot;MSAN_OPTIONS&quot;, &quot;exit_code=&quot; STRINGIFY(MSAN_ERROR) &quot;:&quot;<br>                           &quot;symbolize=0:&quot;<br>                           &quot;abort_on_error=1:&quot;<br>                           &quot;allocator_may_return_null=1:&quot;<br>                           &quot;msan_track_origins=0&quot;, 0);<br><br>    execv(target_path, argv);<br><br>    /* Use a distinctive bitmap signature to tell the parent about execv()<br>       falling through. */<br><br>    *(u32*)trace_bits = EXEC_FAIL_SIG;<br>    exit(0);<br><br>  &#125;<br><br>  /* Close the unneeded endpoints. */<br><br>  close(ctl_pipe[0]);<br>  close(st_pipe[1]);<br><br>  fsrv_ctl_fd = ctl_pipe[1];<br>  fsrv_st_fd  = st_pipe[0];<br><br>  /* Wait for the fork server to come up, but don&#x27;t wait too long. */<br><br>  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / 1000);<br>  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;<br><br>  setitimer(ITIMER_REAL, &amp;it, NULL);<br><br>  rlen = read(fsrv_st_fd, &amp;status, 4);<br><br>  it.it_value.tv_sec = 0;<br>  it.it_value.tv_usec = 0;<br><br>  setitimer(ITIMER_REAL, &amp;it, NULL);<br><br>  /* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.<br>     Otherwise, try to figure out what went wrong. */<br><br>  if (rlen == 4) &#123;<br>    OKF(&quot;All right - fork server is up.&quot;);<br>    return;<br>  &#125;<br><br>  if (child_timed_out)<br>    FATAL(&quot;Timeout while initializing fork server (adjusting -t may help)&quot;);<br><br>  if (waitpid(forksrv_pid, &amp;status, 0) &lt;= 0)<br>    PFATAL(&quot;waitpid() failed&quot;);<br><br>  if (WIFSIGNALED(status)) &#123;<br><br>    if (mem_limit &amp;&amp; mem_limit &lt; 500 &amp;&amp; uses_asan) &#123;<br><br>      SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>           &quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;<br>           &quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;<br>           &quot;    restrictive memory limit configured, this is expected; please read\n&quot;<br>           &quot;    %s/notes_for_asan.txt for help.\n&quot;, doc_path);<br><br>    &#125; else if (!mem_limit) &#123;<br><br>      SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>           &quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;<br>           &quot;    from the fuzzer! There are several probable explanations:\n\n&quot;<br><br>           &quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;<br>           &quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;<br><br>#ifdef __APPLE__<br><br>           &quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;<br>           &quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;<br>           &quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;<br><br>#endif /* __APPLE__ */<br><br>           &quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;<br>           &quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;);<br><br>    &#125; else &#123;<br><br>      SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>           &quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;<br>           &quot;    from the fuzzer! There are several probable explanations:\n\n&quot;<br><br>           &quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;<br>           &quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;<br>           &quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;<br>           &quot;      this diagnosis would be:\n\n&quot;<br><br>#ifdef RLIMIT_AS<br>           &quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;<br>#else<br>           &quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;<br>#endif /* ^RLIMIT_AS */<br><br>           &quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;<br>           &quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;<br><br>           &quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;<br>           &quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;<br><br>#ifdef __APPLE__<br><br>           &quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;<br>           &quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;<br>           &quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;<br><br>#endif /* __APPLE__ */<br><br>           &quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;<br>           &quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;,<br>           DMS(mem_limit &lt;&lt; 20), mem_limit - 1);<br><br>    &#125;<br><br>    FATAL(&quot;Fork server crashed with signal %d&quot;, WTERMSIG(status));<br><br>  &#125;<br><br>  if (*(u32*)trace_bits == EXEC_FAIL_SIG)<br>    FATAL(&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;, argv[0]);<br><br>  if (mem_limit &amp;&amp; mem_limit &lt; 500 &amp;&amp; uses_asan) &#123;<br><br>    SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>           &quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;<br>           &quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;<br>           &quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;<br>           &quot;    read %s/notes_for_asan.txt for help.\n&quot;, doc_path);<br><br>  &#125; else if (!mem_limit) &#123;<br><br>    SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>         &quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;<br>         &quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;<br>         &quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;);<br><br>  &#125; else &#123;<br><br>    SAYF(&quot;\n&quot; cLRD &quot;[-] &quot; cRST<br>         &quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;<br>         &quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;<br><br>         &quot;%s&quot;<br>         &quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;<br>         &quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;<br>         &quot;      simple way to confirm the diagnosis may be:\n\n&quot;<br><br>#ifdef RLIMIT_AS<br>         &quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;<br>#else<br>         &quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;<br>#endif /* ^RLIMIT_AS */<br><br>         &quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;<br>         &quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;<br><br>         &quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;<br>         &quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;,<br>         getenv(DEFER_ENV_VAR) ? &quot;three&quot; : &quot;two&quot;,<br>         getenv(DEFER_ENV_VAR) ?<br>         &quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;<br>         &quot;      reached before the program terminates.\n\n&quot; : &quot;&quot;,<br>         DMS(mem_limit &lt;&lt; 20), mem_limit - 1);<br><br>  &#125;<br><br>  FATAL(&quot;Fork server handshake failed&quot;);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h3><p>将运行过的种子根据运行的效果进行排序，后续模糊测试根据排序的结果来挑选样例进行模糊测试。</p>
<h3 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h3><p>初始化 <code>UI</code> 。</p>
<h3 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h3><p>如果是恢复运行，则调用该函数来寻找到对应的样例的位置。</p>
<h3 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h3><p>更新统计信息文件以进行无人值守的监视。</p>
<h3 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h3><p>保存自动提取的 <code>token</code> ，用于后续字典模式的 <code>fuzz</code> 。</p>
<h3 id="afl-fuzz-主循环"><a href="#afl-fuzz-主循环" class="headerlink" title="afl-fuzz 主循环"></a>afl-fuzz 主循环</h3><ul>
<li>首先调用 <code>cull_queue</code> 来优化队列</li>
<li>如果 <code>queue_cur</code> 为空，代表所有queue都被执行完一轮<ul>
<li>设置queue_cycle计数器加一，即代表所有queue被完整执行了多少轮。</li>
<li>设置current_entry为0，和queue_cur为queue首元素，开始新一轮fuzz。</li>
<li>如果是resume fuzz情况，则先检查seek_to是否为空，如果不为空，就从seek_to指定的queue项开始执行。</li>
<li>刷新展示界面<code>show_stats</code></li>
<li>如果在一轮执行之后的queue里的case数，和执行之前一样，代表在完整的一轮执行里都没有发现任何一个新的case<ul>
<li>如果use_splicing为1，就设置cycles_wo_finds计数器加1</li>
<li>否则，设置use_splicing为1，代表我们接下来要通过splice重组queue里的case。</li>
</ul>
</li>
</ul>
</li>
<li>执行<code>skipped_fuzz = fuzz_one(use_argv)</code>来对queue_cur进行一次测试<ul>
<li>注意fuzz_one并不一定真的执行当前queue_cur，它是有一定策略的，如果不执行，就直接返回1，否则返回0</li>
</ul>
</li>
<li>如果skipped_fuzz为0，且存在sync_id<ul>
<li>sync_interval_cnt计数器加一，如果其结果是SYNC_INTERVAL(默认是5)的倍数，就进行一次sync</li>
</ul>
</li>
<li><code>queue_cur = queue_cur-&gt;next;current_entry++;</code>，开始测试下一个queue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while (1) &#123;<br><br>  u8 skipped_fuzz;<br><br>  cull_queue();<br><br>  if (!queue_cur) &#123;<br><br>    queue_cycle++;<br>    current_entry     = 0;<br>    cur_skipped_paths = 0;<br>    queue_cur         = queue;<br><br>    while (seek_to) &#123;<br>      current_entry++;<br>      seek_to--;<br>      queue_cur = queue_cur-&gt;next;<br>    &#125;<br><br>    show_stats();<br><br>    if (not_on_tty) &#123;<br>      ACTF(&quot;Entering queue cycle %llu.&quot;, queue_cycle);<br>      fflush(stdout);<br>    &#125;<br><br>    /* If we had a full queue cycle with no new finds, try<br>       recombination strategies next. */<br><br>    if (queued_paths == prev_queued) &#123;<br><br>      if (use_splicing) cycles_wo_finds++; else use_splicing = 1;<br><br>    &#125; else cycles_wo_finds = 0;<br><br>    prev_queued = queued_paths;<br><br>    if (sync_id &amp;&amp; queue_cycle == 1 &amp;&amp; getenv(&quot;AFL_IMPORT_FIRST&quot;))<br>      sync_fuzzers(use_argv);<br><br>  &#125;<br><br>  skipped_fuzz = fuzz_one(use_argv);<br><br>  if (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;<br><br>    if (!(sync_interval_cnt++ % SYNC_INTERVAL))<br>      sync_fuzzers(use_argv);<br><br>  &#125;<br><br>  if (!stop_soon &amp;&amp; exit_1) stop_soon = 2;<br><br>  if (stop_soon) break;<br><br>  queue_cur = queue_cur-&gt;next;<br>  current_entry++;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><p>从测试样例的队列中取出 <code>current_entry</code> 进行测试，成功则返回 0 ，否则返回 1。这里主要是对该函数主要内容进行记录，不做细节的代码分析。</p>
<ul>
<li>打开 <code>queue_cur</code> 并映射到 <code>orig_in</code> 和 <code>in_buf</code></li>
<li>分配len大小的内存，并初始化为全 0，然后将地址赋值给 <code>out_buf</code></li>
</ul>
<h5 id="CALIBRATION-阶段"><a href="#CALIBRATION-阶段" class="headerlink" title="CALIBRATION 阶段"></a>CALIBRATION 阶段</h5><ul>
<li>若 <code>queue_cur-&gt;cal_failed &lt; CAL_CHANCES</code> 且 <code>queue_cur-&gt;cal_failed &gt;0</code> ，则调用 <code>calibrate_case</code></li>
</ul>
<h5 id="TRIMMING-阶段"><a href="#TRIMMING-阶段" class="headerlink" title="TRIMMING 阶段"></a>TRIMMING 阶段</h5><ul>
<li>如果样例没经过该阶段，那么就调用 <code>trim_case</code> 修剪样例</li>
<li>将修剪后的结果重新放入 <code>out_buf</code></li>
</ul>
<p>缩减的思路是这样的：如果对一个样本进行缩减后，它所覆盖的路径并未发生变化，那么就说明缩减的这部分内容是可有可无的，因此可以删除。</p>
<p>具体策略如下：</p>
<ul>
<li>如果这个case的大小len小于5字节，就直接返回</li>
<li>设定 <code>stage_name</code> 为 <code>tmp</code> ，该变量仅用来标识本次缩减所使用的策略</li>
<li>计算 <code>len_p2</code> ，其值是大于等于 <code>q-&gt;len</code> 的第一个2的幂次。</li>
<li>取 <code>len_p2/16</code> 为 <code>remove_len</code> 作为起始步长。</li>
<li>进入循环，终止条件为 <code>remove_len</code> 小于终止步长 <code>len_p2/1024</code> , 每轮循环步长会除2。<ul>
<li>初始化一些必要数据后，再次进入循环，这次是按照当前设定的步长对样本进行遍历</li>
<li>用 <code>run_target</code> 运行样例，<code>trim_execs</code> 计数器加一</li>
<li>对比路径是否变化<ul>
<li>若无变化<ul>
<li>则从 <code>q-&gt;len</code> 中减去 <code>remove_len</code> 个字节，并由此重新计算出一个 <code>len_p2</code> ，这里注意一下<code>while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES))</code></li>
<li>将 <code>in_buf+remove_pos+remove_len</code> 到最后的字节，前移到 <code>in_buf+remove_pos</code> 处，等于删除了 <code>remove_pos</code> 向后的 <code>remove_len</code> 个字节。</li>
<li>如果 <code>needs_write</code> 为 0，则设置其为 1，并保存当前 <code>trace_bits</code> 到 <code>clean_trace</code> 中。</li>
</ul>
</li>
<li>如有变化<ul>
<li><code>remove_pos</code> 加上 <code>remove_len</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果needs_write为1<ul>
<li>删除原来的 <code>q-&gt;fname</code> ，创建一个新的 <code>q-&gt;fname</code> ，将 <code>in_buf</code> 里的内容写入，然后用 <code>clean_trace</code> 恢复 <code>trace_bits</code> 的值。</li>
<li>进行一次 <code>update_bitmap_score</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) &#123;<br><br>  static u8 tmp[64];<br>  static u8 clean_trace[MAP_SIZE];<br><br>  u8  needs_write = 0, fault = 0;<br>  u32 trim_exec = 0;<br>  u32 remove_len;<br>  u32 len_p2;<br><br>  /* Although the trimmer will be less useful when variable behavior is<br>     detected, it will still work to some extent, so we don&#x27;t check for<br>     this. */<br><br>  if (q-&gt;len &lt; 5) return 0;<br><br>  stage_name = tmp;<br>  bytes_trim_in += q-&gt;len;<br><br>  /* Select initial chunk len, starting with large steps. */<br><br>  len_p2 = next_p2(q-&gt;len);<br><br>  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);<br><br>  /* Continue until the number of steps gets too high or the stepover<br>     gets too small. */<br><br>  while (remove_len &gt;= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;<br><br>    u32 remove_pos = remove_len;<br><br>    sprintf(tmp, &quot;trim %s/%s&quot;, DI(remove_len), DI(remove_len));<br><br>    stage_cur = 0;<br>    stage_max = q-&gt;len / remove_len;<br><br>    while (remove_pos &lt; q-&gt;len) &#123;<br><br>      u32 trim_avail = MIN(remove_len, q-&gt;len - remove_pos);<br>      u32 cksum;<br><br>      write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);<br><br>      fault = run_target(argv, exec_tmout);<br>      trim_execs++;<br><br>      if (stop_soon  fault == FAULT_ERROR) goto abort_trimming;<br><br>      /* Note that we don&#x27;t keep track of crashes or hangs here; maybe TODO? */<br><br>      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);<br><br>      /* If the deletion had no impact on the trace, make it permanent. This<br>         isn&#x27;t perfect for variable-path inputs, but we&#x27;re just making a<br>         best-effort pass, so it&#x27;s not a big deal if we end up with false<br>         negatives every now and then. */<br><br>      if (cksum == q-&gt;exec_cksum) &#123;<br><br>        u32 move_tail = q-&gt;len - remove_pos - trim_avail;<br><br>        q-&gt;len -= trim_avail;<br>        len_p2  = next_p2(q-&gt;len);<br><br>        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, <br>                move_tail);<br><br>        /* Let&#x27;s save a clean trace, which will be needed by<br>           update_bitmap_score once we&#x27;re done with the trimming stuff. */<br><br>        if (!needs_write) &#123;<br><br>          needs_write = 1;<br>          memcpy(clean_trace, trace_bits, MAP_SIZE);<br><br>        &#125;<br><br>      &#125; else remove_pos += remove_len;<br><br>      /* Since this can be slow, update the screen every now and then. */<br><br>      if (!(trim_exec++ % stats_update_freq)) show_stats();<br>      stage_cur++;<br><br>    &#125;<br><br>    remove_len &gt;&gt;= 1;<br><br>  &#125;<br><br>  /* If we have made changes to in_buf, we also need to update the on-disk<br>     version of the test case. */<br><br>  if (needs_write) &#123;<br><br>    s32 fd;<br><br>    unlink(q-&gt;fname); /* ignore errors */<br><br>    fd = open(q-&gt;fname, O_WRONLY  O_CREAT  O_EXCL, 0600);<br><br>    if (fd &lt; 0) PFATAL(&quot;Unable to create &#x27;%s&#x27;&quot;, q-&gt;fname);<br><br>    ck_write(fd, in_buf, q-&gt;len, q-&gt;fname);<br>    close(fd);<br><br>    memcpy(trace_bits, clean_trace, MAP_SIZE);<br>    update_bitmap_score(q);<br><br>  &#125;<br><br>abort_trimming:<br><br>  bytes_trim_out += q-&gt;len;<br>  return fault;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="PERFORMANCE-SCORE-阶段"><a href="#PERFORMANCE-SCORE-阶段" class="headerlink" title="PERFORMANCE SCORE 阶段"></a>PERFORMANCE SCORE 阶段</h5><ul>
<li>perf_score &#x3D; <code>calculate_score(queue_cur)</code></li>
<li>如果 <code>skip_deterministic</code> 为1，或者 <code>queue_cur</code> 被 fuzz 过，或者 <code>queue_cur</code> 的 <code>passed_det</code> 为1，则跳转去 <code>havoc_stage</code> 阶段</li>
<li>设置doing_det为 1</li>
</ul>
<h5 id="SIMPLE-BITFLIP-阶段"><a href="#SIMPLE-BITFLIP-阶段" class="headerlink" title="SIMPLE BITFLIP 阶段"></a>SIMPLE BITFLIP 阶段</h5><p>这个阶段读起来感觉比较抽象。首先定义了这么一个宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define FLIP_BIT(_ar, _b) do &#123; \<br>    u8* _arf = (u8*)(_ar); \<br>    u32 _bf = (_b); \<br>    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \<br>  &#125; while (0)<br></code></pre></td></tr></table></figure>

<p>这个宏的操作是对一个 bit 进行反转。</p>
<p>而接下来首先有一个循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stage_short = &quot;flip1&quot;;<br>stage_max   = len &lt;&lt; 3;<br>stage_name  = &quot;bitflip 1/1&quot;;<br><br>stage_val_type = STAGE_VAL_NONE;<br><br>orig_hit_cnt = queued_paths + unique_crashes;<br><br>prev_cksum = queue_cur-&gt;exec_cksum;<br>for (stage_cur = 0; stage_cur &lt; stage_max; stage_cur++) &#123;<br>  stage_cur_byte = stage_cur &gt;&gt; 3;<br>  FLIP_BIT(out_buf, stage_cur);<br>  if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br>  FLIP_BIT(out_buf, stage_cur);<br>  ......<br></code></pre></td></tr></table></figure>

<p><code>stage_max</code> 是输入的总 bit 数，然后分别对每个 bit 进行翻转后用 <code>common_fuzz_stuff</code> 进行测试，然后再将其翻转回来。</p>
<p>而如果对某个字节的最后一个 bit 翻转后测试，发现路径并未增加，就能够将其认为是一个 <code>token</code> 。</p>
<ul>
<li>token默认最小是3，最大是32,每次发现新token时，通过<code>maybe_add_auto</code>添加到<code>a_extras</code>数组里。</li>
<li><code>stage_finds[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中新发现的路径和Crash总和</li>
<li><code>stage_cycles[STAGE_FLIP1]</code>的值加上在整个FLIP_BIT中执行的target次数<code>stage_max</code></li>
<li>设置stage_name为<code>bitflip 2/1</code>,原理和之前一样，只是这次是连续翻转相邻的两位。</li>
</ul>
<p>然后在后面的一个循环中又做类似的事，但每次会翻转两个 bit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stage_name  = &quot;bitflip 2/1&quot;;<br>stage_short = &quot;flip2&quot;;<br>stage_max   = (len &lt;&lt; 3) - 1;<br><br>orig_hit_cnt = new_hit_cnt;<br><br>for (stage_cur = 0; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>  stage_cur_byte = stage_cur &gt;&gt; 3;<br><br>  FLIP_BIT(out_buf, stage_cur);<br>  FLIP_BIT(out_buf, stage_cur + 1);<br><br>  if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br><br>  FLIP_BIT(out_buf, stage_cur);<br>  FLIP_BIT(out_buf, stage_cur + 1);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>然后保存结果到<code>stage_finds[STAGE_FLIP2]和stage_cycles[STAGE_FLIP2]</code>里。</li>
<li>同理，设置stage_name为<code>bitflip 4/1</code>，翻转连续的四位并记录。</li>
<li>构建 <code>Effector map</code><ul>
<li>进入 <code>bitflip 8/8</code> 的阶段，这个阶段就是对每个字节的所有 bit 都进行翻转，然后用 <code>common_fuzz_stuff</code> 进行测试</li>
<li>如果其造成执行路径与原始路径不一致，就将该byte在 <code>effector map</code> 中标记为1，即“有效”的，否则标记为 0，即“无效”的。</li>
<li>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</li>
</ul>
</li>
</ul>
<p>然后进入 <code>bitflip 16/8</code> 部分，按对每两个字节进行一次翻转然后测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">for (i = 0; i &lt; len - 1; i++) &#123;<br><br>  /* Let&#x27;s consult the effector map... */<br><br>  if (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + 1)]) &#123;<br>    stage_max--;<br>    continue;<br>  &#125;<br><br>  stage_cur_byte = i;<br><br>  *(u16*)(out_buf + i) ^= 0xFFFF;<br><br>  if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br>  stage_cur++;<br><br>  *(u16*)(out_buf + i) ^= 0xFFFF;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里要注意在翻转之前会先检查eff_map里对应于这两个字节的标志是否为0，如果为0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一个字。</li>
<li>common_fuzz_stuff执行变异后的结果，然后还原。</li>
</ul>
<p>最后是 <code>bitflip 32/8</code> 阶段，每 4 个字节进行翻转然后测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stage_name  = &quot;bitflip 32/8&quot;;<br>stage_short = &quot;flip32&quot;;<br>stage_cur   = 0;<br>stage_max   = len - 3;<br><br>orig_hit_cnt = new_hit_cnt;<br><br>for (i = 0; i &lt; len - 3; i++) &#123;<br><br>  /* Let&#x27;s consult the effector map... */<br>  if (!eff_map[EFF_APOS(i)] &amp;&amp; !eff_map[EFF_APOS(i + 1)] &amp;&amp;<br>      !eff_map[EFF_APOS(i + 2)] &amp;&amp; !eff_map[EFF_APOS(i + 3)]) &#123;<br>    stage_max--;<br>    continue;<br>  &#125;<br><br>  stage_cur_byte = i;<br><br>  *(u32*)(out_buf + i) ^= 0xFFFFFFFF;<br><br>  if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br>  stage_cur++;<br><br>  *(u32*)(out_buf + i) ^= 0xFFFFFFFF;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在每次翻转之前会检查eff_map里对应于这四个字节的标志是否为0，如果是0，则这两个字节是无效的数据，stage_max减一，然后开始变异下一组双字。</li>
</ul>
<h5 id="ARITHMETIC-INC-DEC-阶段"><a href="#ARITHMETIC-INC-DEC-阶段" class="headerlink" title="ARITHMETIC INC&#x2F;DEC 阶段"></a>ARITHMETIC INC&#x2F;DEC 阶段</h5><ul>
<li>arith 8&#x2F;8，每次对8个bit进行加减运算，按照每8个 bit 的步长从头开始，即对文件的每个 byte 进行整数加减变异</li>
<li>arith 16&#x2F;8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li>
<li>arith 32&#x2F;8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li>
<li>加减变异的上限，在 <code>config.h</code> 中的宏 <code>ARITH_MAX</code> 定义，默认为 35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35 的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</li>
<li>此外，AFL 还会智能地跳过某些 <code>arithmetic</code> 变异。第一种情况就是前面提到的 effector map ：如果一个整数的所有 bytes 都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前 bitflip 已经生成过的变异：如果加&#x2F;减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</li>
</ul>
<p>此处展示 arith 8&#x2F;8 部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stage_name  = &quot;arith 8/8&quot;;<br>stage_short = &quot;arith8&quot;;<br>stage_cur   = 0;<br>stage_max   = 2 * len * ARITH_MAX;<br><br>stage_val_type = STAGE_VAL_LE;<br><br>orig_hit_cnt = new_hit_cnt;<br><br>for (i = 0; i &lt; len; i++) &#123;<br><br>  u8 orig = out_buf[i];<br><br>  /* Let&#x27;s consult the effector map... */<br><br>  if (!eff_map[EFF_APOS(i)]) &#123;<br>    stage_max -= 2 * ARITH_MAX;<br>    continue;<br>  &#125;<br><br>  stage_cur_byte = i;<br><br>  for (j = 1; j &lt;= ARITH_MAX; j++) &#123;<br><br>    u8 r = orig ^ (orig + j);<br><br>    /* Do arithmetic operations only if the result couldn&#x27;t be a product<br>       of a bitflip. */<br><br>    if (!could_be_bitflip(r)) &#123;<br><br>      stage_cur_val = j;<br>      out_buf[i] = orig + j;<br><br>      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br>      stage_cur++;<br><br>    &#125; else stage_max--;<br><br>    r =  orig ^ (orig - j);<br><br>    if (!could_be_bitflip(r)) &#123;<br><br>      stage_cur_val = -j;<br>      out_buf[i] = orig - j;<br><br>      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br>      stage_cur++;<br><br>    &#125; else stage_max--;<br><br>    out_buf[i] = orig;<br><br>  &#125;<br><br>&#125;<br><br>new_hit_cnt = queued_paths + unique_crashes;<br><br>stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;<br>stage_cycles[STAGE_ARITH8] += stage_max;<br></code></pre></td></tr></table></figure>

<h5 id="INTERESTING-VALUES-阶段"><a href="#INTERESTING-VALUES-阶段" class="headerlink" title="INTERESTING VALUES 阶段"></a>INTERESTING VALUES 阶段</h5><ul>
<li>interest 8&#x2F;8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换</li>
<li>interest 16&#x2F;8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li>
<li>interest 32&#x2F;8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换</li>
<li>而用于替换的 <code>interesting values</code> 是AFL预设的一些比较特殊的数,这些数的定义在config.h文件中：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static s8  interesting_8[]  = &#123; INTERESTING_8 &#125;;<br>static s16 interesting_16[] = &#123; INTERESTING_8, INTERESTING_16 &#125;;<br>static s32 interesting_32[] = &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>同样，<code>effector map</code> 仍然会用于判断是否需要变异；此外，如果某个<code>interesting value</code>，是可以通过 <code>bitflip</code> 或者 <code>arithmetic</code> 变异达到，那么这样的重复性变异也是会跳过的。</li>
</ul>
<p>此处给出 <code>interest 8/8</code> 部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">stage_name  = &quot;interest 8/8&quot;;<br>stage_short = &quot;int8&quot;;<br>stage_cur   = 0;<br>stage_max   = len * sizeof(interesting_8);<br><br>stage_val_type = STAGE_VAL_LE;<br><br>orig_hit_cnt = new_hit_cnt;<br><br>/* Setting 8-bit integers. */<br><br>for (i = 0; i &lt; len; i++) &#123;<br><br>  u8 orig = out_buf[i];<br><br>  /* Let&#x27;s consult the effector map... */<br><br>  if (!eff_map[EFF_APOS(i)]) &#123;<br>    stage_max -= sizeof(interesting_8);<br>    continue;<br>  &#125;<br><br>  stage_cur_byte = i;<br><br>  for (j = 0; j &lt; sizeof(interesting_8); j++) &#123;<br><br>    /* Skip if the value could be a product of bitflips or arithmetics. */<br><br>    if (could_be_bitflip(orig ^ (u8)interesting_8[j]) <br>        could_be_arith(orig, (u8)interesting_8[j], 1)) &#123;<br>      stage_max--;<br>      continue;<br>    &#125;<br><br>    stage_cur_val = interesting_8[j];<br>    out_buf[i] = interesting_8[j];<br><br>    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br><br>    out_buf[i] = orig;<br>    stage_cur++;<br><br>  &#125;<br><br>&#125;<br><br>new_hit_cnt = queued_paths + unique_crashes;<br><br>stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;<br>stage_cycles[STAGE_INTEREST8] += stage_max;<br></code></pre></td></tr></table></figure>

<h5 id="DICTIONARY-STUFF-阶段"><a href="#DICTIONARY-STUFF-阶段" class="headerlink" title="DICTIONARY STUFF 阶段"></a>DICTIONARY STUFF 阶段</h5><ul>
<li>通过 <code>-x</code> 选项指定一个词典，如果没有则跳过前两个阶段</li>
<li>user extras(over),从头开始,将用户提供的tokens依次替换到原文件中,stage_max为 <code>extras_cnt * len</code></li>
<li>user extras(insert),从头开始,将用户提供的tokens依次插入到原文件中,stage_max为 <code>extras_cnt * len</code></li>
<li>如果在之前的分析中提取到了 tokens，则进入 <code>auto extras</code> 阶段</li>
<li>auto extras(over),从头开始,将自动检测的tokens依次替换到原文件中, <code>stage_max</code> 为<code>MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len</code></li>
</ul>
<p>此处给出 <code>auto extras (over)</code> 部分的源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (!a_extras_cnt) goto skip_extras;<br><br>stage_name  = &quot;auto extras (over)&quot;;<br>stage_short = &quot;ext_AO&quot;;<br>stage_cur   = 0;<br>stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;<br><br>stage_val_type = STAGE_VAL_NONE;<br><br>orig_hit_cnt = new_hit_cnt;<br><br>for (i = 0; i &lt; len; i++) &#123;<br><br>  u32 last_len = 0;<br><br>  stage_cur_byte = i;<br><br>  for (j = 0; j &lt; MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;<br><br>    /* See the comment in the earlier code; extras are sorted by size. */<br><br>    if (a_extras[j].len &gt; len - i <br>        !memcmp(a_extras[j].data, out_buf + i, a_extras[j].len) <br>        !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, a_extras[j].len))) &#123;<br><br>      stage_max--;<br>      continue;<br><br>    &#125;<br><br>    last_len = a_extras[j].len;<br>    memcpy(out_buf + i, a_extras[j].data, last_len);<br><br>    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;<br><br>    stage_cur++;<br><br>  &#125;<br><br>  /* Restore all the clobbered memory. */<br>  memcpy(out_buf + i, in_buf + i, last_len);<br><br>&#125;<br><br>new_hit_cnt = queued_paths + unique_crashes;<br><br>stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;<br>stage_cycles[STAGE_EXTRAS_AO] += stage_max;<br></code></pre></td></tr></table></figure>

<h5 id="RANDOM-HAVOC-阶段"><a href="#RANDOM-HAVOC-阶段" class="headerlink" title="RANDOM HAVOC 阶段"></a>RANDOM HAVOC 阶段</h5><p>该部分使用一个巨大的 switch ，通过随机数进行跳转，并在每个分支中使用随机数来完成随机性的行为：</p>
<ul>
<li>首先指定出变换的此处上限 <code>use_stacking = 1 &lt;&lt; (1 + UR(HAVOC_STACK_POW2))</code></li>
<li>然后进入循环，生成一个随机数去选择下列中的某一个情况来对样例进行变换<ul>
<li>随机选取某个bit进行翻转</li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li>随机删除一段bytes</li>
<li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li>
<li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
</ul>
</li>
<li>然后调用 <code>common_fuzz_stuff</code> 进行测试</li>
<li>重复上述过程 <code>stage_max</code> 次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">for (stage_cur = 0; stage_cur &lt; stage_max; stage_cur++) &#123;<br><br>  u32 use_stacking = 1 &lt;&lt; (1 + UR(HAVOC_STACK_POW2));<br><br>  stage_cur_val = use_stacking;<br><br>  for (i = 0; i &lt; use_stacking; i++) &#123;<br><br>    switch (UR(15 + ((extras_cnt + a_extras_cnt) ? 2 : 0))) &#123;<br><br>      case 0:<br><br>        /* Flip a single bit somewhere. Spooky! */<br><br>        FLIP_BIT(out_buf, UR(temp_len &lt;&lt; 3));<br>        break;<br><br>      case 1: <br><br>        /* Set byte to interesting value. */<br><br>        out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];<br>        break;<br><br>      case 2:<br><br>        /* Set word to interesting value, randomly choosing endian. */<br><br>        if (temp_len &lt; 2) break;<br><br>        if (UR(2)) &#123;<br><br>          *(u16*)(out_buf + UR(temp_len - 1)) =<br>            interesting_16[UR(sizeof(interesting_16) &gt;&gt; 1)];<br><br>        &#125; else &#123;<br><br>          *(u16*)(out_buf + UR(temp_len - 1)) = SWAP16(<br>            interesting_16[UR(sizeof(interesting_16) &gt;&gt; 1)]);<br><br>        &#125;<br><br>        break;<br><br>      case 3:<br><br>        /* Set dword to interesting value, randomly choosing endian. */<br><br>        if (temp_len &lt; 4) break;<br><br>        if (UR(2)) &#123;<br><br>          *(u32*)(out_buf + UR(temp_len - 3)) =<br>            interesting_32[UR(sizeof(interesting_32) &gt;&gt; 2)];<br><br>        &#125; else &#123;<br><br>          *(u32*)(out_buf + UR(temp_len - 3)) = SWAP32(<br>            interesting_32[UR(sizeof(interesting_32) &gt;&gt; 2)]);<br><br>        &#125;<br><br>        break;<br><br>      case 4:<br><br>        /* Randomly subtract from byte. */<br><br>        out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);<br>        break;<br><br>      case 5:<br><br>        /* Randomly add to byte. */<br><br>        out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);<br>        break;<br><br>      case 6:<br><br>        /* Randomly subtract from word, random endian. */<br><br>        if (temp_len &lt; 2) break;<br><br>        if (UR(2)) &#123;<br><br>          u32 pos = UR(temp_len - 1);<br><br>          *(u16*)(out_buf + pos) -= 1 + UR(ARITH_MAX);<br><br>        &#125; else &#123;<br><br>          u32 pos = UR(temp_len - 1);<br>          u16 num = 1 + UR(ARITH_MAX);<br><br>          *(u16*)(out_buf + pos) =<br>            SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);<br><br>        &#125;<br><br>        break;<br><br>      case 7:<br><br>        /* Randomly add to word, random endian. */<br><br>        if (temp_len &lt; 2) break;<br><br>        if (UR(2)) &#123;<br><br>          u32 pos = UR(temp_len - 1);<br><br>          *(u16*)(out_buf + pos) += 1 + UR(ARITH_MAX);<br><br>        &#125; else &#123;<br><br>          u32 pos = UR(temp_len - 1);<br>          u16 num = 1 + UR(ARITH_MAX);<br><br>          *(u16*)(out_buf + pos) =<br>            SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);<br><br>        &#125;<br><br>        break;<br><br>      case 8:<br><br>        /* Randomly subtract from dword, random endian. */<br><br>        if (temp_len &lt; 4) break;<br><br>        if (UR(2)) &#123;<br><br>          u32 pos = UR(temp_len - 3);<br><br>          *(u32*)(out_buf + pos) -= 1 + UR(ARITH_MAX);<br><br>        &#125; else &#123;<br><br>          u32 pos = UR(temp_len - 3);<br>          u32 num = 1 + UR(ARITH_MAX);<br><br>          *(u32*)(out_buf + pos) =<br>            SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);<br><br>        &#125;<br><br>        break;<br><br>      case 9:<br><br>        /* Randomly add to dword, random endian. */<br><br>        if (temp_len &lt; 4) break;<br><br>        if (UR(2)) &#123;<br><br>          u32 pos = UR(temp_len - 3);<br><br>          *(u32*)(out_buf + pos) += 1 + UR(ARITH_MAX);<br><br>        &#125; else &#123;<br><br>          u32 pos = UR(temp_len - 3);<br>          u32 num = 1 + UR(ARITH_MAX);<br><br>          *(u32*)(out_buf + pos) =<br>            SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);<br><br>        &#125;<br><br>        break;<br><br>      case 10:<br><br>        /* Just set a random byte to a random value. Because,<br>           why not. We use XOR with 1-255 to eliminate the<br>           possibility of a no-op. */<br><br>        out_buf[UR(temp_len)] ^= 1 + UR(255);<br>        break;<br><br>      case 11 ... 12: &#123;<br><br>          /* Delete bytes. We&#x27;re making this a bit more likely<br>             than insertion (the next option) in hopes of keeping<br>             files reasonably small. */<br><br>          u32 del_from, del_len;<br><br>          if (temp_len &lt; 2) break;<br><br>          /* Don&#x27;t delete too much. */<br><br>          del_len = choose_block_len(temp_len - 1);<br><br>          del_from = UR(temp_len - del_len + 1);<br><br>          memmove(out_buf + del_from, out_buf + del_from + del_len,<br>                  temp_len - del_from - del_len);<br><br>          temp_len -= del_len;<br><br>          break;<br><br>        &#125;<br><br>      case 13:<br><br>        if (temp_len + HAVOC_BLK_XL &lt; MAX_FILE) &#123;<br><br>          /* Clone bytes (75%) or insert a block of constant bytes (25%). */<br><br>          u8  actually_clone = UR(4);<br>          u32 clone_from, clone_to, clone_len;<br>          u8* new_buf;<br><br>          if (actually_clone) &#123;<br><br>            clone_len  = choose_block_len(temp_len);<br>            clone_from = UR(temp_len - clone_len + 1);<br><br>          &#125; else &#123;<br><br>            clone_len = choose_block_len(HAVOC_BLK_XL);<br>            clone_from = 0;<br><br>          &#125;<br><br>          clone_to   = UR(temp_len);<br><br>          new_buf = ck_alloc_nozero(temp_len + clone_len);<br><br>          /* Head */<br><br>          memcpy(new_buf, out_buf, clone_to);<br><br>          /* Inserted part */<br><br>          if (actually_clone)<br>            memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);<br>          else<br>            memset(new_buf + clone_to,<br>                   UR(2) ? UR(256) : out_buf[UR(temp_len)], clone_len);<br><br>          /* Tail */<br>          memcpy(new_buf + clone_to + clone_len, out_buf + clone_to,<br>                 temp_len - clone_to);<br><br>          ck_free(out_buf);<br>          out_buf = new_buf;<br>          temp_len += clone_len;<br><br>        &#125;<br><br>        break;<br><br>      case 14: &#123;<br><br>          /* Overwrite bytes with a randomly selected chunk (75%) or fixed<br>             bytes (25%). */<br><br>          u32 copy_from, copy_to, copy_len;<br><br>          if (temp_len &lt; 2) break;<br><br>          copy_len  = choose_block_len(temp_len - 1);<br><br>          copy_from = UR(temp_len - copy_len + 1);<br>          copy_to   = UR(temp_len - copy_len + 1);<br><br>          if (UR(4)) &#123;<br><br>            if (copy_from != copy_to)<br>              memmove(out_buf + copy_to, out_buf + copy_from, copy_len);<br><br>          &#125; else memset(out_buf + copy_to,<br>                        UR(2) ? UR(256) : out_buf[UR(temp_len)], copy_len);<br><br>          break;<br><br>        &#125;<br><br>      /* Values 15 and 16 can be selected only if there are any extras<br>         present in the dictionaries. */<br><br>      case 15: &#123;<br><br>          /* Overwrite bytes with an extra. */<br><br>          if (!extras_cnt  (a_extras_cnt &amp;&amp; UR(2))) &#123;<br><br>            /* No user-specified extras or odds in our favor. Let&#x27;s use an<br>               auto-detected one. */<br><br>            u32 use_extra = UR(a_extras_cnt);<br>            u32 extra_len = a_extras[use_extra].len;<br>            u32 insert_at;<br><br>            if (extra_len &gt; temp_len) break;<br><br>            insert_at = UR(temp_len - extra_len + 1);<br>            memcpy(out_buf + insert_at, a_extras[use_extra].data, extra_len);<br><br>          &#125; else &#123;<br><br>            /* No auto extras or odds in our favor. Use the dictionary. */<br><br>            u32 use_extra = UR(extras_cnt);<br>            u32 extra_len = extras[use_extra].len;<br>            u32 insert_at;<br><br>            if (extra_len &gt; temp_len) break;<br><br>            insert_at = UR(temp_len - extra_len + 1);<br>            memcpy(out_buf + insert_at, extras[use_extra].data, extra_len);<br><br>          &#125;<br><br>          break;<br><br>        &#125;<br><br>      case 16: &#123;<br><br>          u32 use_extra, extra_len, insert_at = UR(temp_len + 1);<br>          u8* new_buf;<br><br>          /* Insert an extra. Do the same dice-rolling stuff as for the<br>             previous case. */<br><br>          if (!extras_cnt  (a_extras_cnt &amp;&amp; UR(2))) &#123;<br><br>            use_extra = UR(a_extras_cnt);<br>            extra_len = a_extras[use_extra].len;<br><br>            if (temp_len + extra_len &gt;= MAX_FILE) break;<br><br>            new_buf = ck_alloc_nozero(temp_len + extra_len);<br><br>            /* Head */<br>            memcpy(new_buf, out_buf, insert_at);<br><br>            /* Inserted part */<br>            memcpy(new_buf + insert_at, a_extras[use_extra].data, extra_len);<br><br>          &#125; else &#123;<br><br>            use_extra = UR(extras_cnt);<br>            extra_len = extras[use_extra].len;<br><br>            if (temp_len + extra_len &gt;= MAX_FILE) break;<br><br>            new_buf = ck_alloc_nozero(temp_len + extra_len);<br><br>            /* Head */<br>            memcpy(new_buf, out_buf, insert_at);<br><br>            /* Inserted part */<br>            memcpy(new_buf + insert_at, extras[use_extra].data, extra_len);<br><br>          &#125;<br><br>          /* Tail */<br>          memcpy(new_buf + insert_at + extra_len, out_buf + insert_at,<br>                 temp_len - insert_at);<br><br>          ck_free(out_buf);<br>          out_buf   = new_buf;<br>          temp_len += extra_len;<br><br>          break;<br><br>        &#125;<br><br>    &#125;<br><br>  &#125;<br><br>  if (common_fuzz_stuff(argv, out_buf, temp_len))<br>    goto abandon_entry;<br><br>  /* out_buf might have been mangled a bit, so let&#x27;s restore it to its<br>     original size and shape. */<br><br>  if (temp_len &lt; len) out_buf = ck_realloc(out_buf, len);<br>  temp_len = len;<br>  memcpy(out_buf, in_buf, len);<br><br>  /* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits<br>     permitting. */<br><br>  if (queued_paths != havoc_queued) &#123;<br><br>    if (perf_score &lt;= HAVOC_MAX_MULT * 100) &#123;<br>      stage_max  *= 2;<br>      perf_score *= 2;<br>    &#125;<br><br>    havoc_queued = queued_paths;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="SPLICING-阶段"><a href="#SPLICING-阶段" class="headerlink" title="SPLICING 阶段"></a>SPLICING 阶段</h5><p>最后一个阶段，它会随机选择出另外一个输入样例，然后对当前的输入样例和另外一个样例都选择出合适的偏移量，然后从该处将他们拼接起来，然后重新进入到 <code>RANDOM HAVOC</code> 阶段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#ifndef IGNORE_FINDS<br><br>  /************<br>   * SPLICING *<br>   ************/<br><br>  /* This is a last-resort strategy triggered by a full round with no findings.<br>     It takes the current input file, randomly selects another input, and<br>     splices them together at some offset, then relies on the havoc<br>     code to mutate that blob. */<br><br>retry_splicing:<br><br>  if (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;<br>      queued_paths &gt; 1 &amp;&amp; queue_cur-&gt;len &gt; 1) &#123;<br><br>    struct queue_entry* target;<br>    u32 tid, split_at;<br>    u8* new_buf;<br>    s32 f_diff, l_diff;<br><br>    /* First of all, if we&#x27;ve modified in_buf for havoc, let&#x27;s clean that<br>       up... */<br><br>    if (in_buf != orig_in) &#123;<br>      ck_free(in_buf);<br>      in_buf = orig_in;<br>      len = queue_cur-&gt;len;<br>    &#125;<br><br>    /* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */<br><br>    do &#123; tid = UR(queued_paths); &#125; while (tid == current_entry);<br><br>    splicing_with = tid;<br>    target = queue;<br><br>    while (tid &gt;= 100) &#123; target = target-&gt;next_100; tid -= 100; &#125;<br>    while (tid--) target = target-&gt;next;<br><br>    /* Make sure that the target has a reasonable length. */<br><br>    while (target &amp;&amp; (target-&gt;len &lt; 2  target == queue_cur)) &#123;<br>      target = target-&gt;next;<br>      splicing_with++;<br>    &#125;<br><br>    if (!target) goto retry_splicing;<br><br>    /* Read the testcase into a new buffer. */<br><br>    fd = open(target-&gt;fname, O_RDONLY);<br><br>    if (fd &lt; 0) PFATAL(&quot;Unable to open &#x27;%s&#x27;&quot;, target-&gt;fname);<br><br>    new_buf = ck_alloc_nozero(target-&gt;len);<br><br>    ck_read(fd, new_buf, target-&gt;len, target-&gt;fname);<br><br>    close(fd);<br><br>    /* Find a suitable splicing location, somewhere between the first and<br>       the last differing byte. Bail out if the difference is just a single<br>       byte or so. */<br><br>    locate_diffs(in_buf, new_buf, MIN(len, target-&gt;len), &amp;f_diff, &amp;l_diff);<br><br>    if (f_diff &lt; 0  l_diff &lt; 2  f_diff == l_diff) &#123;<br>      ck_free(new_buf);<br>      goto retry_splicing;<br>    &#125;<br><br>    /* Split somewhere between the first and last differing byte. */<br><br>    split_at = f_diff + UR(l_diff - f_diff);<br><br>    /* Do the thing. */<br><br>    len = target-&gt;len;<br>    memcpy(new_buf, in_buf, split_at);<br>    in_buf = new_buf;<br><br>    ck_free(out_buf);<br>    out_buf = ck_alloc_nozero(len);<br>    memcpy(out_buf, in_buf, len);<br><br>    goto havoc_stage;<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<h5 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h5><ul>
<li>设置 <code>ret_val</code> 的值为 0</li>
<li>如果 <code>queue_cur</code> 通过了评估，且 <code>was_fuzzed</code> 字段是 0，就设置 <code>queue_cur-&gt;was_fuzzed</code> 为 1，然后 <code>pending_not_fuzzed</code> 计数器减一</li>
<li>如果 <code>queue_cur</code> 是 <code>favored</code> , <code>pending_favored</code> 计数器减一。</li>
</ul>
<h4 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h4><p>读取其他 sync 文件夹下的 queue 文件，然后保存到自己的 queue 里。</p>
<ul>
<li>打开 <code>sync_dir</code> 文件夹</li>
<li>while循环读取该文件夹下的目录和文件 <code>while ((sd_ent = readdir(sd)))</code><ul>
<li>跳过<code>.</code>开头的文件和 <code>sync_id</code> 即我们自己的输出文件夹</li>
<li>读取 <code>out_dir/.synced/sd_ent-&gt;d_name</code> 文件即 <code>id_fd</code> 里的前4个字节到 <code>min_accept</code> 里，设置 <code>next_min_accept</code> 为 <code>min_accept</code> ，这个值代表之前从这个文件夹里读取到的最后一个queue的id。</li>
<li>设置 <code>stage_name</code> 为 <code>sprintf(stage_tmp, &quot;sync %u&quot;, ++sync_cnt);</code> ，设置 <code>stage_cur</code> 为 0，<code>stage_max</code> 为 0</li>
<li>循环读取 <code>sync_dir/sd_ent-&gt;d_name/queue</code> 文件夹里的目录和文件<ul>
<li>同样跳过 <code>.</code> 开头的文件和标识小于 <code>min_accept</code> 的文件，因为这些文件应该已经被 sync 过了。</li>
<li>如果标识 <code>syncing_case</code> 大于等于 <code>next_min_accept</code> ，就设置 <code>next_min_accept</code> 为 <code>syncing_case + 1</code></li>
<li>开始同步这个 case<ul>
<li>如果 case 大小为 0 或者大于 <code>MAX_FILE</code> (默认是1M),就不进行 sync。</li>
<li>否则 mmap 这个文件到内存内存里，然后 <code>write_to_testcase(mem, st.st_size)</code> ,并 <code>run_target</code> ,然后通过 <code>save_if_interesting</code> 来决定是否要导入这个文件到自己的 queue 里，如果发现了新的 path，就导入。<ul>
<li>设置 <code>syncing_party</code> 的值为<code>sd_ent-&gt;d_name</code></li>
<li>如果 <code>save_if_interesting</code> 返回 1，<code>queued_imported</code> 计数器就加 1</li>
</ul>
</li>
</ul>
</li>
<li><code>stage_cur</code> 计数器加一，如果 <code>stage_cur</code> 是 <code>stats_update_freq</code> 的倍数，就刷新一次展示界面。</li>
</ul>
</li>
<li>向id_fd写入当前的 <code>next_min_accept</code> 值</li>
</ul>
</li>
</ul>
<p>总结来说，这个函数就是先读取有哪些 fuzzer 文件夹，然后读取其他 fuzzer 文件夹下的 queue 文件夹里的 case，并依次执行，如果发现了新 path，就保存到自己的 queue 文件夹里，而且将最后一个 sync 的 case id 写入到 <code>.synced/其他fuzzer文件夹名</code> 文件里，以避免重复运行。</p>
<h4 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h4><p>因为 fuzz_one 部分过于庞大，而这个函数又不是那么特殊，因此把它拉出来做一个简短的说明。</p>
<ul>
<li>若有 <code>post_handler</code> ，那么就对样例调用 <code>post_handler</code></li>
<li>将样例写入文件，然后 <code>run_target</code> 执行</li>
<li>如果执行结果是超时则做如下操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (fault == FAULT_TMOUT) &#123;<br><br>  if (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;<br>    cur_skipped_paths++;<br>    return 1;<br>  &#125;<br><br>&#125; else subseq_tmouts = 0;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果发现了新路径，那么保存并增加 <code>queued_discovered</code> 计数器</li>
<li>更新页面 <code>show_stats</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">EXP_ST u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) &#123;<br><br>  u8 fault;<br><br>  if (post_handler) &#123;<br><br>    out_buf = post_handler(out_buf, &amp;len);<br>    if (!out_buf  !len) return 0;<br><br>  &#125;<br><br>  write_to_testcase(out_buf, len);<br><br>  fault = run_target(argv, exec_tmout);<br><br>  if (stop_soon) return 1;<br><br>  if (fault == FAULT_TMOUT) &#123;<br><br>    if (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;<br>      cur_skipped_paths++;<br>      return 1;<br>    &#125;<br><br>  &#125; else subseq_tmouts = 0;<br><br>  /* Users can hit us with SIGUSR1 to request the current input<br>     to be abandoned. */<br><br>  if (skip_requested) &#123;<br><br>     skip_requested = 0;<br>     cur_skipped_paths++;<br>     return 1;<br><br>  &#125;<br><br>  /* This handles FAULT_ERROR for us: */<br><br>  queued_discovered += save_if_interesting(argv, out_buf, len, fault);<br><br>  if (!(stage_cur % stats_update_freq)  stage_cur + 1 == stage_max)<br>    show_stats();<br><br>  return 0;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h5><p>执行结果是否发现了新路径，决定是否保存或跳过。如果保存了这个 case，则返回 1，否则返回 0。</p>
<ul>
<li>如果没有新的路径发现或者路径命中次数相同，就直接返回0</li>
<li>将 case 保存到 <code>fn = alloc_printf(&quot;%s/queue/id:%06u,%s&quot;, out_dir, queued_paths, describe_op(hnb))</code> 文件里</li>
<li>将新样本加入队列 <code>add_to_queue</code></li>
<li>如果 <code>hnb</code> 的值是2，代表发现了新路径，设置刚刚加入到队列里的 queue 的 <code>has_new_cov</code> 字段为 1，即 <code>queue_top-&gt;has_new_cov = 1</code> ，然后 <code>queued_with_cov</code> 计数器加一</li>
<li>保存hash到其exec_cksum</li>
<li>评估这个queue，<code>calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0)</code></li>
<li>根据fault结果进入不同的分支<ul>
<li>若是出现错误，则直接抛出异常</li>
<li>若是崩溃<ul>
<li>total_crashes计数器加一</li>
<li>如果unique_crashes大于能保存的最大数量<code>KEEP_UNIQUE_CRASH</code>即5000，就直接返回keeping的值</li>
<li>如果不是dumb mode，就<code>simplify_trace((u64 *) trace_bits)</code>进行规整</li>
<li>没有发现新的crash路径，就直接返回</li>
<li>否则，代表发现了新的crash路径，unique_crashes计数器加一，并将结果保存到<code>alloc_printf(&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;, out_dir,unique_crashes, kill_signal, describe_op(0))</code>文件。</li>
<li>更新last_crash_time和last_crash_execs</li>
</ul>
</li>
<li>若是超时<ul>
<li><code>total_tmouts</code> 计数器加一</li>
<li>如果 <code>unique_hangs</code> 的个数超过能保存的最大数量 <code>KEEP_UNIQUE_HANG</code> 则返回</li>
<li>若不是 dumb mode，就 <code>simplify_trace((u64 *) trace_bits)</code> 进行规整。</li>
<li>没有发现新的超时路径，就直接返回</li>
<li>否则，代表发现了新的超时路径，<code>unique_tmouts</code> 计数器加一</li>
<li>若 <code>hang_tmout</code> 大于 <code>exec_tmout</code> ，则以 <code>hang_tmout</code> 为timeout，重新执行一次 <code>runt_target</code><ul>
<li>若出现崩溃，就跳转到 <code>keep_as_crash</code></li>
<li>若没有超时则直接返回</li>
<li>否则就使 <code>unique_hangs</code> 计数器加一，更新 <code>last_hang_time</code> 的值，并保存到<code>alloc_printf(&quot;%s/hangs/id:%06llu,%s&quot;, out_dir, unique_hangs, describe_op(0))</code>文件。</li>
</ul>
</li>
</ul>
</li>
<li>若是其他情况，则直接返回</li>
</ul>
</li>
</ul>
<h2 id="插桩与路径发现的记录"><a href="#插桩与路径发现的记录" class="headerlink" title="插桩与路径发现的记录"></a>插桩与路径发现的记录</h2><p>其实插桩已经叙述过一部分了，在上文中的 <code>fork server</code> 部分，笔者就介绍过该机制就是通过插桩实现的。</p>
<p>但还有一部分内容没有涉及，新路径是如何在发现的同时被通知给 fuzzer 的？</p>
<p>在插桩阶段，我们为每个分支跳转都添加了一小段代码，这里笔者以 64 位的情况进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static const u8* trampoline_fmt_64 =<br><br>  &quot;\n&quot;<br>  &quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;<br>  &quot;\n&quot;<br>  &quot;.align 4\n&quot;<br>  &quot;\n&quot;<br>  &quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;movq %%rdx,  0(%%rsp)\n&quot;<br>  &quot;movq %%rcx,  8(%%rsp)\n&quot;<br>  &quot;movq %%rax, 16(%%rsp)\n&quot;<br>  &quot;movq $0x%08x, %%rcx\n&quot;<br>  &quot;call __afl_maybe_log\n&quot;<br>  &quot;movq 16(%%rsp), %%rax\n&quot;<br>  &quot;movq  8(%%rsp), %%rcx\n&quot;<br>  &quot;movq  0(%%rsp), %%rdx\n&quot;<br>  &quot;leaq (128+24)(%%rsp), %%rsp\n&quot;<br>  &quot;\n&quot;<br>  &quot;/* --- END --- */\n&quot;<br>  &quot;\n&quot;;<br></code></pre></td></tr></table></figure>

<p>它首先保存了一部分将要被破坏的寄存器，然后调用了 <code>__afl_maybe_log</code> 来记录路径的发现。该函数同样是由汇编编写的，但我们可以用一些其他工具来反编译它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char __fastcall _afl_maybe_log(__int64 a1, __int64 a2, __int64 a3, __int64 a4)<br>&#123;<br>  char v4; // of<br>  char v5; // al<br>  __int64 v6; // rdx<br>  __int64 v7; // rcx<br>  char *v9; // rax<br>  int v10; // eax<br>  void *v11; // rax<br>  int v12; // edi<br>  __int64 v13; // rax<br>  __int64 v14; // rax<br>  __int64 v15; // [rsp-10h] [rbp-180h]<br>  char v16; // [rsp+10h] [rbp-160h]<br>  __int64 v17; // [rsp+18h] [rbp-158h]<br><br>  v5 = v4;<br>  v6 = _afl_area_ptr;<br>  if ( !_afl_area_ptr )<br>  &#123;<br>    if ( _afl_setup_failure )<br>      return v5 + 127;<br>    v6 = _afl_global_area_ptr;<br>    if ( _afl_global_area_ptr )<br>    &#123;<br>      _afl_area_ptr = _afl_global_area_ptr;<br>    &#125;<br>    else<br>    &#123;<br>      v16 = v4;<br>      v17 = a4;<br>      v9 = getenv(&quot;__AFL_SHM_ID&quot;);<br>      if ( !v9  (v10 = atoi(v9), v11 = shmat(v10, 0LL, 0), v11 == -1LL) )<br>      &#123;<br>        ++_afl_setup_failure;<br>        v5 = v16;<br>        return v5 + 127;<br>      &#125;<br>      _afl_area_ptr = v11;<br>      _afl_global_area_ptr = v11;<br>      v15 = v11;<br>      if ( write(199, &amp;_afl_temp, 4uLL) == 4 )<br>      &#123;<br>        while ( 1 )<br>        &#123;<br>          v12 = 198;<br>          if ( read(198, &amp;_afl_temp, 4uLL) != 4 )<br>            break;<br>          LODWORD(v13) = fork();<br>          if ( v13 &lt; 0 )<br>            break;<br>          if ( !v13 )<br>            goto __afl_fork_resume;<br>          _afl_fork_pid = v13;<br>          write(199, &amp;_afl_fork_pid, 4uLL);<br>          v12 = _afl_fork_pid;<br>          LODWORD(v14) = waitpid(_afl_fork_pid, &amp;_afl_temp, 0);<br>          if ( v14 &lt;= 0 )<br>            break;<br>          write(199, &amp;_afl_temp, 4uLL);<br>        &#125;<br>        _exit(v12);<br>      &#125;<br>__afl_fork_resume:<br>      close(198);<br>      close(199);<br>      v6 = v15;<br>      v5 = v16;<br>      a4 = v17;<br>    &#125;<br>  &#125;<br>  v7 = _afl_prev_loc ^ a4;<br>  _afl_prev_loc ^= v7;<br>  _afl_prev_loc = _afl_prev_loc &gt;&gt; 1;<br>  ++*(v6 + v7);<br>  return v5 + 127;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前面的一大段代码其实都是为了去建立我们在上文所说的“共享内存”，在完成初始化后调用最后这么一小段代码进行记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">v7 = _afl_prev_loc ^ a4;<br>_afl_prev_loc ^= v7;<br>_afl_prev_loc = _afl_prev_loc &gt;&gt; 1;<br>++*(v6 + v7);<br></code></pre></td></tr></table></figure>

<p>此处 <code>v6</code> 即为共享内存的地址，而 <code>a4</code> 为 <code>cur_location</code> ，因此 <code>v7=cur_location ^ prev_location</code> ，它将作为索引，使得共享内存中的对应偏移处的值增加。而在 fuzzer 部分就可以通过检查这块内存来发现是否有新路径被得到了。</p>
<p>另外，<code>_afl_prev_loc = _afl_prev_loc &gt;&gt; 1;</code> 的目的是为了避开 <code>A-&gt;A</code> 和 <code>B-&gt;B</code> 以及 <code>A-&gt;B</code> 和 <code>B-&gt;A</code> 被识别为相同路径的情况。</p>
<h2 id="其他阅读材料"><a href="#其他阅读材料" class="headerlink" title="其他阅读材料"></a>其他阅读材料</h2><blockquote>
<p>sakuraのAFL源码全注释<br><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
<p>fuzzer AFL 源码分析<br><a target="_blank" rel="noopener" href="https://tttang.com/user/f1tao">https://tttang.com/user/f1tao</a></p>
<p>AFL二三事——源码分析<br><a target="_blank" rel="noopener" href="https://paper.seebug.org/1732/#afl-afl-asc">https://paper.seebug.org/1732/#afl-afl-asc</a></p>
<p>AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing<br><a target="_blank" rel="noopener" href="https://paper.seebug.org/841/">https://paper.seebug.org/841/</a></p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/12/angr-tips-1/">← Next Angr 使用技巧速通笔记(一)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/02/20/glibc2-34-iofile-exploit/">GLIBC2.34以后的IO FILE利用链 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AFL-%E6%BA%90%E4%BB%A3%E7%A0%81%E9%80%9F%E9%80%9A%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">AFL 源代码速通笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-gcc-%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">afl-gcc 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fuzz"><span class="toc-number">1.2.</span> <span class="toc-text">afl-fuzz</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">1.2.1.</span> <span class="toc-text">setup_signal_handlers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">1.2.2.</span> <span class="toc-text">check_asan_opts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">1.2.3.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-cmdline"><span class="toc-number">1.2.4.</span> <span class="toc-text">save_cmdline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-banner"><span class="toc-number">1.2.5.</span> <span class="toc-text">fix_up_banner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-if-tty"><span class="toc-number">1.2.6.</span> <span class="toc-text">check_if_tty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-core-count"><span class="toc-number">1.2.7.</span> <span class="toc-text">get_core_count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-crash-handling"><span class="toc-number">1.2.8.</span> <span class="toc-text">check_crash_handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-cpu-governor"><span class="toc-number">1.2.9.</span> <span class="toc-text">check_cpu_governor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-post"><span class="toc-number">1.2.10.</span> <span class="toc-text">setup_post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-shm"><span class="toc-number">1.2.11.</span> <span class="toc-text">setup_shm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-count-class16"><span class="toc-number">1.2.12.</span> <span class="toc-text">init_count_class16</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">1.2.13.</span> <span class="toc-text">setup_dirs_fds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-testcases"><span class="toc-number">1.2.14.</span> <span class="toc-text">read_testcases</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-to-queue"><span class="toc-number">1.2.14.1.</span> <span class="toc-text">add_to_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-auto"><span class="toc-number">1.2.15.</span> <span class="toc-text">load_auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">1.2.16.</span> <span class="toc-text">pivot_inputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-extras"><span class="toc-number">1.2.17.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-timeout"><span class="toc-number">1.2.18.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detect-file-args"><span class="toc-number">1.2.19.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">1.2.20.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-binary"><span class="toc-number">1.2.21.</span> <span class="toc-text">check_binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#perform-dry-run"><span class="toc-number">1.2.22.</span> <span class="toc-text">perform_dry_run</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#calibrate-case"><span class="toc-number">1.2.22.1.</span> <span class="toc-text">calibrate_case</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#init-forkserver"><span class="toc-number">1.2.22.1.1.</span> <span class="toc-text">init_forkserver</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cull-queue"><span class="toc-number">1.2.23.</span> <span class="toc-text">cull_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#show-init-stats"><span class="toc-number">1.2.24.</span> <span class="toc-text">show_init_stats</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-start-position"><span class="toc-number">1.2.25.</span> <span class="toc-text">find_start_position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-stats-file"><span class="toc-number">1.2.26.</span> <span class="toc-text">write_stats_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-auto"><span class="toc-number">1.2.27.</span> <span class="toc-text">save_auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#afl-fuzz-%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.28.</span> <span class="toc-text">afl-fuzz 主循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fuzz-one"><span class="toc-number">1.2.28.1.</span> <span class="toc-text">fuzz_one</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CALIBRATION-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.1.</span> <span class="toc-text">CALIBRATION 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TRIMMING-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.2.</span> <span class="toc-text">TRIMMING 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PERFORMANCE-SCORE-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.3.</span> <span class="toc-text">PERFORMANCE SCORE 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SIMPLE-BITFLIP-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.4.</span> <span class="toc-text">SIMPLE BITFLIP 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ARITHMETIC-INC-DEC-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.5.</span> <span class="toc-text">ARITHMETIC INC&#x2F;DEC 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#INTERESTING-VALUES-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.6.</span> <span class="toc-text">INTERESTING VALUES 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DICTIONARY-STUFF-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.7.</span> <span class="toc-text">DICTIONARY STUFF 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RANDOM-HAVOC-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.8.</span> <span class="toc-text">RANDOM HAVOC 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SPLICING-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.28.1.9.</span> <span class="toc-text">SPLICING 阶段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number">1.2.28.1.10.</span> <span class="toc-text">结束</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">1.2.28.2.</span> <span class="toc-text">sync_fuzzers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#common-fuzz-stuff"><span class="toc-number">1.2.28.3.</span> <span class="toc-text">common_fuzz_stuff</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#save-if-interesting"><span class="toc-number">1.2.28.3.1.</span> <span class="toc-text">save_if_interesting</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A1%A9%E4%B8%8E%E8%B7%AF%E5%BE%84%E5%8F%91%E7%8E%B0%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">插桩与路径发现的记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text">其他阅读材料</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>