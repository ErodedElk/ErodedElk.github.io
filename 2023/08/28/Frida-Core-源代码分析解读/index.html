<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Frida-Core 源代码分析解读 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Frida-Core 源代码分析解读</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-08-28T14:26:36.000Z" id="date"> 2023-08-28</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.977Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>书接上文，在理解了 frida 是如何对代码进行 hook 的以后，接下来笔者打算研究一下 Frida 是如何与用户进行交互实现动态的 hook 。因此还是按照前文的逻辑，我们从 frida-core 开始。</p>
<blockquote>
<p>前篇：《Frida-gum 源代码速通笔记》<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-278423.htm">https://bbs.kanxue.com/thread-278423.htm</a></p>
</blockquote>
<h1 id="本文内容目录"><a href="#本文内容目录" class="headerlink" title="本文内容目录"></a>本文内容目录</h1><p>本文主要涉及的是 Frida-core 模块的实现代码分析，大致内容包括：</p>
<ul>
<li>Frida-Core<ul>
<li>Frida-Server<ul>
<li>进程注入</li>
<li>frida-server 工作流程</li>
<li>frida-agent</li>
<li>frida-helper</li>
</ul>
</li>
<li>Frida-Gadget</li>
<li>launchd</li>
<li>总结 &#x2F; 以及一个奇怪的问题</li>
</ul>
</li>
</ul>
<h1 id="Frida-Core"><a href="#Frida-Core" class="headerlink" title="Frida-Core"></a>Frida-Core</h1><h2 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h2><p>首先要解决的第一个问题是，我们尽管知道 Frida-gum 能够对程序进行动态插桩，并也在上一节中介绍过它的工作原理，但是也正如我们所知，无论在 Android 还是 iOS 或者其他平台，进程和进程直接相互是透明的，就算对 Frida 来说目标进程并非透明的，但是对目标进程来说，至少 Frida 也该是透明的。但是现实情况显然是，二者往往需要相互之间识别并交互。</p>
<p>那么解决方案似乎也呼之欲出了，既然两个进程不能相互识别，那么让它们成为一个进程不就好了？</p>
<p>由于笔者本文主要是面向 iOS 的，因此下文中笔者会选择 darwin 平台的代码进行分析。对于 Android 平台，frida 的实现是有所不同的，不过大体的逻辑还是有些相似的，仅供参考。</p>
<p>本部分的代码主要定义在 <code>inject/src/darwin/darwin-host-session.vala</code> 中，可以注意到，它是由 vala 编写的语言，这对我来说有些陌生。不过好在它的语法结构和 C 很像，并且编译 vala 的过程其实就是把它先转为 C 代码再使用 C 的编译器完成的，因此大体上还是能够从语意上理解逻辑。</p>
<blockquote>
<p>糟糕的是，我的 VSCode 不再支持代码跟踪了，即便装了插件也还是如此，要命。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inject/src/darwin/darwin-host-session.vala</span><br><br>		private async uint <span class="hljs-title function_">inject_agent</span> <span class="hljs-params">(uint pid, <span class="hljs-built_in">string</span> agent_parameters, Cancellable? cancellable)</span> throws Error, IOError &#123;<br>			uint id;<br><br>			unowned <span class="hljs-built_in">string</span> entrypoint = <span class="hljs-string">&quot;frida_agent_main&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_EMBEDDED_ASSETS</span><br>			id = yield fruitjector.inject_library_resource (pid, agent, entrypoint, agent_parameters, cancellable);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>			<span class="hljs-built_in">string</span> agent_path = Config.FRIDA_AGENT_PATH;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IOS || TVOS</span><br>			unowned <span class="hljs-built_in">string</span>? cryptex_path = Environment.get_variable (<span class="hljs-string">&quot;CRYPTEX_MOUNT_PATH&quot;</span>);<br>			<span class="hljs-keyword">if</span> (cryptex_path != null)<br>				agent_path = cryptex_path + agent_path;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>			id = yield fruitjector.inject_library_file (pid, agent_path, entrypoint, agent_parameters, cancellable);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>			<span class="hljs-keyword">return</span> id;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>跟入 <code>inject_library_file</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inject/src/darwin/fruitjector.vala</span><br>		public async uint <span class="hljs-title function_">inject_library_file</span> <span class="hljs-params">(uint pid, <span class="hljs-built_in">string</span> path, <span class="hljs-built_in">string</span> entrypoint, <span class="hljs-built_in">string</span> data,</span><br><span class="hljs-params">				Cancellable? cancellable)</span> throws Error, IOError &#123;<br>			var id = yield helper.inject_library_file (pid, path, entrypoint, data, cancellable);<br>			pid_by_id[id] = pid;<br>			<span class="hljs-keyword">return</span> id;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>因此再次跟入 <code>inject_library_file</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inject/src/darwin/frida-helper-service.vala</span><br>		public async uint <span class="hljs-title function_">inject_library_file</span> <span class="hljs-params">(uint pid, <span class="hljs-built_in">string</span> path, <span class="hljs-built_in">string</span> entrypoint, <span class="hljs-built_in">string</span> data, Cancellable? cancellable)</span><br>				throws Error, IOError &#123;<br>			<span class="hljs-keyword">return</span> yield backend.inject_library_file (pid, path, entrypoint, data, cancellable);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>好吧，我们再次跟入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inject/src/darwin/frida-helper-backend.vala</span><br>		public async uint <span class="hljs-title function_">inject_library_file</span> <span class="hljs-params">(uint pid, <span class="hljs-built_in">string</span> path, <span class="hljs-built_in">string</span> entrypoint, <span class="hljs-built_in">string</span> data, Cancellable? cancellable)</span><br>				throws Error, IOError &#123;<br>			<span class="hljs-keyword">return</span> yield _inject (pid, path, null, entrypoint, data, cancellable);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>继续跟入 <code>_inject</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inject/src/darwin/frida-helper-backend.vala</span><br>		private async uint _inject (uint pid, <span class="hljs-built_in">string</span> path_or_name, MappedLibraryBlob? blob, <span class="hljs-built_in">string</span> entrypoint, <span class="hljs-built_in">string</span> data,<br>				Cancellable? cancellable) throws Error, IOError &#123;<br>			yield <span class="hljs-title function_">prepare_target</span> <span class="hljs-params">(pid, cancellable)</span>;<br><br>			var task = task_for_pid (pid);<br>			try &#123;<br>				<span class="hljs-keyword">return</span> _inject_into_task (pid, task, path_or_name, blob, entrypoint, data);<br>			&#125; finally &#123;<br>				deallocate_port (task);<br>			&#125;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>可以看见此处将会使用 <code>_inject_into_task</code> 实现进程注入的方式，这里跟入 <code>_frida_darwin_helper_backend_inject_into_task</code> ，由于函数体比较大，这里省略部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">guint<br>_frida_darwin_helper_backend_inject_into_task (FridaDarwinHelperBackend * self, guint pid, guint task, <span class="hljs-type">const</span> gchar * path_or_name, FridaMappedLibraryBlob * blob,<br>    <span class="hljs-type">const</span> gchar * entrypoint, <span class="hljs-type">const</span> gchar * data, GError ** error)<br>&#123;<br><span class="hljs-comment">//此处省略</span><br><span class="hljs-comment">//1. 初始化实例</span><br>  self_task = mach_task_self ();<br><br>  instance = frida_inject_instance_new (self, self-&gt;next_id++, pid);<br>  mach_port_mod_refs (self_task, task, MACH_PORT_RIGHT_SEND, <span class="hljs-number">1</span>);<br>  instance-&gt;task = task;<br><br>  resolver = gum_darwin_module_resolver_new (task, &amp;io_error);<br><span class="hljs-comment">//此处省略</span><br><span class="hljs-comment">//2. 在进程的内存空间中开辟内存</span><br>  kr = mach_vm_allocate (task, &amp;payload_address, instance-&gt;payload_size, VM_FLAGS_ANYWHERE);<br>  CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_allocate(payload)&quot;</span>);<br>  instance-&gt;payload_address = payload_address;<br><br>  kr = mach_vm_allocate (self_task, &amp;agent_context_address, layout.data_size, VM_FLAGS_ANYWHERE);<br>  g_assert (kr == KERN_SUCCESS);<br>  instance-&gt;agent_context = (FridaAgentContext *) agent_context_address;<br>  instance-&gt;agent_context_size = layout.data_size;<br><br>  data_address = payload_address + layout.data_offset;<br>  kr = mach_vm_remap (task, &amp;data_address, layout.data_size, <span class="hljs-number">0</span>, VM_FLAGS_OVERWRITE, self_task, agent_context_address,<br>      FALSE, &amp;cur_protection, &amp;max_protection, VM_INHERIT_SHARE);<br><span class="hljs-comment">//此处省略</span><br><span class="hljs-comment">//3. 修改内存段权限</span><br>  kr = mach_vm_protect (task, payload_address + layout.stack_guard_offset, layout.stack_guard_size, FALSE, VM_PROT_NONE);<br>  CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_protect&quot;</span>);<br><span class="hljs-comment">//4. 初始化实例</span><br>  <span class="hljs-keyword">if</span> (!frida_agent_context_init (&amp;agent_ctx, &amp;details, &amp;layout, payload_address, instance-&gt;payload_size, resolver, mapper, error))<br>    <span class="hljs-keyword">goto</span> failure;<br><span class="hljs-comment">//5. 创建代码</span><br>  frida_agent_context_emit_mach_stub_code (&amp;agent_ctx, mach_stub_code, resolver, mapper);<br><br>  frida_agent_context_emit_pthread_stub_code (&amp;agent_ctx, pthread_stub_code, resolver, mapper);<br></code></pre></td></tr></table></figure>

<p>正如注释中所述，其实就是通过 iOS 平台本身提供的 api 往进程的内存空间中开辟内存段。</p>
<p>关键是接下来的部分。如果该平台允许存在 rwx 段那么将执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (gum_query_is_rwx_supported () || !gum_code_segment_is_supported ())<br>  &#123;<br><span class="hljs-comment">//1. 向进程内存空间中写入 mach_stub_code 的代码</span><br>    kr = mach_vm_write (task, payload_address + layout.mach_code_offset,<br>        (<span class="hljs-type">vm_offset_t</span>) mach_stub_code, <span class="hljs-keyword">sizeof</span> (mach_stub_code));<br>    CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_write(mach_stub_code)&quot;</span>);<br><span class="hljs-comment">//2. 向进程内存空间中写入 pthread_stub_code 的代码</span><br>    kr = mach_vm_write (task, payload_address + layout.pthread_code_offset,<br>        (<span class="hljs-type">vm_offset_t</span>) pthread_stub_code, <span class="hljs-keyword">sizeof</span> (pthread_stub_code));<br>    CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_write(pthread_stub_code)&quot;</span>);<br><span class="hljs-comment">//3. 将权限改为 rx</span><br>    kr = mach_vm_protect (task, payload_address + layout.code_offset, page_size, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);<br>    CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_protect&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，对于已越狱的 iOS 设备，这么做是可行的；但是对于非越狱设备，系统并不允许由用户分配带有执行权限的内存段，同理也不允许修改段段权限为可执行。</p>
</blockquote>
<p>而对于不支持上述条件的情况，包括设备未越狱，那么则使用如下分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">else</span><br>  &#123;<br>    GumCodeSegment * segment;<br>    guint8 * scratch_page;<br>    <span class="hljs-type">mach_vm_address_t</span> code_address;<br><span class="hljs-comment">//1.创建一个新的内存段，此时它尚且没有执行权限</span><br>    segment = gum_code_segment_new (page_size, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//2. 将代码拷贝到该内存段</span><br>    scratch_page = gum_code_segment_get_address (segment);<br>    <span class="hljs-built_in">memcpy</span> (scratch_page + layout.mach_code_offset, mach_stub_code, <span class="hljs-keyword">sizeof</span> (mach_stub_code));<br>    <span class="hljs-built_in">memcpy</span> (scratch_page + layout.pthread_code_offset, pthread_stub_code, <span class="hljs-keyword">sizeof</span> (pthread_stub_code));<br><span class="hljs-comment">//3. 为代码构造具有可执行权限的内存段</span><br>    gum_code_segment_realize (segment);<br>    gum_code_segment_map (segment, <span class="hljs-number">0</span>, page_size, scratch_page);<br><span class="hljs-comment">//4。 将其映射到 code_address 去</span><br>    code_address = payload_address + layout.code_offset;<br>    kr = mach_vm_remap (task, &amp;code_address, page_size, <span class="hljs-number">0</span>, VM_FLAGS_OVERWRITE, self_task, (<span class="hljs-type">mach_vm_address_t</span>) scratch_page,<br>        FALSE, &amp;cur_protection, &amp;max_protection, VM_INHERIT_COPY);<br><br>    gum_code_segment_free (segment);<br><br>    CHECK_MACH_RESULT (kr, ==, KERN_SUCCESS, <span class="hljs-string">&quot;mach_vm_remap(code)&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>笔者大致查了一下，在 iOS 中，程序的代码段都是需要经过签名验证的，因此对于未经过签名的代码段是会因此而产生异常的，所以在 iOS 上不能使用 smc 也是这个原因，因为代码要么不可变要么不可执行。但反过来，它们允许用户删除对代码段的执行权限，这是合法的。</p>
</blockquote>
<p>这里我们跟入 <code>gum_code_segment_realize</code> 看看是如何得到可执行内存段的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> gboolean<br><span class="hljs-title function_">gum_code_segment_try_realize</span> <span class="hljs-params">(GumCodeSegment * self)</span><br>&#123;<br>  gchar * dylib_path;<br>  GumCodeLayout layout;<br>  guint8 * dylib_header;<br>  gsize dylib_header_size;<br>  guint8 * code_signature;<br>  gint res;<br>  <span class="hljs-type">fsignatures_t</span> sigs;<br><span class="hljs-comment">//1. 创建临时文件 frida-XXXXXX.dylib</span><br>  self-&gt;fd = gum_file_open_tmp (<span class="hljs-string">&quot;frida-XXXXXX.dylib&quot;</span>, &amp;dylib_path);<br>  <span class="hljs-keyword">if</span> (self-&gt;fd == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> FALSE;<br><br>  gum_code_segment_compute_layout (self, &amp;layout);<br><span class="hljs-comment">//2. 构造 mach 文件头</span><br>  dylib_header = g_malloc0 (layout.header_file_size);<br>  gum_put_mach_headers (dylib_path, &amp;layout, dylib_header, &amp;dylib_header_size);<br><span class="hljs-comment">//3. 构造 code signature</span><br>  code_signature = g_malloc0 (layout.code_signature_file_size);<br>  gum_put_code_signature (dylib_header, self-&gt;data, &amp;layout, code_signature);<br><span class="hljs-comment">//4. 写入文件</span><br>  gum_file_write_all (self-&gt;fd, GUM_OFFSET_NONE, dylib_header,<br>      dylib_header_size);<br>  gum_file_write_all (self-&gt;fd, layout.text_file_offset, self-&gt;data,<br>      layout.text_size);<br>  gum_file_write_all (self-&gt;fd, layout.code_signature_file_offset,<br>      code_signature, layout.code_signature_file_size);<br><br>  sigs.fs_file_start = <span class="hljs-number">0</span>;<br>  sigs.fs_blob_start = GSIZE_TO_POINTER (layout.code_signature_file_offset);<br>  sigs.fs_blob_size = layout.code_signature_file_size;<br><span class="hljs-comment">//3. 添加签名</span><br>  res = fcntl (self-&gt;fd, F_ADDFILESIGS, &amp;sigs);<br><br>  unlink (dylib_path);<br><br>  g_free (code_signature);<br>  g_free (dylib_header);<br>  g_free (dylib_path);<br><br>  <span class="hljs-keyword">return</span> res == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上操作完成了构造一个 dylib 的行为，接下来程序将会调用 <code>gum_code_segment_try_map</code> 将该动态库映射到内存中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> gboolean<br><span class="hljs-title function_">gum_code_segment_try_map</span> <span class="hljs-params">(GumCodeSegment * self,</span><br><span class="hljs-params">                          gsize source_offset,</span><br><span class="hljs-params">                          gsize source_size,</span><br><span class="hljs-params">                          gpointer target_address)</span><br>&#123;<br>  gpointer result;<br><br>  result = mmap (target_address, source_size, PROT_READ | PROT_EXEC,<br>      MAP_PRIVATE | MAP_FIXED, self-&gt;fd,<br>      gum_query_page_size () + source_offset);<br><br>  <span class="hljs-keyword">return</span> result != MAP_FAILED;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意到此处使用 <code>mmap</code> 去映射文件到 <code>target_address</code> 并给出了可读可执行的权限标志。接下来这段内存就已经被注入到进程中去了。</p>
<p>其实这个地方用到的就是一个小 trick。正如前文所说，iOS 不允许让一个 rw 页面变为 rx，也不允许让 rx 页面变为 rwx ，但是加载可执行文件的行为是不被禁止的，因为那属于正常的诉求，因此这里用需要注入的代码去构建可执行文件，最后再将其映射到内存中去，这样就没有修改任何页面了权限了。</p>
<blockquote>
<p>其实实际原因是，对于正常组织的代码段，有一个 max_protection 去限制能够允许 mprotect 设定权限的范围，默认情况下会被限制为 rx，也就是说只允许对这段内存给出 rx 中的范围。但是通过 mmap 创建的内存段的 max_protection 是允许给出 rwx 权限的。所以实际是只要最后是用 mmap 去构建注入内存，总会有办法解决的。</p>
</blockquote>
<blockquote>
<p>您也可以参考本文：<a target="_blank" rel="noopener" href="https://www.codercto.com/a/63507.html">https://www.codercto.com/a/63507.html</a></p>
</blockquote>
<p>最后调用 <code>mach_vm_remap</code> 把这段内存重新映射回去即可。</p>
<h2 id="frida-server"><a href="#frida-server" class="headerlink" title="frida-server"></a>frida-server</h2><p>在介绍了大致的 frida 进程注入的原理以后，接下来我们正式开始跟一下 frida 具体是如何开始工作的。</p>
<p>在启动 frida 后，程序将从 <code>run_application</code> 开始向下调用 <code>application.run</code> ，然后再往下调用 <code>start.begin</code>，此时，它将通过 <code>service.start</code> 去启动一个 <code>ControlService</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">		public async <span class="hljs-type">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">(Cancellable? cancellable = null)</span> throws Error, IOError &#123;<br>			<span class="hljs-keyword">if</span> (state != STOPPED)<br>				throw new Error.INVALID_OPERATION (<span class="hljs-string">&quot;Invalid operation&quot;</span>);<br>			state = STARTING;<br><br>			try &#123;<br><span class="hljs-comment">//1. WebService 被启动</span><br>				yield service.start (cancellable);<br><br>				<span class="hljs-keyword">if</span> (options.enable_preload) &#123;<br><span class="hljs-comment">//2. 创建 BaseDBusHostSession</span><br>					var base_host_session = host_session as BaseDBusHostSession;<br>					<span class="hljs-keyword">if</span> (base_host_session != null)<br>						base_host_session.preload.begin (io_cancellable);<br>				&#125;<br><br>				state = STARTED;<br>			&#125; finally &#123;<br>				<span class="hljs-keyword">if</span> (state != STARTED)<br>					state = STOPPED;<br>			&#125;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们跟入 <code>WebService</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">		public async <span class="hljs-type">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">(Cancellable? cancellable)</span> throws Error, IOError &#123;<br>			frida_context = MainContext.ref_thread_default ();<br>			dbus_context = yield get_dbus_context ();<br><br>			cancellable.set_error_if_cancelled ();<br><br>			var start_request = new Promise&lt;SocketAddress&gt; ();<br><span class="hljs-comment">//1. handle_start_request 开始调度</span><br>			schedule_on_dbus_thread (() =&gt; &#123;<br>				handle_start_request.begin (start_request, cancellable);<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;);<br><br>			_listen_address = yield start_request.<span class="hljs-built_in">future</span>.wait_async (cancellable);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>而 <code>handle_start_request</code> 会向下调用 <code>do_start</code> 完成具体的工作，包括监听地址，设置处理函数等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">		private async SocketAddress <span class="hljs-title function_">do_start</span> <span class="hljs-params">(Cancellable? cancellable)</span> throws Error, IOError &#123;<br>			server = (Soup.Server) Object.new (typeof (Soup.Server),<br>				<span class="hljs-string">&quot;tls-certificate&quot;</span>, endpoint_params.certificate);<br><span class="hljs-comment">//1. 设置 websocket_handler</span><br>			server.add_websocket_handler (<span class="hljs-string">&quot;/ws&quot;</span>, endpoint_params.origin, null, on_websocket_opened);<br><span class="hljs-comment">//......此处省略</span><br>				SocketAddress? effective_address = null;<br>				InetSocketAddress? inet_address = address as InetSocketAddress;<br>				<span class="hljs-keyword">if</span> (inet_address != null) &#123;<br>					uint16 start_port = inet_address.get_port ();<br>					uint16 candidate_port = start_port;<br>					<span class="hljs-keyword">do</span> &#123;<br>						try &#123;<br><span class="hljs-comment">//2. 监听地址</span><br>							server.listen (inet_address, listen_options);<br></code></pre></td></tr></table></figure>

<p>跟入 <code>on_websocket_opened</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">private <span class="hljs-type">void</span> <span class="hljs-title function_">on_websocket_opened</span> <span class="hljs-params">(Soup.Server server, Soup.ServerMessage msg, <span class="hljs-built_in">string</span> path,</span><br><span class="hljs-params">		Soup.WebsocketConnection connection)</span> &#123;<br>	var peer = new WebConnection (connection);<br><br>	IOStream soup_stream = connection.get_io_stream ();<br><br>	SocketConnection socket_stream;<br>	soup_stream.get (<span class="hljs-string">&quot;base-iostream&quot;</span>, out socket_stream);<br><br>	SocketAddress remote_address;<br>	try &#123;<br>		remote_address = socket_stream.get_remote_address ();<br>	&#125; catch (GLib.Error e) &#123;<br>		assert_not_reached ();<br>	&#125;<br><br>	schedule_on_frida_thread (() =&gt; &#123;<br>		incoming (peer, remote_address);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处发送了 <code>incoming</code> 信号，而对应的处理被在构造函数中可见：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">		construct &#123;<br>			host_session.spawn_added.connect (notify_spawn_added);<br>			host_session.child_added.connect (notify_child_added);<br>			host_session.child_removed.connect (notify_child_removed);<br>			host_session.process_crashed.connect (notify_process_crashed);<br>			host_session.output.connect (notify_output);<br>			host_session.agent_session_detached.connect (on_agent_session_detached);<br>			host_session.uninjected.connect (notify_uninjected);<br><br>			service = new WebService (endpoint_params, CONTROL);<br><span class="hljs-comment">//1. 此处注册了 on_server_connection</span><br>			service.incoming.connect (on_server_connection);<br><br>			broker_service.incoming.connect (on_broker_service_connection);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>从 <code>on_server_connection</code> 跟入 <code>handle_server_connection</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">		private async <span class="hljs-type">void</span> <span class="hljs-title function_">handle_server_connection</span> <span class="hljs-params">(IOStream raw_connection)</span> throws GLib.Error &#123;<br><span class="hljs-comment">//1. 创建 DBusConnection</span><br>			var connection = yield new DBusConnection (raw_connection, null, DELAY_MESSAGE_PROCESSING, null, io_cancellable);<br>			connection.on_closed.connect (on_connection_closed);<br><br>			Peer peer;<br>			AuthenticationService? auth_service = endpoint_params.auth_service;<br>			<span class="hljs-keyword">if</span> (auth_service != null)<br>				peer = new AuthenticationChannel (this, connection, auth_service);<br>			<span class="hljs-keyword">else</span><br><span class="hljs-comment">//2. 创建 controlchannel</span><br>				peer = setup_control_channel (connection);<br>			peers[connection] = peer;<br><br>			connection.start_message_processing ();<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>对于不需要认证的情况，将会调用 <code>setup_control_channel</code>  完成初始化，而该函数将会返回一个 <code>ControlChannel</code> 对象，其构造函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">construct &#123;<br>	try &#123;<br>		HostSession session = this;<br>		registrations.add (connection.register_object (ObjectPath.HOST_SESSION, session));<br><br>		AuthenticationService null_auth = new NullAuthenticationService ();<br>		registrations.add (connection.register_object (Frida.ObjectPath.AUTHENTICATION_SERVICE, null_auth));<br><br>		TransportBroker broker = this;<br>		registrations.add (connection.register_object (Frida.ObjectPath.TRANSPORT_BROKER, broker));<br>	&#125; catch (IOError e) &#123;<br>		assert_not_reached ();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该对象在构造时将会把 <code>HostSession</code> 、<code>AuthenticationService</code> 和 <code>TransportBroker</code> 都注册到 Dbus 对象中，这会使得远程的电脑端能够直接调用这些类中的方法从而实现通信。</p>
<p>而主要的负责通信的部分都由 <code>ControlChannel</code> 中的函数负责实现，常见的几个函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">public async uint <span class="hljs-title function_">spawn</span> <span class="hljs-params">(<span class="hljs-built_in">string</span> program, HostSpawnOptions options, Cancellable? cancellable)</span> throws GLib.Error &#123;<br>	<span class="hljs-keyword">return</span> yield parent.host_session.spawn (program, options, cancellable);<br>&#125;<br><br>public async <span class="hljs-type">void</span> <span class="hljs-title function_">resume</span> <span class="hljs-params">(uint pid, Cancellable? cancellable)</span> throws GLib.Error &#123;<br>	yield parent.resume (pid, this);<br>&#125;<br><br>public async AgentSessionId <span class="hljs-title function_">attach</span> <span class="hljs-params">(uint pid, HashTable&lt;<span class="hljs-built_in">string</span>, Variant&gt; options,</span><br><span class="hljs-params">		Cancellable? cancellable)</span> throws GLib.Error &#123;<br>	<span class="hljs-keyword">return</span> yield parent.attach (pid, options, this, cancellable);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，当我们使用 <code>spawn</code> 或者 <code>attach</code> 去附加或启动某个进程时，最终还是调用了 <code>host_session</code> 中的对应函数。</p>
<blockquote>
<p>这里的 parent 指的是 <code>ControlService</code> 对象</p>
</blockquote>
<p>而 <code>host_session</code> 其实是一个 <code>BaseDBusHostSession</code> 对象，该对象是平台相关的，不同平台又不同的实现方法，以 drawin 为例，我们跟一下 <code>spawn</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">		public override async uint <span class="hljs-title function_">spawn</span> <span class="hljs-params">(<span class="hljs-built_in">string</span> program, HostSpawnOptions options, Cancellable? cancellable)</span><br>				throws Error, IOError &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IOS || TVOS</span><br>			<span class="hljs-keyword">if</span> (!program.has_prefix (<span class="hljs-string">&quot;/&quot;</span>))<br>				<span class="hljs-keyword">return</span> yield fruit_controller.spawn (program, options, cancellable);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>			<span class="hljs-keyword">return</span> yield helper.spawn (program, options, cancellable);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>可以看出，实际上它只是一个封装，会向下调用 frida-helper 中的 spawn 去实现。对于 darwin 平台，helper 是一个 <code>DarwinHelperBackend</code>  ，顺带一提，<code>host_session</code> 其实是 <code>DarwinHostSession</code> 。</p>
<p>我们跟入实际的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">		public async uint <span class="hljs-title function_">spawn</span> <span class="hljs-params">(<span class="hljs-built_in">string</span> path, HostSpawnOptions options, Cancellable? cancellable)</span> throws Error, IOError &#123;<br>			<span class="hljs-keyword">if</span> (!FileUtils.test (path, EXISTS))<br>				throw new Error.EXECUTABLE_NOT_FOUND (<span class="hljs-string">&quot;Unable to find executable at &#x27;%s&#x27;&quot;</span>, path);<br><br>			StdioPipes? pipes;<br><span class="hljs-comment">//1. 启动进程</span><br>			var child_pid = _spawn (path, options, out pipes);<br><br>			ChildWatch.add ((Pid) child_pid, on_child_dead);<br><br>			<span class="hljs-keyword">if</span> (pipes != null) &#123;<br>				stdin_streams[child_pid] = new UnixOutputStream (pipes.input, <span class="hljs-literal">false</span>);<br>				process_next_output_from.begin (new UnixInputStream (pipes.output, <span class="hljs-literal">false</span>), child_pid, <span class="hljs-number">1</span>, pipes);<br>				process_next_output_from.begin (new UnixInputStream (pipes.error, <span class="hljs-literal">false</span>), child_pid, <span class="hljs-number">2</span>, pipes);<br>			&#125;<br><br>			<span class="hljs-keyword">return</span> child_pid;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>到此我们就完成启动了，对于 spawn 模式启动的进程，将在启动后挂起等待附加，接下来我们跟一下 <code>attach</code> 。该函数也是平台相关的，最终的附加部分会由 <code>perform_attach_to</code> 实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">protected override async Future&lt;IOStream&gt; <span class="hljs-title function_">perform_attach_to</span> <span class="hljs-params">(uint pid, HashTable&lt;<span class="hljs-built_in">string</span>, Variant&gt; options,</span><br><span class="hljs-params">		Cancellable? cancellable, out Object? transport)</span> throws Error, IOError &#123;<br>	transport = null;<br><br>	<span class="hljs-built_in">string</span> remote_address;<br>	var stream_future = yield helper.open_pipe_stream (pid, cancellable, out remote_address);<br><br>	var id = yield inject_agent (pid, make_agent_parameters (pid, remote_address, options), cancellable);<br>	injectee_by_pid[pid] = id;<br><br>	<span class="hljs-keyword">return</span> stream_future;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处可以看出，frida 调用 <code>inject_agent</code> 将 frida-agant 注入到进程中去。</p>
<h2 id="frida-agant"><a href="#frida-agant" class="headerlink" title="frida-agant"></a>frida-agant</h2><p>frida-agant 在大多数时候充当了 app 内部的服务端。在用户向应用传递新脚本的时候，通过 RPC 服务与 frida-agant 通信，由它来负责注入 hook 。</p>
<p>在 <code>inject_agent</code> 中注入 agant 之后，<code>entrypoint</code> 为 <code>frida_agent_main</code> ，该函数也由 vala 转换而来，其实现定义在 <code>lib/agant/agant.vala</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">namespace Frida.Agent &#123;<br>	public <span class="hljs-type">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-built_in">string</span> agent_parameters, ref Frida.UnloadPolicy unload_policy, <span class="hljs-type">void</span> * injector_state)</span> &#123;<br>		<span class="hljs-keyword">if</span> (Runner.shared_instance == null)<br>			Runner.create_and_run (agent_parameters, ref unload_policy, injector_state);<br>		<span class="hljs-keyword">else</span><br>			Runner.resume_after_transition (ref unload_policy, injector_state);<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>从 <code>create_and_run</code> 一路往下跟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">private <span class="hljs-type">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">(owned FileDescriptorTablePadder padder)</span> throws Error &#123;<br>	main_context.push_thread_default ();<br><br>	start.begin ((owned) padder);<br><br>	main_loop.run ();<br><br>	main_context.pop_thread_default ();<br><br>	<span class="hljs-keyword">if</span> (start_error != null)<br>		throw start_error;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处开始之后会先调用 <code>start.run</code> 完成各项初始化任务，然后在 <code>main_loop.run()</code> 中进入循环，直到进程退出。</p>
<p>而此处 <code>start.begin()</code> 实际上执行的是如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">		private async <span class="hljs-type">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">(owned FileDescriptorTablePadder padder)</span> &#123;<br>			<span class="hljs-built_in">string</span>[] tokens = agent_parameters.split (<span class="hljs-string">&quot;|&quot;</span>);<br>			unowned <span class="hljs-built_in">string</span> transport_uri = tokens[<span class="hljs-number">0</span>];<br>			<span class="hljs-type">bool</span> enable_exceptor = <span class="hljs-literal">true</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DARWIN</span><br>			enable_exceptor = !Gum.Darwin.query_hardened ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//此处省略</span><br><br>			&#123;<br>				var interceptor = Gum.Interceptor.obtain ();<br>				interceptor.begin_transaction ();<br><span class="hljs-comment">//此处省略</span><br><br>			try &#123;<br>				yield <span class="hljs-title function_">setup_connection_with_transport_uri</span> <span class="hljs-params">(transport_uri)</span>;<br>			&#125; catch (Error e) &#123;<br>				start_error = e;<br>				main_loop.quit ();<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			Gum.ScriptBackend.get_scheduler ().push_job_on_js_thread (Priority.DEFAULT, () =&gt; &#123;<br>				schedule_idle (start.callback);<br>			&#125;);<br>			yield;<br><br>			padder = null;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，这里分别初始化了 <code>ScriptBackend</code> 和 <code>Interceptor</code> 。并连接到启动时指定的 <code>transport_uri</code> 建立通信隧道。</p>
<h2 id="frida-helper"><a href="#frida-helper" class="headerlink" title="frida-helper"></a>frida-helper</h2><p>其实这部分已经在前面介绍过了。frida-helper 的作用其实就是用于实现包括通信、注入进程、启动进程等各项功能等模块。这里就不再赘述了。</p>
<h1 id="frida-gadget"><a href="#frida-gadget" class="headerlink" title="frida-gadget"></a>frida-gadget</h1><p>源代码来自于 <code>lib/gadget/gadget.vala</code>，这部分也是笔者一直比较关心的部分，因为它允许我们在非越狱环境下使用 frida。</p>
<p>直接跟进主要函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c">	public <span class="hljs-type">void</span> <span class="hljs-title function_">load</span> <span class="hljs-params">(Gum.MemoryRange? mapped_range, <span class="hljs-built_in">string</span>? config_data, <span class="hljs-type">int</span> * result)</span> &#123;<br>		<span class="hljs-keyword">if</span> (loaded)<br>			<span class="hljs-keyword">return</span>;<br>		loaded = <span class="hljs-literal">true</span>;<br><br>		Environment.init ();<br><br>		Gee.Promise&lt;<span class="hljs-type">int</span>&gt;? request = null;<br>		<span class="hljs-keyword">if</span> (result != null)<br>			request = new Gee.Promise&lt;<span class="hljs-type">int</span>&gt; ();<br><br>		location = detect_location (mapped_range);<br><span class="hljs-comment">//1. 解析或加载配置文件</span><br>		try &#123;<br>			config = (config_data != null)<br>				? parse_config (config_data)<br>				: load_config (location);<br>		&#125; catch (Error e) &#123;<br>			log_warning (e.message);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		Gum.Process.set_code_signing_policy (config.code_signing);<br><br>		Gum.Cloak.add_range (location.range);<br><br>		interceptor = Gum.Interceptor.obtain ();<br>		interceptor.begin_transaction ();<br>		exceptor = Gum.Exceptor.obtain ();<br><span class="hljs-comment">//2. 设定 frida 的启动方式</span><br>		try &#123;<br>			var interaction = config.interaction;<br>			<span class="hljs-keyword">if</span> (interaction is ScriptInteraction) &#123;<br>				controller = new ScriptRunner (config, location);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interaction is ScriptDirectoryInteraction) &#123;<br>				controller = new ScriptDirectoryRunner (config, location);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interaction is ListenInteraction) &#123;<br>				controller = new ControlServer (config, location);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interaction is ConnectInteraction) &#123;<br>				controller = new ClusterClient (config, location);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				throw new Error.NOT_SUPPORTED (<span class="hljs-string">&quot;Invalid interaction specified&quot;</span>);<br>			&#125;<br>		&#125; catch (Error e) &#123;<br>			resume ();<br><br>			<span class="hljs-keyword">if</span> (request != null) &#123;<br>				request.set_exception (e);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				log_warning (<span class="hljs-string">&quot;Failed to start: &quot;</span> + e.message);<br>			&#125;<br>		&#125;<br><span class="hljs-comment">//3. 启动 interceptor</span><br>		interceptor.end_transaction ();<br><br>		<span class="hljs-keyword">if</span> (controller == null)<br>			<span class="hljs-keyword">return</span>;<br><br>		wait_for_resume_needed = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//4. 确定是否需要直接恢复进程</span><br>		var listen_interaction = config.interaction as ListenInteraction;<br>		<span class="hljs-keyword">if</span> (listen_interaction != null &amp;&amp; listen_interaction.on_load == ListenInteraction.LoadBehavior.RESUME) &#123;<br>			wait_for_resume_needed = <span class="hljs-literal">false</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (!wait_for_resume_needed)<br>			resume ();<br><span class="hljs-comment">//5. 完成初始化并加载脚本进入 main_loop</span><br>		<span class="hljs-keyword">if</span> (wait_for_resume_needed &amp;&amp; Environment.can_block_at_load_time ()) &#123;<br>			var scheduler = Gum.ScriptBackend.get_scheduler ();<br><br>			scheduler.disable_background_thread ();<br><br>			wait_for_resume_context = scheduler.get_js_context ();<br><br>			var ignore_scope = new ThreadIgnoreScope (APPLICATION_THREAD);<br><br>			start (request);<br><br>			var loop = new MainLoop (wait_for_resume_context, <span class="hljs-literal">true</span>);<br>			wait_for_resume_loop = loop;<br><br>			wait_for_resume_context.push_thread_default ();<br>			loop.run ();<br>			wait_for_resume_context.pop_thread_default ();<br><br>			scheduler.enable_background_thread ();<br><br>			ignore_scope = null;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			start (request);<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (result != null) &#123;<br>			try &#123;<br>				*result = request.<span class="hljs-built_in">future</span>.wait ();<br>			&#125; catch (Gee.FutureError e) &#123;<br>				*result = <span class="hljs-number">-1</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>首先 Frida-gadget 在被加载时会自动搜索配置文件，如果找到了则根据配置文件处理。</p>
<p>随后完成一系列工作以后，在进入主循环以前会调用 <code>start</code> 加载脚本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">private <span class="hljs-type">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">(Gee.Promise&lt;<span class="hljs-type">int</span>&gt;? request)</span> &#123;<br>	var source = new IdleSource ();<br>	source.set_callback (() =&gt; &#123;<br>		perform_start.begin (request);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;);<br>	source.attach (Environment.get_worker_context ());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>perform_start</code> 中会调用 <code>controller.start ()</code> ，此时调用的函数将会根据先前用户配置文件中选择的类型完成。</p>
<p>比方说常用的 Listen 类型就会调用 <code>ControlServer</code> 下的 <code>on_start</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">		protected override async <span class="hljs-type">void</span> <span class="hljs-title function_">on_start</span> <span class="hljs-params">()</span> throws Error, IOError &#123;<br>			var interaction = (ListenInteraction) config.interaction;<br><br>			<span class="hljs-built_in">string</span>? token = interaction.token;<br>			auth_service = (token != null) ? new StaticAuthenticationService (token) : null;<br><br>			File? asset_root = null;<br>			<span class="hljs-built_in">string</span>? asset_root_path = interaction.asset_root;<br>			<span class="hljs-keyword">if</span> (asset_root_path != null)<br>				asset_root = File.new_for_path (location.resolve_asset_path (asset_root_path));<br><br>			var endpoint_params = new EndpointParameters (interaction.address, interaction.port,<br>				parse_certificate (interaction.certificate, location), interaction.origin, auth_service, asset_root);<br><span class="hljs-comment">// 1. 启动一个 WebService 与用户进行交互</span><br>			service = new WebService (endpoint_params, CONTROL, interaction.on_port_conflict);<br>			service.incoming.connect (on_incoming_connection);<br>			yield service.start (io_cancellable);<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>然后该服务就会监听特定地址了，如果用户传递了文件或代码等，则会与 frida-agant 通过 IPC 服务通信，由对方去负责具体的 hook 行为。</p>
<p>又比如指定一个脚本令其自动运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">public async <span class="hljs-type">void</span> <span class="hljs-title function_">start</span> <span class="hljs-params">()</span> throws Error, IOError &#123;<br>	save_terminal_config ();<br><br>	yield <span class="hljs-title function_">load</span> <span class="hljs-params">()</span>;<br><br>	<span class="hljs-keyword">if</span> (enable_development &amp;&amp; script_path != null) &#123;<br>		try &#123;<br>			script_monitor = File.new_for_path (script_path).monitor_file (FileMonitorFlags.NONE);<br>			script_monitor.changed.connect (on_script_file_changed);<br>		&#125; catch (GLib.Error e) &#123;<br>			printerr (e.message + <span class="hljs-string">&quot;\n&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处会调用 <code>load</code> 完成加载和启动的操作，我们跟入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">		private async <span class="hljs-type">void</span> <span class="hljs-title function_">load</span> <span class="hljs-params">()</span> throws Error, IOError &#123;<br>			load_in_progress = <span class="hljs-literal">true</span>;<br><br>			try &#123;<br>				<span class="hljs-built_in">string</span> source;<br><br>				var options = new ScriptOptions ();<br><span class="hljs-comment">//1. 读取脚本内容</span><br>				<span class="hljs-keyword">if</span> (script_path != null) &#123;<br>					try &#123;<br>						FileUtils.get_contents (script_path, out source);<br>					&#125; catch (FileError e) &#123;<br>						throw new Error.INVALID_ARGUMENT (<span class="hljs-string">&quot;%s&quot;</span>, e.message);<br>					&#125;<br><span class="hljs-comment">//2. 读取脚本路径</span><br>					options.name = Path.get_basename (script_path).split (<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">2</span>)[<span class="hljs-number">0</span>];<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					source = script_source;<br><br>					options.name = <span class="hljs-string">&quot;frida&quot;</span>;<br>				&#125;<br><br>				options.runtime = script_runtime;<br><span class="hljs-comment">//3. 创建脚本</span><br>				var s = yield session.create_script (source, options, io_cancellable);<br><br>				<span class="hljs-keyword">if</span> (script != null) &#123;<br>					yield script.unload (io_cancellable);<br>					script = null;<br>				&#125;<br>				script = s;<br><span class="hljs-comment">//4. 加载脚本到进程</span><br>				script.message.connect (on_message);<br>				yield script.load (io_cancellable);<br><span class="hljs-comment">//5. 启动目标进程</span><br>				yield <span class="hljs-title function_">call_init</span> <span class="hljs-params">()</span>;<br><br>				terminal_mode = yield query_terminal_mode ();<br>				apply_terminal_mode (terminal_mode);<br><br>				<span class="hljs-keyword">if</span> (eternalize)<br>					yield script.eternalize (io_cancellable);<br>			&#125; finally &#123;<br>				load_in_progress = <span class="hljs-literal">false</span>;<br>			&#125;<br>		&#125;<br></code></pre></td></tr></table></figure>

<p>其中的 <code>call_init</code> 负责通过 rpc 服务去调用 <code>init</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">private async <span class="hljs-type">void</span> <span class="hljs-title function_">call_init</span> <span class="hljs-params">()</span> &#123;<br>	var stage = new Json.Node.alloc ().init_string (<span class="hljs-string">&quot;early&quot;</span>);<br><br>	try &#123;<br>		yield rpc_client.call (<span class="hljs-string">&quot;init&quot;</span>, new Json.Node[] &#123; stage, parameters &#125;, io_cancellable);<br>	&#125; catch (GLib.Error e) &#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在完成以上操作后，frida 会进入 <code>main_loop</code>，而被启动的应用会等待被 resume。</p>
<p>然后是 <code>perform_start</code> 的后半：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">	private async <span class="hljs-type">void</span> <span class="hljs-title function_">perform_start</span> <span class="hljs-params">(Gee.Promise&lt;<span class="hljs-type">int</span>&gt;? request)</span> &#123;<br>		worker_ignore_scope = new ThreadIgnoreScope (FRIDA_THREAD);<br><br>		try &#123;<br>			yield controller.start ();<br><br>			var server = controller as ControlServer;<br>			<span class="hljs-keyword">if</span> (server != null) &#123;<br><span class="hljs-comment">//1. 如果 controller 是一个服务端的话，那么就需要监听网络地址来和用户进行交互</span><br><span class="hljs-comment">//比如常用的 Listen 模式就需要监听特定地址端口</span><br>				var listen_address = server.listen_address;<br>				var inet_address = listen_address as InetSocketAddress;<br>				<span class="hljs-keyword">if</span> (inet_address != null) &#123;<br>					uint16 listen_port = inet_address.get_port ();<br>					Environment.set_thread_name (<span class="hljs-string">&quot;frida-gadget-tcp-%u&quot;</span>.<span class="hljs-built_in">printf</span> (listen_port));<br>					<span class="hljs-keyword">if</span> (request != null) &#123;<br>						request.set_value (listen_port);<br>					&#125; <span class="hljs-keyword">else</span> &#123;<br>						log_info (<span class="hljs-string">&quot;Listening on %s TCP port %u&quot;</span>.<span class="hljs-built_in">printf</span> (<br>							inet_address.get_address ().to_string (),<br>							listen_port));<br>					&#125;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !WINDOWS</span><br><span class="hljs-comment">//2. 对于不是 windows 的系统，这里使用的是 frida-gadget-unix，这里监听 unix socket</span><br><span class="hljs-comment">//主要是负责 IPC 服务用的</span><br>					var unix_address = (UnixSocketAddress) listen_address;<br>					Environment.set_thread_name (<span class="hljs-string">&quot;frida-gadget-unix&quot;</span>);<br>					<span class="hljs-keyword">if</span> (request != null) &#123;<br>						request.set_value (<span class="hljs-number">0</span>);<br>					&#125; <span class="hljs-keyword">else</span> &#123;<br>						log_info (<span class="hljs-string">&quot;Listening on UNIX socket at “%s”&quot;</span>.<span class="hljs-built_in">printf</span> (unix_address.get_path ()));<br>					&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>					assert_not_reached ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">if</span> (request != null)<br>					request.set_value (<span class="hljs-number">0</span>);<br>			&#125;<br>		&#125; catch (GLib.Error e) &#123;<br>			resume ();<br><br>			<span class="hljs-keyword">if</span> (request != null) &#123;<br>				request.set_exception (e);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				log_warning (<span class="hljs-string">&quot;Failed to start: &quot;</span> + e.message);<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>由于该函数是以回调函数的形式被注册的，因此附加的进程在每次触发请求的时候都会重新调用该函数处理。</p>
<p>然后我们再看看使用这种方式的情况下是如何附加进程和启动进程的。</p>
<p>在前文中曾说过，通过 IPC 的方式，主机端能够直接调用类中的方法，其中一个比较关键的类是 <code>ControlChannel</code> ，它负责了几个关键行为的设定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">public async uint <span class="hljs-title function_">spawn</span> <span class="hljs-params">(<span class="hljs-built_in">string</span> program, HostSpawnOptions options, Cancellable? cancellable)</span> throws Error, IOError &#123;<br>	<span class="hljs-keyword">if</span> (program != this_app.identifier)<br>		throw new Error.NOT_SUPPORTED (<span class="hljs-string">&quot;Unable to spawn other apps when embedded&quot;</span>);<br><br>	resume_on_attach = <span class="hljs-literal">false</span>;<br><br>	<span class="hljs-keyword">return</span> this_process.pid;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 <code>spawn</code> 方式的启动，由于所有模块都被打包在同一个进程中，因此当前进程就是将要附加的进程，因此 <code>spawn</code> 可以直接返回当前进程的 pid。</p>
<p>attach 倒是没太大变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">public async AgentSessionId <span class="hljs-title function_">attach</span> <span class="hljs-params">(uint pid, HashTable&lt;<span class="hljs-built_in">string</span>, Variant&gt; options,</span><br><span class="hljs-params">		Cancellable? cancellable)</span> throws Error, IOError &#123;<br>	validate_pid (pid);<br><br>	<span class="hljs-keyword">if</span> (resume_on_attach)<br>		Frida.Gadget.resume ();<br><br>	<span class="hljs-keyword">return</span> yield parent.attach (options, this, cancellable);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它仍然调用 <code>parent.attach</code> 去附加。</p>
<p>总结一下就是：</p>
<ul>
<li>frida-gadget 被注入以后会在加载该库的时候调用 <code>load</code> 方法</li>
<li>该方法根据用户提供的配置文件选择接下来的行为</li>
<li>对于 Listen 则是监听地址端口并触发回调完成交互</li>
<li>如果用户在配置中指定来 resume，那么此前会先调用 <code>resume</code> 恢复进程</li>
<li>对于 Script 则是读取给定路径下的脚本解析并加载</li>
<li>如果需要监听文件变化时候动态修改 hook ，那么还需要额外操作</li>
</ul>
<h1 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a>launchd</h1><p>上文大致介绍完了 frida 的大体逻辑，但是还有一个细节上的小问题没有解决。具体来说就是，“frida 到底是怎么通过 spawn 启动的进程？”</p>
<p>实际上，frida 除了对进程本身进行注入以外，还会对 launchd 进行注入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">getExportByName</span>(<span class="hljs-string">&#x27;/usr/lib/system/libsystem_kernel.dylib&#x27;</span>, <span class="hljs-string">&#x27;__posix_spawn&#x27;</span>), &#123;<br>  <span class="hljs-title function_">onEnter</span>(<span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-keyword">const</span> env = <span class="hljs-title function_">parseStringv</span>(args[<span class="hljs-number">4</span>]);<br>    <span class="hljs-keyword">const</span> prewarm = <span class="hljs-title function_">isPrewarmLaunch</span>(env);<br><br>    <span class="hljs-keyword">if</span> (prewarm &amp;&amp; !gating)<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">const</span> path = args[<span class="hljs-number">1</span>].<span class="hljs-title function_">readUtf8String</span>();<br><br>    <span class="hljs-keyword">let</span> rawIdentifier;<br>    <span class="hljs-keyword">if</span> (path === <span class="hljs-string">&#x27;/usr/libexec/xpcproxy&#x27;</span>) &#123;<br>      rawIdentifier = args[<span class="hljs-number">3</span>].<span class="hljs-title function_">add</span>(pointerSize).<span class="hljs-title function_">readPointer</span>().<span class="hljs-title function_">readUtf8String</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rawIdentifier = <span class="hljs-title function_">tryParseXpcServiceName</span>(env);<br>      <span class="hljs-keyword">if</span> (rawIdentifier === <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> identifier, event;<br>    <span class="hljs-keyword">if</span> (rawIdentifier.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;UIKitApplication:&#x27;</span>)) &#123;<br>      identifier = rawIdentifier.<span class="hljs-title function_">substring</span>(<span class="hljs-number">17</span>, rawIdentifier.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;[&#x27;</span>));<br>      <span class="hljs-keyword">if</span> (!prewarm &amp;&amp; upcoming.<span class="hljs-title function_">has</span>(identifier))<br>        event = <span class="hljs-string">&#x27;launch:app&#x27;</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gating)<br>        event = <span class="hljs-string">&#x27;spawn&#x27;</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gating || (reportCrashes &amp;&amp; crashServices.<span class="hljs-title function_">has</span>(rawIdentifier))) &#123;<br>      identifier = rawIdentifier;<br>      event = <span class="hljs-string">&#x27;spawn&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> attrs = args[<span class="hljs-number">2</span>].<span class="hljs-title function_">add</span>(pointerSize).<span class="hljs-title function_">readPointer</span>();<br><br>    <span class="hljs-keyword">let</span> flags = attrs.<span class="hljs-title function_">readU16</span>();<br>    flags |= <span class="hljs-variable constant_">POSIX_SPAWN_START_SUSPENDED</span>;<br>    attrs.<span class="hljs-title function_">writeU16</span>(flags);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">event</span> = event;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span> = path;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">identifier</span> = identifier;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pidPtr</span> = args[<span class="hljs-number">0</span>];<br>  &#125;,<br>  <span class="hljs-title function_">onLeave</span>(<span class="hljs-params">retval</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; event &#125; = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">if</span> (event === <span class="hljs-literal">undefined</span>)<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">const</span> &#123; path, identifier, pidPtr, threadId &#125; = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">if</span> (event === <span class="hljs-string">&#x27;launch:app&#x27;</span>)<br>      upcoming.<span class="hljs-title function_">delete</span>(identifier);<br><br>    <span class="hljs-keyword">if</span> (retval.<span class="hljs-title function_">toInt32</span>() &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">const</span> pid = pidPtr.<span class="hljs-title function_">readU32</span>();<br><br>    suspendedPids.<span class="hljs-title function_">add</span>(pid);<br><br>    <span class="hljs-keyword">if</span> (pidsToIgnore !== <span class="hljs-literal">null</span>)<br>      pidsToIgnore.<span class="hljs-title function_">add</span>(pid);<br><br>    <span class="hljs-keyword">if</span> (substrateInvocations.<span class="hljs-title function_">has</span>(threadId)) &#123;<br>      substratePidsPending.<span class="hljs-title function_">set</span>(pid, notifyFridaBackend);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">notifyFridaBackend</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">notifyFridaBackend</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">send</span>([event, path, identifier, pid]);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这个地方直接把 <code>__posix_spawn</code> 给 hook 掉了，并且加上了 <code>POSIX_SPAWN_START_SUSPENDED</code> 的 flag，该标记能够让进程在启动后被挂起。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各个组件的功能如下：</p>
<ul>
<li>frida-server &#x2F; 一个服务端。负责在设备上与本机通讯</li>
<li>frida-agant &#x2F; 被注入到进程中去的动态库，通常由 frida-server 释放注入，负责编译脚本注入进程</li>
<li>frida-helper &#x2F; 负责具体的进程注入、启动进程等功能</li>
<li>frida-gadgat &#x2F; frida-server+frida-agant+frida-helper ，将三者的功能全都集成在一个动态库中，由用户手动注入到应用中</li>
</ul>
<p>这里引出一个小问题，对于被注入 Frida-gadget 的 app 来说，如果我不使用 frida 去启动它，而是通过点击图标的方式原生启动应用，那么应用还能正常启动吗？</p>
<p>如果仅凭上文的分析，主机端通过 IPC 通信去调用设备上对应的函数从而启动了应用，但是原生启动是不通过 IPC 的，这种情况下，frida-gadget 要如何工作呢？它还会正常去启动应用吗？</p>
<p>问了一些师傅，他们表示 Android 平台下，即便注入的 frida-gadget 也是可以正常点击打开的，但是笔者在 iOS16 上测试发现这将导致闪退，但是诡异的是，我能够用 <code>frida -U -f bundleid</code> 正常打开应用。<br>而在 iOS14 上，笔者发现应用将会停在启动页面无法继续执行，并且 frida 也没办法附加，以及 <code>frida -U -f bundleid</code> 也无法正常启动了，唯独 Xcode 启动时，一切正常，这十分的诡异。</p>
<p>以上问题目前笔者还不清楚原因，欢迎师傅们讨论。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/09/21/%E6%88%91%E4%BB%AC%E5%AF%B9%20PWN%20%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%AF%E4%BC%9A/">← Next 我们对 PWN 都有哪些误会</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/08/28/Frida-gum-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E8%AF%BB/">Frida-gum 源代码分析解读 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">本文内容目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Frida-Core"><span class="toc-number">3.</span> <span class="toc-text">Frida-Core</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">进程注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frida-server"><span class="toc-number">3.2.</span> <span class="toc-text">frida-server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frida-agant"><span class="toc-number">3.3.</span> <span class="toc-text">frida-agant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frida-helper"><span class="toc-number">3.4.</span> <span class="toc-text">frida-helper</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#frida-gadget"><span class="toc-number">4.</span> <span class="toc-text">frida-gadget</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#launchd"><span class="toc-number">5.</span> <span class="toc-text">launchd</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>