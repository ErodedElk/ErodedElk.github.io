<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>《操作系统真象还原》chapter14/文件系统与遗憾 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>《操作系统真象还原》chapter14/文件系统与遗憾</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-03-06T05:43:28.000Z" id="date"> 2022-03-06</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:35.014Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本章没能看完，有些可惜。主要是因为寒假结束，没有那种能够安静看书的时间了，所以最后两章我的阅读效率下降的很快；另外还是因为本书已经快要看完了，心态有点浮躁，实在不适合继续看下去了，于是本章笔记只对本章前半部分做了相对详细的笔记，但后半部分笔者没能读下去，所以肯定是不足的。</p>
<p>以后若有时间的话，希望能把这本书完整读完吧。</p>
<h3 id="勘误"><a href="#勘误" class="headerlink" title="勘误"></a>勘误</h3><p>本书P600页存在一个表述错误，特此摘出：</p>
<blockquote>
<p>“它被固定储存在各分区的第2个扇区，通常在占用一个扇区的大小。”</p>
</blockquote>
<p>此处“它”是指超级块。</p>
<p>该表述不够严谨，在上一章中我们曾留意到：</p>
<ul>
<li>对于主分区，其开始的第一个磁道会被OBR占用，而OBR的大小不一定只占用一个扇区。在EXT4文件系统中，该OBR会占用两个扇区，所以该文件系统中的超级块存在于1024偏移处，也就是从第三个扇区开始</li>
<li>对于总拓展分区，每个子拓展分区的开始是EBR，EBR和MBR是同构的。子拓展分区里的每个逻辑分区就相当于主分区，它们也都在相似的地方存在OBR，在EXT4文件系统中，超级块也都在1024偏移处</li>
</ul>
<p>综上，超级块的具体位置应该是和文件组织结构本身有关的，EXT4和FAT32等等各不相同的结构有各不相同的结果，本书在这方面没有表述清楚(注：从EXT2开始，引导块就占两个扇区1Kb大小了，至于FAT32是不是这样，笔者并没有查过)。</p>
<p>不过本书的实现中，接下来会默认引导块只占用一个扇区，超级块从第二个扇区开始。</p>
<p><a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch29s02.html">https://akaedu.github.io/book/ch29s02.html</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本章虽然实现了一个简易的文件系统，不过它并没有实用性，只能用作理解掌握文件系统根本原理。最终完成格式化的硬盘并没有泛用性，属于是专属于该操作系统的硬盘了(当然，我没有说这样做不好，倒不如说这样做帮大忙了。所以只是提个醒，不要以本章实现的文件系统为准，只需要理解其原理即可)。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>总结一下文件系统的几个要点吧：</p>
<ul>
<li>操作系统为整个文件系统提供了inode结构体，每个文件对应一个inode。该结构体标识了文件属性和文件数据指针等内容。</li>
<li>操作系统为所有文件维护了一个inode数组，访问文件的具体数据通过inode编号的下表直接寻址</li>
<li>同时，对于任何一个文件，操作系统为其确定固定的结构体条目，该结构体中包含了文件名、文件大小、文件类型、inode编号等</li>
<li>对于“目录文件”类型，这类文件的inode文件的数据指针处存放的是目录下其他文件的文件结构条目</li>
<li>所有的文件都会被挂载在根目录下</li>
</ul>
<p>然后是操作系统的文件访问逻辑：假定目前文件系统已经完全初始化完成了</p>
<ul>
<li>首先由用户提供文件名</li>
<li>操作系统根据该文件从根目录开始递归查询</li>
<li>首先会访问根目录的数据区，该数据区存放了根目录下其他文件的结构条目，对比每个条目中的文件名和请求文件名</li>
<li>若存在该文件，那么直接从条目中获取inode编号，通过inode编号得到文件对于数据区的指针</li>
<li>若不存在该文件，则通过该目录下其他“目录类型”的文件继续递归查找，直到全目录搜索完毕或找到同名文件为止</li>
</ul>
<p>当然，上面描述的寻址有些简单粗暴，因为我们一般都会界定寻址的范围和开始的目录，很少从根目录就开始查询。并且，一般的系统都支持在不同的目录下运行同名文件出现，并且我们往往只在一层目录中寻找文件。</p>
<p>不过概念上有些不同的是，现在我们通常描述的“文件名”其实是包括了父目录以后的文件名，比如“C:&#x2F;file.txt”；而本书中所说的文件名就是单独所指的文件名，比如“file.txt”。前者属于更高级一点的概念，还是要做一点区分的。</p>
<p>上述的两个结构体如下：有一定删减</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//文件结构条目(有删减)<br>struct dir_entry &#123;<br>   char filename[MAX_FILE_NAME_LEN];  // 普通文件或目录名称<br>   uint32_t i_no;              // 普通文件或目录对应的inode编号<br>   enum file_types f_type;          // 文件类型<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* inode结构 */<br>struct inode &#123;<br>   uint32_t i_no;    // inode编号<br>/* 当此inode是文件时,i_size是指文件大小,若此inode是目录,i_size是指该目录下所有目录项大小之和*/<br>   uint32_t i_size;<br>   uint32_t i_open_cnts;   // 记录此文件被打开的次数<br>   bool write_deny;       // 写文件不能并行,进程写文件前检查此标识<br>/* i_sectors[0-11]是直接块, i_sectors[12]用来存储一级间接块指针 */<br>   uint32_t i_sectors[13];<br>   struct list_elem inode_tag;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中，i_sectors指针是针对文件较大需要分散存放的文件设计的。硬盘的储存单位是“块”，对于一个块存放不下的文件，会指定其他块进行存放，为了寻址其他块，在inode结构体中通过一系列数组来记录每个块的指针。</p>
<p>然后就是构建文件系统了。格式化硬盘的函数就在本段下面，不过在看之前还是先听笔者唠叨几句吧。</p>
<p>一般来讲，我们现在装Linux都是先把硬盘(当然一般是U盘)格式化以后，写入操作系统镜像的。这个格式化其实就是在为硬盘创建文件系统。本书也说明了，现代的操作系统一般是先格式化硬盘，然后再初始化操作系统自己的，所以笔者认为，本来的话，文件系统是不需要操作系统的范畴的，因为操作系统不负责文件系统的构建，那是在制作启动盘的时候就完成的事情。</p>
<p>本章的作者是自己去创建文件系统，而不是通过工具生成一块具有泛用性的磁盘文件，而是自己去仿造了一个类似的文件系统。虽然略感可惜，但对于笔者这样的初学者来说确实是帮大忙了。唠叨就到这里，下面是格式化函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 格式化分区,也就是初始化分区的元信息,创建文件系统 */<br>static void partition_format(struct partition* part) &#123;<br>/* 为方便实现,一个块大小是一扇区 */<br>   uint32_t boot_sector_sects = 1;      <br>   uint32_t super_block_sects = 1;<br>   uint32_t inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);       // I结点位图占用的扇区数.最多支持4096个文件<br>   uint32_t inode_table_sects = DIV_ROUND_UP(((sizeof(struct inode) * MAX_FILES_PER_PART)), SECTOR_SIZE);<br>   uint32_t used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;<br>   uint32_t free_sects = part-&gt;sec_cnt - used_sects;  <br><br>/************** 简单处理块位图占据的扇区数 ***************/<br>   uint32_t block_bitmap_sects;<br>   block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);<br>   /* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */<br>   uint32_t block_bitmap_bit_len = free_sects - block_bitmap_sects; <br>   block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); <br>/*********************************************************/<br><br>   /* 超级块初始化 */<br>   struct super_block sb;<br>   sb.magic = 0x19590318;<br>   sb.sec_cnt = part-&gt;sec_cnt;<br>   sb.inode_cnt = MAX_FILES_PER_PART;<br>   sb.part_lba_base = part-&gt;start_lba;<br><br>   sb.block_bitmap_lba = sb.part_lba_base + 2;     // 第0块是引导块,第1块是超级块<br>   sb.block_bitmap_sects = block_bitmap_sects;<br><br>   sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;<br>   sb.inode_bitmap_sects = inode_bitmap_sects;<br><br>   sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;<br>   sb.inode_table_sects = inode_table_sects; <br><br>   sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;<br>   sb.root_inode_no = 0;<br>   sb.dir_entry_size = sizeof(struct dir_entry);<br><br>   printk(&quot;%s info:\n&quot;, part-&gt;name);<br>   printk(&quot;   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n&quot;, sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);<br><br>   struct disk* hd = part-&gt;my_disk;<br>/*******************************<br> * 1 将超级块写入本分区的1扇区 *<br> ******************************/<br>   ide_write(hd, part-&gt;start_lba + 1, &amp;sb, 1);<br>   printk(&quot;   super_block_lba:0x%x\n&quot;, part-&gt;start_lba + 1);<br><br>/* 找出数据量最大的元信息,用其尺寸做存储缓冲区*/<br>   uint32_t buf_size = (sb.block_bitmap_sects &gt;= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);<br>   buf_size = (buf_size &gt;= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;<br>   uint8_t* buf = (uint8_t*)sys_malloc(buf_size);    // 申请的内存由内存管理系统清0后返回<br><br>/**************************************<br> * 2 将块位图初始化并写入sb.block_bitmap_lba *<br> *************************************/<br>   /* 初始化块位图block_bitmap */<br>   buf[0] = 0x01;       // 第0个块预留给根目录,位图中先占位<br>   uint32_t block_bitmap_last_byte = block_bitmap_bit_len / 8;<br>   uint8_t  block_bitmap_last_bit  = block_bitmap_bit_len % 8;<br>   uint32_t last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);         // last_size是位图所在最后一个扇区中，不足一扇区的其余部分<br><br>   /* 1 先将位图最后一字节到其所在的扇区的结束全置为1,即超出实际块数的部分直接置为已占用*/<br>   memset(&amp;buf[block_bitmap_last_byte], 0xff, last_size);<br><br>   /* 2 再将上一步中覆盖的最后一字节内的有效位重新置0 */<br>   uint8_t bit_idx = 0;<br>   while (bit_idx &lt;= block_bitmap_last_bit) &#123;<br>      buf[block_bitmap_last_byte] &amp;= ~(1 &lt;&lt; bit_idx++);<br>   &#125;<br>   ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);<br><br>/***************************************<br> * 3 将inode位图初始化并写入sb.inode_bitmap_lba *<br> ***************************************/<br>   /* 先清空缓冲区*/<br>   memset(buf, 0, buf_size);<br>   buf[0] = 0x1;      // 第0个inode分给了根目录<br>   /* 由于inode_table中共4096个inode,位图inode_bitmap正好占用1扇区,<br>    * 即inode_bitmap_sects等于1, 所以位图中的位全都代表inode_table中的inode,<br>    * 无须再像block_bitmap那样单独处理最后一扇区的剩余部分,<br>    * inode_bitmap所在的扇区中没有多余的无效位 */<br>   ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);<br><br>/***************************************<br> * 4 将inode数组初始化并写入sb.inode_table_lba *<br> ***************************************/<br> /* 准备写inode_table中的第0项,即根目录所在的inode */<br>   memset(buf, 0, buf_size);  // 先清空缓冲区buf<br>   struct inode* i = (struct inode*)buf; <br>   i-&gt;i_size = sb.dir_entry_size * 2;     // .和..<br>   i-&gt;i_no = 0;   // 根目录占inode数组中第0个inode<br>   i-&gt;i_sectors[0] = sb.data_start_lba;         // 由于上面的memset,i_sectors数组的其它元素都初始化为0 <br>   ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);<br><br>/***************************************<br> * 5 将根目录初始化并写入sb.data_start_lba<br> ***************************************/<br>   /* 写入根目录的两个目录项.和.. */<br>   memset(buf, 0, buf_size);<br>   struct dir_entry* p_de = (struct dir_entry*)buf;<br><br>   /* 初始化当前目录&quot;.&quot; */<br>   memcpy(p_de-&gt;filename, &quot;.&quot;, 1);<br>   p_de-&gt;i_no = 0;<br>   p_de-&gt;f_type = FT_DIRECTORY;<br>   p_de++;<br><br>   /* 初始化当前目录父目录&quot;..&quot; */<br>   memcpy(p_de-&gt;filename, &quot;..&quot;, 2);<br>   p_de-&gt;i_no = 0;   // 根目录的父目录依然是根目录自己<br>   p_de-&gt;f_type = FT_DIRECTORY;<br><br>   /* sb.data_start_lba已经分配给了根目录,里面是根目录的目录项 */<br>   ide_write(hd, sb.data_start_lba, buf, 1);<br><br>   printk(&quot;   root_dir_lba:0x%x\n&quot;, sb.data_start_lba);<br>   printk(&quot;%s format done\n&quot;, part-&gt;name);<br>   sys_free(buf);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>磁盘内容分布如下：</p>
<p class='item-img' data-src='https://www.linuxidc.com/upload/2019_08/190804190297241.png'><img src="https://www.linuxidc.com/upload/2019_08/190804190297241.png"></p>
<p>第一扇区中存在一个Boot Block，也就是EBR或者MBR，然后紧跟着的是占用一个扇区的超级块，其结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* 超级块 */<br>struct super_block &#123;<br>   uint32_t magic;            // 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型<br>   uint32_t sec_cnt;            // 本分区总共的扇区数<br>   uint32_t inode_cnt;            // 本分区中inode数量<br>   uint32_t part_lba_base;        // 本分区的起始lba地址<br>   uint32_t block_bitmap_lba;        // 块位图本身起始扇区地址<br>   uint32_t block_bitmap_sects;     // 扇区位图本身占用的扇区数量<br>   uint32_t inode_bitmap_lba;        // i结点位图起始扇区lba地址<br>   uint32_t inode_bitmap_sects;        // i结点位图占用的扇区数量<br>   uint32_t inode_table_lba;        // i结点表起始扇区lba地址<br>   uint32_t inode_table_sects;        // i结点表占用的扇区数量<br>   uint32_t data_start_lba;        // 数据区开始的第一个扇区号<br>   uint32_t root_inode_no;        // 根目录所在的I结点号<br>   uint32_t dir_entry_size;        // 目录项大小<br>   uint8_t  pad[460];            // 加上460字节,凑够512字节1扇区大小<br>&#125; __attribute__ ((packed));<br>#endif<br></code></pre></td></tr></table></figure>

<p>该超级块中表明了分区的扇区数、inode数、根目录位置等信息。通过magic来确定文件系统类型或判断是否存在文件系统。</p>
<p>在ide通道初始化完成以后，操作系统就已经获得了有关磁盘和分区的主要信息。但分区并没有建立文件系统。</p>
<p>filesys_init函数负责从ide通道中获取每个分区，然后通过partition_format函数初始化每个分区。</p>
<p>partition_format函数首先初始化超级块，然后是块位图以及inode位图，再之后初始化inode数组和根目录。</p>
<ul>
<li>这里插入一点关于rootfs的内容。其实现在所实现的根目录就是一个简化版的rootfs。</li>
<li>真正的rootfs在内核开启时第一个被挂载，由它提供根目录‘&#x2F;’，并从该目录下会加载出一些初始化脚本和服务到内存，init进程也运行在根目录文件系统上。</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1791275">https://cloud.tencent.com/developer/article/1791275</a></li>
</ul>
<hr>
<p>插画ID：1134778859747008514(tw)</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/03/17/d3ctf-pwn/">← Next D3CTF-PWN复现报告</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/02/25/tqlctf-re-pwn/">TQLCTF-RE/PWN复现报告 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8B%98%E8%AF%AF"><span class="toc-number">1.1.</span> <span class="toc-text">勘误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">文件系统</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>