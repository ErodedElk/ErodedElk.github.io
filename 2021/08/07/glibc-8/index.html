<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅷ——从源代码理解malloc) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅷ——从源代码理解malloc)</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2021-08-07T12:27:05.000Z" id="date"> 2021-08-07</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.996Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p> 本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源(也有置于篇首的情况)。</p>
<p>        关于glibc堆管理器Ptmalloc2的实际讨论在前几节已经大致结束了，但是笔者仍觉得对其分配机制缺少完整的认识，于是最后两节将直接通过源代码来对其分配和释放规则进行分析</p>
<p>        尽管笔者所用的Ubuntu18.04使用glibc-2.27，但笔者在对照源代码后发现，实际的操作和官方放出的glibc2.29更加接近，因此笔者将引用2.29版本中的源代码进行分析</p>
<p>        为了文章的可读性，笔者将使用“块引用”来表示分支情况，在没有特别标注的情况下(没有说明引用来源时)，其中内容均为笔者所写</p>
<h1 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void *<br>__libc_malloc (size_t bytes)<br>&#123;<br>  mstate ar_ptr;<br>  void *victim;<br><br>  void *(*hook) (size_t, const void *)<br>    = atomic_forced_read (__malloc_hook);<br>  if (__builtin_expect (hook != NULL, 0))<br>    return (*hook)(bytes, RETURN_ADDRESS (0));<br>#if USE_TCACHE<br>  /* int_free also calls request2size, be careful to not pad twice.  */<br>  size_t tbytes;<br>  checked_request2size (bytes, tbytes);<br>  size_t tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  if (tc_idx &lt; mp_.tcache_bins<br>      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */<br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL)<br>    &#123;<br>      return tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br>#endif<br><br>  if (SINGLE_THREAD_P)<br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim  chunk_is_mmapped (mem2chunk (victim)) <br>      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      return victim;<br>    &#125;<br><br>  arena_get (ar_ptr, bytes);<br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  /* Retry with another arena only if we were able to find a usable arena<br>     before.  */<br>  if (!victim &amp;&amp; ar_ptr != NULL)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, 1, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  if (ar_ptr != NULL)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  assert (!victim  chunk_is_mmapped (mem2chunk (victim)) <br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  return victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e9fbe673-a816-4a37-a409-fd70f577b51a'><img src="blob:https://tokameine.top/e9fbe673-a816-4a37-a409-fd70f577b51a"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void *<br>_int_malloc (mstate av, size_t bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               /* normalized request size */<br>  unsigned int idx;                 /* associated bin index */<br>  mbinptr bin;                      /* associated bin */<br><br>  mchunkptr victim;                 /* inspected/selected chunk */<br>  INTERNAL_SIZE_T size;             /* its size */<br>  int victim_index;                 /* its bin index */<br><br>  mchunkptr remainder;              /* remainder from a split */<br>  unsigned long remainder_size;     /* its size */<br><br>  unsigned int block;               /* bit map traverser */<br>  unsigned int bit;                 /* bit map traverser */<br>  unsigned int map;                 /* current word of binmap */<br><br>  mchunkptr fwd;                    /* misc temp for linking */<br>  mchunkptr bck;                    /* misc temp for linking */<br><br>#if USE_TCACHE<br>  size_t tcache_unsorted_count;    /* count of unsorted chunks processed */<br>#endif<br><br>  /*<br>     Convert request size to internal form by adding SIZE_SZ bytes<br>     overhead plus possibly more to obtain necessary alignment and/or<br>     to obtain a size of at least MINSIZE, the smallest allocatable<br>     size. Also, checked_request2size traps (returning 0) request sizes<br>     that are so large that they wrap around zero when padded and<br>     aligned.<br>   */<br><br>  checked_request2size (bytes, nb);<br><br>  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from<br>     mmap.  */<br>  if (__glibc_unlikely (av == NULL))<br>    &#123;<br>      void *p = sysmalloc (nb, av);<br>      if (p != NULL)<br>alloc_perturb (p, bytes);<br>      return p;<br>    &#125;<br><br>  /*<br>     If the size qualifies as a fastbin, first check corresponding bin.<br>     This code is safe to execute even if av is not yet initialized, so we<br>     can try it without checking, which saves some time on this fast path.<br>   */<br><br>#define REMOVE_FB(fb, victim, pp)\<br>  do\<br>    &#123;\<br>      victim = pp;\<br>      if (victim == NULL)\<br>break;\<br>    &#125;\<br>  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \<br> != victim);\<br><br>  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br><br>      if (victim != NULL)<br>&#123;<br>  if (SINGLE_THREAD_P)<br>    *fb = victim-&gt;fd;<br>  else<br>    REMOVE_FB (fb, pp, victim);<br>  if (__glibc_likely (victim != NULL))<br>    &#123;<br>      size_t victim_idx = fastbin_index (chunksize (victim));<br>      if (__builtin_expect (victim_idx != idx, 0))<br>malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);<br>      check_remalloced_chunk (av, victim, nb);<br>#if USE_TCACHE<br>      /* While we&#x27;re here, if we see other chunks of the same size,<br> stash them in the tcache.  */<br>      size_t tc_idx = csize2tidx (nb);<br>      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>&#123;<br>  mchunkptr tc_victim;<br><br>  /* While bin not empty and tcache not full, copy chunks.  */<br>  while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br> &amp;&amp; (tc_victim = *fb) != NULL)<br>    &#123;<br>      if (SINGLE_THREAD_P)<br>*fb = tc_victim-&gt;fd;<br>      else<br>&#123;<br>  REMOVE_FB (fb, pp, tc_victim);<br>  if (__glibc_unlikely (tc_victim == NULL))<br>    break;<br>&#125;<br>      tcache_put (tc_victim, tc_idx);<br>    &#125;<br>&#125;<br>#endif<br>      void *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      return p;<br>    &#125;<br>&#125;<br>    &#125;<br><br>  /*<br>     If a small request, check regular bin.  Since these &quot;smallbins&quot;<br>     hold one size each, no searching within bins is necessary.<br>     (For a large request, we need to wait until unsorted chunks are<br>     processed to find best fit. But for small ones, fits are exact<br>     anyway, so we can check now, which is faster.)<br>   */<br><br>  if (in_smallbin_range (nb))<br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      if ((victim = last (bin)) != bin)<br>        &#123;<br>          bck = victim-&gt;bk;<br>  if (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);<br>          set_inuse_bit_at_offset (victim, nb);<br>          bin-&gt;bk = bck;<br>          bck-&gt;fd = bin;<br><br>          if (av != &amp;main_arena)<br>    set_non_main_arena (victim);<br>          check_malloced_chunk (av, victim, nb);<br>#if USE_TCACHE<br>  /* While we&#x27;re here, if we see other chunks of the same size,<br>     stash them in the tcache.  */<br>  size_t tc_idx = csize2tidx (nb);<br>  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    &#123;<br>      mchunkptr tc_victim;<br><br>      /* While bin not empty and tcache not full, copy chunks over.  */<br>      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>     &amp;&amp; (tc_victim = last (bin)) != bin)<br>&#123;<br>  if (tc_victim != 0)<br>    &#123;<br>      bck = tc_victim-&gt;bk;<br>      set_inuse_bit_at_offset (tc_victim, nb);<br>      if (av != &amp;main_arena)<br>set_non_main_arena (tc_victim);<br>      bin-&gt;bk = bck;<br>      bck-&gt;fd = bin;<br><br>      tcache_put (tc_victim, tc_idx);<br>            &#125;<br>&#125;<br>    &#125;<br>#endif<br>          void *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          return p;<br>        &#125;<br>    &#125;<br><br>  /*<br>     If this is a large request, consolidate fastbins before continuing.<br>     While it might look excessive to kill all fastbins before<br>     even seeing if there is space available, this avoids<br>     fragmentation problems normally associated with fastbins.<br>     Also, in practice, programs tend to have runs of either small or<br>     large requests, but less often mixtures, so consolidation is not<br>     invoked all that often in most programs. And the programs that<br>     it is called frequently in otherwise tend to fragment.<br>   */<br><br>  else<br>    &#123;<br>      idx = largebin_index (nb);<br>      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>        malloc_consolidate (av);<br>    &#125;<br><br>  /*<br>     Process recently freed or remaindered chunks, taking one only if<br>     it is exact fit, or, if this a small request, the chunk is remainder from<br>     the most recent non-exact fit.  Place other traversed chunks in<br>     bins.  Note that this step is the only place in any routine where<br>     chunks are placed in bins.<br><br>     The outer loop here is needed because we might not realize until<br>     near the end of malloc that we should have consolidated, so must<br>     do so and retry. This happens at most once, and only when we would<br>     otherwise need to expand memory to service a &quot;small&quot; request.<br>   */<br><br>#if USE_TCACHE<br>  INTERNAL_SIZE_T tcache_nb = 0;<br>  size_t tc_idx = csize2tidx (nb);<br>  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br>  int return_cached = 0;<br><br>  tcache_unsorted_count = 0;<br>#endif<br><br>  for (;; )<br>    &#123;<br>      int iters = 0;<br>      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          size = chunksize (victim);<br>          mchunkptr next = chunk_at_offset (victim, size);<br><br>          if (__glibc_unlikely (size &lt;= 2 * SIZE_SZ)<br>               __glibc_unlikely (size &gt; av-&gt;system_mem))<br>            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);<br>          if (__glibc_unlikely (chunksize_nomask (next) &lt; 2 * SIZE_SZ)<br>               __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))<br>            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);<br>          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))<br>            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);<br>          if (__glibc_unlikely (bck-&gt;fd != victim)<br>               __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))<br>            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);<br>          if (__glibc_unlikely (prev_inuse (next)))<br>            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);<br><br>          /*<br>             If a small request, try to use last remainder if it is the<br>             only chunk in unsorted bin.  This helps promote locality for<br>             runs of consecutive small requests. This is the only<br>             exception to best-fit, and applies only when there is<br>             no exact fit for a small chunk.<br>           */<br><br>          if (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))<br>            &#123;<br>              /* split and reattach remainder */<br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              if (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = NULL;<br>                  remainder-&gt;bk_nextsize = NULL;<br>                &#125;<br><br>              set_head (victim, nb  PREV_INUSE <br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));<br>              set_head (remainder, remainder_size  PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              void *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              return p;<br>            &#125;<br><br>          /* remove from unsorted list */<br>          if (__glibc_unlikely (bck-&gt;fd != victim))<br>            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);<br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          /* Take now instead of binning if exact fit */<br><br>          if (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              if (av != &amp;main_arena)<br>set_non_main_arena (victim);<br>#if USE_TCACHE<br>      /* Fill cache first, return to user only if cache fills.<br> We may return one of these chunks later.  */<br>      if (tcache_nb<br>  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>&#123;<br>  tcache_put (victim, tc_idx);<br>  return_cached = 1;<br>  continue;<br>&#125;<br>      else<br>&#123;<br>#endif<br>              check_malloced_chunk (av, victim, nb);<br>              void *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              return p;<br>#if USE_TCACHE<br>&#125;<br>#endif<br>            &#125;<br><br>          /* place chunk in bin */<br><br>          if (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          else<br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              /* maintain large bins in sorted order */<br>              if (fwd != bck)<br>                &#123;<br>                  /* Or with inuse bit to speed comparisons */<br>                  size = PREV_INUSE;<br>                  /* if smaller than smallest, bypass loop below */<br>                  assert (chunk_main_arena (bck-&gt;bk));<br>                  if ((unsigned long) (size)<br>      &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  else<br>                    &#123;<br>                      assert (chunk_main_arena (fwd));<br>                      while ((unsigned long) size &lt; chunksize_nomask (fwd))<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>  assert (chunk_main_arena (fwd));<br>                        &#125;<br><br>                      if ((unsigned long) size<br>  == (unsigned long) chunksize_nomask (fwd))<br>                        /* Always insert in the second position.  */<br>                        fwd = fwd-&gt;fd;<br>                      else<br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              else<br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br>#if USE_TCACHE<br>      /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while<br> filling the cache, return one of the cached ones.  */<br>      ++tcache_unsorted_count;<br>      if (return_cached<br>  &amp;&amp; mp_.tcache_unsorted_limit &gt; 0<br>  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>&#123;<br>  return tcache_get (tc_idx);<br>&#125;<br>#endif<br><br>#define MAX_ITERS       10000<br>          if (++iters &gt;= MAX_ITERS)<br>            break;<br>        &#125;<br><br>#if USE_TCACHE<br>      /* If all the small chunks we found ended up cached, return one now.  */<br>      if (return_cached)<br>&#123;<br>  return tcache_get (tc_idx);<br>&#125;<br>#endif<br><br>      /*<br>         If a large request, scan through the chunks of current bin in<br>         sorted order to find smallest that fits.  Use the skip list for this.<br>       */<br><br>      if (!in_smallbin_range (nb))<br>        &#123;<br>          bin = bin_at (av, idx);<br><br>          /* skip scan if empty or largest chunk is too small */<br>          if ((victim = first (bin)) != bin<br>      &amp;&amp; (unsigned long) chunksize_nomask (victim)<br>        &gt;= (unsigned long) (nb))<br>            &#123;<br>              victim = victim-&gt;bk_nextsize;<br>              while (((unsigned long) (size = chunksize (victim)) &lt;<br>                      (unsigned long) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br><br>              /* Avoid removing the first entry for a size so that the skip<br>                 list does not have to be rerouted.  */<br>              if (victim != last (bin)<br>  &amp;&amp; chunksize_nomask (victim)<br>    == chunksize_nomask (victim-&gt;fd))<br>                victim = victim-&gt;fd;<br><br>              remainder_size = size - nb;<br>              unlink_chunk (av, victim);<br><br>              /* Exhaust */<br>              if (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  if (av != &amp;main_arena)<br>    set_non_main_arena (victim);<br>                &#125;<br>              /* Split */<br>              else<br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br>                  /* We cannot assume the unsorted list is empty and therefore<br>                     have to perform a complete insert here.  */<br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  if (__glibc_unlikely (fwd-&gt;bk != bck))<br>    malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;);<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  if (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = NULL;<br>                      remainder-&gt;bk_nextsize = NULL;<br>                    &#125;<br>                  set_head (victim, nb  PREV_INUSE <br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));<br>                  set_head (remainder, remainder_size  PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              void *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              return p;<br>            &#125;<br>        &#125;<br><br>      /*<br>         Search for a chunk by scanning bins, starting with next largest<br>         bin. This search is strictly by best-fit; i.e., the smallest<br>         (with ties going to approximately the least recently used) chunk<br>         that fits is selected.<br><br>         The bitmap avoids needing to check that most blocks are nonempty.<br>         The particular case of skipping all bins during warm-up phases<br>         when no chunks have been returned yet is faster than it might look.<br>       */<br><br>      ++idx;<br>      bin = bin_at (av, idx);<br>      block = idx2block (idx);<br>      map = av-&gt;binmap[block];<br>      bit = idx2bit (idx);<br><br>      for (;; )<br>        &#123;<br>          /* Skip rest of block if there are no more set bits in this block.  */<br>          if (bit &gt; map  bit == 0)<br>            &#123;<br>              do<br>                &#123;<br>                  if (++block &gt;= BINMAPSIZE) /* out of bins */<br>                    goto use_top;<br>                &#125;<br>              while ((map = av-&gt;binmap[block]) == 0);<br><br>              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>              bit = 1;<br>            &#125;<br><br>          /* Advance to bin with set bit. There must be one. */<br>          while ((bit &amp; map) == 0)<br>            &#123;<br>              bin = next_bin (bin);<br>              bit &lt;&lt;= 1;<br>              assert (bit != 0);<br>            &#125;<br><br>          /* Inspect the bin. It is likely to be non-empty */<br>          victim = last (bin);<br><br>          /*  If a false alarm (empty bin), clear the bit. */<br>          if (victim == bin)<br>            &#123;<br>              av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */<br>              bin = next_bin (bin);<br>              bit &lt;&lt;= 1;<br>            &#125;<br><br>          else<br>            &#123;<br>              size = chunksize (victim);<br><br>              /*  We know the first chunk in this bin is big enough to use. */<br>              assert ((unsigned long) (size) &gt;= (unsigned long) (nb));<br><br>              remainder_size = size - nb;<br><br>              /* unlink */<br>              unlink_chunk (av, victim);<br><br>              /* Exhaust */<br>              if (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  if (av != &amp;main_arena)<br>    set_non_main_arena (victim);<br>                &#125;<br><br>              /* Split */<br>              else<br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br><br>                  /* We cannot assume the unsorted list is empty and therefore<br>                     have to perform a complete insert here.  */<br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  if (__glibc_unlikely (fwd-&gt;bk != bck))<br>    malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;);<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br><br>                  /* advertise as last remainder */<br>                  if (in_smallbin_range (nb))<br>                    av-&gt;last_remainder = remainder;<br>                  if (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = NULL;<br>                      remainder-&gt;bk_nextsize = NULL;<br>                    &#125;<br>                  set_head (victim, nb  PREV_INUSE <br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));<br>                  set_head (remainder, remainder_size  PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              void *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              return p;<br>            &#125;<br>        &#125;<br><br>    use_top:<br>      /*<br>         If large enough, split off the chunk bordering the end of memory<br>         (held in av-&gt;top). Note that this is in accord with the best-fit<br>         search rule.  In effect, av-&gt;top is treated as larger (and thus<br>         less well fitting) than any other available chunk since it can<br>         be extended to be as large as necessary (up to system<br>         limitations).<br><br>         We require that av-&gt;top always exists (i.e., has size &gt;=<br>         MINSIZE) after initialization, so if it would otherwise be<br>         exhausted by current request, it is replenished. (The main<br>         reason for ensuring it exists is that we may need MINSIZE space<br>         to put in fenceposts in sysmalloc.)<br>       */<br><br>      victim = av-&gt;top;<br>      size = chunksize (victim);<br><br>      if (__glibc_unlikely (size &gt; av-&gt;system_mem))<br>        malloc_printerr (&quot;malloc(): corrupted top size&quot;);<br><br>      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))<br>        &#123;<br>          remainder_size = size - nb;<br>          remainder = chunk_at_offset (victim, nb);<br>          av-&gt;top = remainder;<br>          set_head (victim, nb  PREV_INUSE <br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));<br>          set_head (remainder, remainder_size  PREV_INUSE);<br><br>          check_malloced_chunk (av, victim, nb);<br>          void *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          return p;<br>        &#125;<br><br>      /* When we are using atomic ops to free fast chunks we can get<br>         here for all block sizes.  */<br>      else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>        &#123;<br>          malloc_consolidate (av);<br>          /* restore original bin index */<br>          if (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          else<br>            idx = largebin_index (nb);<br>        &#125;<br><br>      /*<br>         Otherwise, relay to handle system-dependent cases<br>       */<br>      else<br>        &#123;<br>          void *p = sysmalloc (nb, av);<br>          if (p != NULL)<br>            alloc_perturb (p, bytes);<br>          return p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/69b2f595-28c5-43f9-807b-fd89a06403a9'><img src="blob:https://tokameine.top/69b2f595-28c5-43f9-807b-fd89a06403a9"></p>
<p>         代码量较大，由于接下来大多为文字介绍，如果不对照代码可能有些晦涩，建议读者自行下载源代码或是拷贝上述代码以方便对照</p>
<h1 id="libc-malloc："><a href="#libc-malloc：" class="headerlink" title="__libc_malloc："></a><strong>__libc_malloc</strong>：</h1><p>        malloc函数在被调用时，会使用<strong>__libc_malloc</strong>函数进行一定的初始化功能，然后再调用<strong>_int_malloc</strong>函数进行内存块分配</p>
<p>        而管理器会调用<strong>malloc_hook_ini</strong>函数对堆进行初始化，然后回调<strong>__libc_malloc，</strong>但这并不是我们关注的重点，因此这里不会过多介绍</p>
<h2 id="分支：如果使用Tcache"><a href="#分支：如果使用Tcache" class="headerlink" title="分支：如果使用Tcache"></a>分支：如果使用Tcache</h2><blockquote>
<p>        根据请求bytes大小的空间，调用checked_request2size宏定义将其转换为内存块的大小tbytes，再通过csize2tidx获取对应的Bins结构索引</p>
<p>        如果Tcache还未初始化，则用MAYBE_INIT_TCACHE初始化；否则不执行</p>
<p>        检查tcache索引tc_idx是否合法，以及该索引中是否有空闲块。若有，则直接取出并返回给用户</p>
</blockquote>
<p>        否则，判断请求是否由主线程发起。若是，调用_int_malloc申请内存块，并返回给用户</p>
<p>        否则，获取当前线程arena存入ar_ptr，调用_int_malloc申请内存块</p>
<p>        如果当前arena正被其他线程使用，则_int_malloc将会返回NULL，调用失败，直到有空闲的arena出现时，重新调用_int_malloc并返回给用户</p>
<h1 id="int-malloc："><a href="#int-malloc：" class="headerlink" title="_int_malloc："></a><strong>_int_malloc：</strong></h1><p>        先用checked_request2size将请求的bytes转换为chunk块的大小nb</p>
<h2 id="分支-1："><a href="#分支-1：" class="headerlink" title="分支 1："></a>分支 1：</h2><blockquote>
<p>        如果arena空间不足(没有可用的arena)，调用sysmalloc通过mmap或者brk来分配新堆块，如果成功，就直接返回给用户</p>
</blockquote>
<p>         否则，通常此时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pp==NULL<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/00b6ccef-a712-4e05-b3f6-c27dc03c5fe5'><img src="blob:https://tokameine.top/00b6ccef-a712-4e05-b3f6-c27dc03c5fe5"></p>
<p>        成立，因此不执行REMOVE_FB，其作用是将pp从Bin中取出</p>
<h2 id="分支-2：Fast-Bin范围内"><a href="#分支-2：Fast-Bin范围内" class="headerlink" title="分支 2：Fast Bin范围内"></a>分支 2：Fast Bin范围内</h2><blockquote>
<p>        如果块的大小能由Fast Bins提供服务(即在sizeof(size_t)的返回值范围内)，根据nb获取对应Bin的链表索引idx</p>
<p>        使用fastbin()宏定义来获取该链表的表头，指针为fd</p>
<p>        将第一个节点作为victim，如果是单线程情况，则向表头里放入victim的下一个</p>
<p>        如果victim取到了空闲块，获取所在链表索引victim_idx，并做一系列检查</p>
<p> <strong>且函数不返回，继续往下判断分支2.1</strong></p>
<p>注：FastBin的安全性检测中，存在对ChunkSize的检测，即要求该bin中的chunk符合该bin的规范。但这个检测并非强对比，例如：Size&#x3D;7f的chunk会被放在0x70的bin中而不报错</p>
</blockquote>
<h3 id="分支-2-1：使用Tcache"><a href="#分支-2-1：使用Tcache" class="headerlink" title="分支 2.1：使用Tcache"></a>分支 2.1：使用Tcache</h3><blockquote>
<p>        根据nb获取对应链表索引tc_idx，如果获取的内容合法(即索引可行的范围)，将F<strong>astBin表头中的节点fd</strong>作为tc_victim</p>
<p>        循环的将tc_victim放入Tcache Bin中</p>
<p>        最后将victim(也就是最早的Fast Bin的第一个节点)返回给用户</p>
<p> <strong>函数结束</strong></p>
</blockquote>
<h3 id="分支2-2：否则"><a href="#分支2-2：否则" class="headerlink" title="分支2.2：否则"></a>分支2.2：否则</h3><blockquote>
<p>        直接将victim返回给用户</p>
<p> <strong>函数结束</strong></p>
</blockquote>
<h2 id="分支3：Small-Bin范围内"><a href="#分支3：Small-Bin范围内" class="headerlink" title="分支3：Small Bin范围内"></a>分支3：Small Bin范围内</h2><p>        在Fast Bin没能找到合适块的情况下(比如对应链表为空等等)，将进入该分支</p>
<p>        通过smallbin_index获取链表索引idx，bin_at获取链表表头bin</p>
<h3 id="分支3-1：链表非空"><a href="#分支3-1：链表非空" class="headerlink" title="分支3.1：链表非空"></a>分支3.1：链表非空</h3><p>        此时victim将成为当前链表最后一个，如下为其宏定义操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define last(b)      ((b)-&gt;bk)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/a2365d44-648e-4be7-b404-e7c3f50a28ea'><img src="blob:https://tokameine.top/a2365d44-648e-4be7-b404-e7c3f50a28ea"></p>
<p>        令bck为链表倒数第二个，判断bck-&gt;fd是否为victim（出于安全性的检查）</p>
<p>        若成功，令链表最后一个为bck，而bck-&gt;fd为表头bin</p>
<p>    <strong>且函数不返回，继续往下判断分支3.2</strong></p>
<h3 id="分支3-2：使用Tcache"><a href="#分支3-2：使用Tcache" class="headerlink" title="分支3.2：使用Tcache"></a>分支3.2：使用Tcache</h3><p>        获取索引tc_idx，检查其合法性，若对应链表中存在空闲块，进入循环</p>
<p>        令tc_victim为Small Bin中此时的最后一个(即分支3.1中所指的bck)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bin-&gt;bk = bck;<br>bck-&gt;fd = bin;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/ad179c36-68f9-4142-b330-e78f8036f24c'><img src="blob:https://tokameine.top/ad179c36-68f9-4142-b330-e78f8036f24c"></p>
<p>        通过该Unlink操作，并执行tcache_put将 tc_victim放入Tcache Bin中，直到Tcache Bin链表满员，或者该Small Bin为空</p>
<p> <strong>且函数不返回，继续往下进入分支3.3</strong></p>
<h3 id="分支3-3：否则"><a href="#分支3-3：否则" class="headerlink" title="分支3.3：否则"></a>分支3.3：否则</h3><blockquote>
<p>        将从Small Bin中获取到的victim返回给用户</p>
<p> <strong>函数结束</strong></p>
</blockquote>
<h2 id="分支4：Large-Bin范围内"><a href="#分支4：Large-Bin范围内" class="headerlink" title="分支4：Large Bin范围内"></a>分支4：Large Bin范围内</h2><blockquote>
<p>        获取对应链表索引idx</p>
<p>        判断Fast Bin中是否有空闲块，若有，调用malloc_consolidate将其合并且投放到Unsorted Bin</p>
<p> <strong>函数继续往下，判断分支5</strong></p>
</blockquote>
<h2 id="分支5：使用Tcache"><a href="#分支5：使用Tcache" class="headerlink" title="分支5：使用Tcache"></a>分支5：使用Tcache</h2><blockquote>
<p>        如果分支3没能令函数返回，则必然会判断是否进入该分支，如果进入，则进行如下流程</p>
<p>        根据nb获取对应Tcache Bin中的链表索引tc_idx，如果其在可行范围内，令tcache_nb为nb</p>
<p> <strong>函数进行往下</strong></p>
</blockquote>
<h2 id="分支6：否则"><a href="#分支6：否则" class="headerlink" title="分支6：否则"></a>分支6：否则</h2><h3 id="分支6-1：Unsorted-Bin中存在空闲块"><a href="#分支6-1：Unsorted-Bin中存在空闲块" class="headerlink" title="分支6.1：Unsorted Bin中存在空闲块"></a>分支6.1：Unsorted Bin中存在空闲块</h3><p>        令victim成为Unsorted Bin中最后一个空闲块，bck为倒数第二个</p>
<p>        获取victim的大小size</p>
<p>        通过chunk_at_offset获得在物理地址上相邻的下一个chunk的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/929a09f0-4e3b-4807-a844-5fbbbc19efeb'><img src="blob:https://tokameine.top/929a09f0-4e3b-4807-a844-5fbbbc19efeb"></p>
<p>        通过一系列安全性检查</p>
<h3 id="分支6-1-1：nb在Small-Bin范围-bck为Unsorted-Bin最后一个-victim的size足够被分配-有剩余的情况"><a href="#分支6-1-1：nb在Small-Bin范围-bck为Unsorted-Bin最后一个-victim的size足够被分配-有剩余的情况" class="headerlink" title="分支6.1.1：nb在Small Bin范围&amp;bck为Unsorted Bin最后一个&amp;victim的size足够被分配(有剩余的情况)"></a>分支6.1.1：nb在Small Bin范围&amp;bck为Unsorted Bin最后一个&amp;victim的size足够被分配(有剩余的情况)</h3><blockquote>
<p>        分割victim，将remainder作为victim分割后剩下的部分</p>
<p>        令Unsorted Bin的头尾指向remainder，remainder的头尾也指向表头</p>
<p>        如果remainder的剩余大小不在Small Bin的范围内，将fd_nextsize与bk_nextsize置NULL</p>
<p>        set_head设置Top chunk大小</p>
<p>        并将切割后的victim(非remainder部分)返回给用</p>
</blockquote>
<p>        将bck(倒数第二个)作为新的链表尾</p>
<h3 id="分支6-1-2：尺寸刚好-无剩余"><a href="#分支6-1-2：尺寸刚好-无剩余" class="headerlink" title="分支6.1.2：尺寸刚好(无剩余)"></a>分支6.1.2：尺寸刚好(无剩余)</h3><p> <strong>分支6.1.2.1：使用Tcache</strong></p>
<blockquote>
<p>        如果victim是能够放入Tcache Bin中的chunk，那么就将它放入Tcache Bin中，并<strong>回到分支6</strong></p>
</blockquote>
<p>        <strong>分支6.1.2.2：否则</strong></p>
<blockquote>
<p>        如果已经没有可放入的内容了，将victim返回给用户</p>
<p>        函数结束</p>
</blockquote>
<h3 id="分支6-1-3：否则"><a href="#分支6-1-3：否则" class="headerlink" title="分支6.1.3：否则"></a>分支6.1.3：否则</h3><blockquote>
<p>        判断victim符合Small Bin还是Large Bin</p>
<p>        并将victim投放到相应的表头中</p>
</blockquote>
<h3 id="分支6-1-4：如果有往Tcache-Bin中投放过chunk或是所有Small-Bin都被投放完成"><a href="#分支6-1-4：如果有往Tcache-Bin中投放过chunk或是所有Small-Bin都被投放完成" class="headerlink" title="分支6.1.4：如果有往Tcache Bin中投放过chunk或是所有Small Bin都被投放完成"></a><strong>分支6.1.4：如果有往Tcache Bin中投放过chunk或是所有Small Bin都被投放完成</strong></h3><blockquote>
<p>        通过索引返回一个之前投放的块</p>
</blockquote>
<h2 id="分支7：如果nb属于Large-Bin"><a href="#分支7：如果nb属于Large-Bin" class="headerlink" title="分支7：如果nb属于Large Bin"></a>分支7：<strong>如果nb属于Large Bin</strong></h2><blockquote>
<p>        通过循环与bk_nextsize找到稍比nb大一些的chunk</p>
<p>        如果该chunk与chunk-&gt;fd的大小相同，那就让victim成为第二个chunk</p>
<p>        使用unlink_chunk来将victim从链表中摘下</p>
<p>        分割该chunk，将剩余部分放入Unsorted Bin中，并将其他返回给用户</p>
<p>        函数结束</p>
</blockquote>
<h2 id="分支8：其他"><a href="#分支8：其他" class="headerlink" title="分支8：其他"></a>分支8：其他</h2><blockquote>
<p>        从下一个索引开始进入循环并不断搜索，直到找到一个合适的chunk块 或者 索引超出了最大值(如果当前索引链表为空，就会直接跳过，继续往下)</p>
<p>        如果找到了这样一个块，分割它，并将甚于部分放入Unsorted Bin中，其他的返回给用户</p>
</blockquote>
<h2 id="分支9：否则"><a href="#分支9：否则" class="headerlink" title="分支9：否则"></a>分支9：否则</h2><h3 id="分支9-1：如果Top-Chunk足够"><a href="#分支9-1：如果Top-Chunk足够" class="headerlink" title="分支9.1：如果Top Chunk足够"></a>分支9.1：如果Top Chunk足够</h3><p>        分割Top chunk，将chunk返回给用户，修改Top chunk的地址和剩余大小</p>
<h3 id="分支9-2：否则"><a href="#分支9-2：否则" class="headerlink" title="分支9.2：否则"></a>分支9.2：否则</h3><p>        使用malloc_consolidate合并Fast Bins，并投放到Unsorted Bin中</p>
<p>        使用sysmalloc通过brk或者mmap来开辟新的Heap</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://www.zzl14.xyz/2020/04/13/malloc%E6%B5%81%E7%A8%8B/#int-malloc">https://www.zzl14.xyz/2020/04/13/malloc%E6%B5%81%E7%A8%8B/#int-malloc</a></p>
<p>这位师傅用2.27的源代码也进行了详尽的说明，也比较推荐参考其博客 ​</p>
<p>插画ID：91612724</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-9/">← 下一篇 关于如何理解Glibc堆管理器(Ⅸ——从源代码理解free)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-7/">关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!) 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">源代码：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libc-malloc%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">__libc_malloc：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8Tcache"><span class="toc-number">2.1.</span> <span class="toc-text">分支：如果使用Tcache</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int-malloc%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">_int_malloc：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF-1%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">分支 1：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF-2%EF%BC%9AFast-Bin%E8%8C%83%E5%9B%B4%E5%86%85"><span class="toc-number">3.2.</span> <span class="toc-text">分支 2：Fast Bin范围内</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF-2-1%EF%BC%9A%E4%BD%BF%E7%94%A8Tcache"><span class="toc-number">3.2.1.</span> <span class="toc-text">分支 2.1：使用Tcache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF2-2%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.2.2.</span> <span class="toc-text">分支2.2：否则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF3%EF%BC%9ASmall-Bin%E8%8C%83%E5%9B%B4%E5%86%85"><span class="toc-number">3.3.</span> <span class="toc-text">分支3：Small Bin范围内</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF3-1%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%9D%9E%E7%A9%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">分支3.1：链表非空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF3-2%EF%BC%9A%E4%BD%BF%E7%94%A8Tcache"><span class="toc-number">3.3.2.</span> <span class="toc-text">分支3.2：使用Tcache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF3-3%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.3.3.</span> <span class="toc-text">分支3.3：否则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF4%EF%BC%9ALarge-Bin%E8%8C%83%E5%9B%B4%E5%86%85"><span class="toc-number">3.4.</span> <span class="toc-text">分支4：Large Bin范围内</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF5%EF%BC%9A%E4%BD%BF%E7%94%A8Tcache"><span class="toc-number">3.5.</span> <span class="toc-text">分支5：使用Tcache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF6%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.6.</span> <span class="toc-text">分支6：否则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1%EF%BC%9AUnsorted-Bin%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="toc-number">3.6.1.</span> <span class="toc-text">分支6.1：Unsorted Bin中存在空闲块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1-1%EF%BC%9Anb%E5%9C%A8Small-Bin%E8%8C%83%E5%9B%B4-bck%E4%B8%BAUnsorted-Bin%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA-victim%E7%9A%84size%E8%B6%B3%E5%A4%9F%E8%A2%AB%E5%88%86%E9%85%8D-%E6%9C%89%E5%89%A9%E4%BD%99%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.6.2.</span> <span class="toc-text">分支6.1.1：nb在Small Bin范围&amp;bck为Unsorted Bin最后一个&amp;victim的size足够被分配(有剩余的情况)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1-2%EF%BC%9A%E5%B0%BA%E5%AF%B8%E5%88%9A%E5%A5%BD-%E6%97%A0%E5%89%A9%E4%BD%99"><span class="toc-number">3.6.3.</span> <span class="toc-text">分支6.1.2：尺寸刚好(无剩余)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1-3%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.6.4.</span> <span class="toc-text">分支6.1.3：否则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1-4%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%9C%89%E5%BE%80Tcache-Bin%E4%B8%AD%E6%8A%95%E6%94%BE%E8%BF%87chunk%E6%88%96%E6%98%AF%E6%89%80%E6%9C%89Small-Bin%E9%83%BD%E8%A2%AB%E6%8A%95%E6%94%BE%E5%AE%8C%E6%88%90"><span class="toc-number">3.6.5.</span> <span class="toc-text">分支6.1.4：如果有往Tcache Bin中投放过chunk或是所有Small Bin都被投放完成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF7%EF%BC%9A%E5%A6%82%E6%9E%9Cnb%E5%B1%9E%E4%BA%8ELarge-Bin"><span class="toc-number">3.7.</span> <span class="toc-text">分支7：如果nb属于Large Bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF8%EF%BC%9A%E5%85%B6%E4%BB%96"><span class="toc-number">3.8.</span> <span class="toc-text">分支8：其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF9%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.9.</span> <span class="toc-text">分支9：否则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF9-1%EF%BC%9A%E5%A6%82%E6%9E%9CTop-Chunk%E8%B6%B3%E5%A4%9F"><span class="toc-number">3.9.1.</span> <span class="toc-text">分支9.1：如果Top Chunk足够</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF9-2%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.9.2.</span> <span class="toc-text">分支9.2：否则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">参考文章：</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>