<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅹ——完结、补充、注释——Arena、heap_info、malloc_*) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅹ——完结、补充、注释——Arena、heap_info、malloc_*)</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2021-08-07T12:30:18.000Z" id="date"> 2021-08-07</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.992Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p>本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源(也有置于篇首的情况)。</p>
<p>        截至到本节内容，该系列算是正式完结了，后续或许会有补充，但基本上都将添加在本节内容中。在前几节中，笔者已经按照自己的思路尽可能详尽的将Glibc的堆管理器Ptmalloc2的方式做了一定的介绍，尽管Ptmalloc2的内容肯定不止这些，但已能大致了解其工作方式了</p>
<p>        但也有一些必要的内容未曾在前几节中放出，诸如突然出现的<strong>Arena，</strong>以及<strong>Heap的结构</strong>等内容没能展开介绍，因此将这些内容补充在本系列最后一节</p>
<h2 id="heap-info结构体："><a href="#heap-info结构体：" class="headerlink" title="heap_info结构体："></a>heap_info结构体：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _heap_info<br>&#123;<br>  mstate ar_ptr; /* Arena for this heap. */<br>  struct _heap_info *prev; /* Previous heap. */<br>  size_t size;   /* Current size in bytes. */<br>  size_t mprotect_size; /* Size in bytes that has been mprotected<br>                           PROT_READPROT_WRITE.  */<br>  /* Make sure the following data is properly aligned, particularly<br>     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of<br>     MALLOC_ALIGNMENT. */<br>  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/44e9c05d-dd32-46c4-87ae-e7d5b91b0f0d'><img src="blob:https://tokameine.top/44e9c05d-dd32-46c4-87ae-e7d5b91b0f0d"></p>
<p>        每一个新开辟的堆都有一个独立的heap_info结构体</p>
<ul>
<li>        <strong>ar_ptr指针</strong>指向一个为该堆服务的arena</li>
<li>      <strong>prev指针</strong>指向上一个堆的heap_info结构体</li>
<li>        <strong>size</strong>记录了堆的大小</li>
<li>        <strong>mprotect_size</strong>记录了堆中多大的空间是可读写的</li>
<li>        <strong>pad字符串</strong>则用以堆其该结构体，使其能够按照0x10字节对齐(x86中则是8字节对齐)</li>
</ul>
<p>        这里引用CTF-WIKI中对pad的解释：</p>
<blockquote>
<p><strong>pad 里负数的缘由是什么呢？</strong></p>
<p> <code>pad</code> 是为了确保分配的空间是按照 <code>MALLOC_ALIGN_MASK+1</code> (记为 <code>MALLOC_ALIGN_MASK_1</code>) 对齐的。在 <code>pad</code> 之前该结构体一共有 6 个 <code>SIZE_SZ</code> 大小的成员, 为了确保 <code>MALLOC_ALIGN_MASK_1</code> 字节对齐, 可能需要进行 <code>pad</code>，不妨假设该结构体的最终大小为 <code>MALLOC_ALIGN_MASK_1*x</code>，其中 <code>x</code> 为自然数，那么需要 <code>pad</code> 的空间为 <code>MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ = (MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ) % MALLOC_ALIGN_MASK_1 = 0 - 6 * SIZE_SZ % MALLOC_ALIGN_MASK_1=-6 * SIZE_SZ % MALLOC_ALIGN_MASK_1 = -6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK</code> </p>
</blockquote>
<h2 id="malloc-state："><a href="#malloc-state：" class="headerlink" title="malloc_state："></a>malloc_state：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct malloc_state<br>&#123;<br>  /* Serialize access.  */<br>  __libc_lock_define (, mutex);<br><br>  /* Flags (formerly in max_fast).  */<br>  int flags;<br><br>  /* Set if the fastbin chunks contain recently inserted free blocks.  */<br>  /* Note this is a bool but not all targets support atomics on booleans.  */<br>  int have_fastchunks;<br><br>  /* Fastbins */<br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  /* Base of the topmost chunk -- not otherwise kept in a bin */<br>  mchunkptr top;<br><br>  /* The remainder from the most recent split of a small request */<br>  mchunkptr last_remainder;<br><br>  /* Normal bins packed as described above */<br>  mchunkptr bins[NBINS * 2 - 2];<br><br>  /* Bitmap of bins */<br>  unsigned int binmap[BINMAPSIZE];<br><br>  /* Linked list */<br>  struct malloc_state *next;<br><br>  /* Linked list for free arenas.  Access to this field is serialized<br>     by free_list_lock in arena.c.  */<br>  struct malloc_state *next_free;<br><br>  /* Number of threads attached to this arena.  0 if the arena is on<br>     the free list.  Access to this field is serialized by<br>     free_list_lock in arena.c.  */<br>  INTERNAL_SIZE_T attached_threads;<br><br>  /* Memory allocated from the system in this arena.  */<br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/0051bf1c-f51a-4307-b23b-03013d0ca0ed'><img src="blob:https://tokameine.top/0051bf1c-f51a-4307-b23b-03013d0ca0ed"></p>
<ul>
<li>          <strong>__libc_lock_define (, mutex)：</strong>笔者将其理解为一个开关(锁)，如果某个线程对这个堆进行操作时，就会将这个堆锁住，组织其他线程对这个堆的操作，直到其他线程发现这个变量被解开了，那么才会排队进行操作(笔者称锁住时为占用，否则为空闲)</li>
<li>        <strong>flags：</strong>一个二进制数，bit0记录FastBins中是否有空闲块，bit1 标识分配区是否能返回连续的虚拟地址空间，具体定义见下面的定义表</li>
<li>      <strong>fastbinsY[NFASTBINS]：</strong>一个存放了每个Fast Bin链表头指针的数组</li>
<li>        <strong>top</strong>：指向堆中的Top chunk</li>
<li>        <strong>last_reminder：</strong>指向最新切割chunk后剩余的部分</li>
<li>        <strong>bins：</strong>用于存放各类Bins结构的数组</li>
<li>       <strong>binmap：</strong>用来表示堆中是否还有空闲块</li>
<li>      **  next：**指向下一个相同类型结构体</li>
<li>    <strong>next_free：</strong>指向下一个空闲的arena</li>
<li>        <strong>attached_threads：</strong>指示有多少个线程连接这个堆</li>
<li>        <strong>system_mem&#x2F;max_system_mem：</strong>表示系统为这个堆分配了多少空间</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*<br>   FASTCHUNKS_BIT held in max_fast indicates that there are probably<br>   some fastbin chunks. It is set true on entering a chunk into any<br>   fastbin, and cleared only in malloc_consolidate.<br>   The truth value is inverted so that have_fastchunks will be true<br>   upon startup (since statics are zero-filled), simplifying<br>   initialization checks.<br> */<br><br>#define FASTCHUNKS_BIT (1U)<br><br>#define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)<br>#define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)<br>#define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)<br><br>/*<br>   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous<br>   regions.  Otherwise, contiguity is exploited in merging together,<br>   when possible, results from consecutive MORECORE calls.<br>   The initial value comes from MORECORE_CONTIGUOUS, but is<br>   changed dynamically if mmap is ever used as an sbrk substitute.<br> */<br><br>#define NONCONTIGUOUS_BIT (2U)<br><br>#define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)<br>#define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)<br>#define set_noncontiguous(M) ((M)-&gt;flags = NONCONTIGUOUS_BIT)<br>#define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)<br><br>/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the<br>   arena.  Such an arena is no longer used to allocate chunks.  Chunks<br>   allocated in that arena before detecting corruption are not freed.  */<br><br>#define ARENA_CORRUPTION_BIT (4U)<br><br>#define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))<br>#define set_arena_corrupt(A) ((A)-&gt;flags = ARENA_CORRUPTION_BIT)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/5a83acee-b0fd-4239-9017-e035051e2375'><img src="blob:https://tokameine.top/5a83acee-b0fd-4239-9017-e035051e2375"></p>
<h2 id="malloc-par："><a href="#malloc-par：" class="headerlink" title="malloc_par："></a>malloc_par：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct malloc_par<br>&#123;<br>  /* Tunable parameters */<br>  unsigned long trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  /* Memory map support */<br>  int n_mmaps;<br>  int n_mmaps_max;<br>  int max_n_mmaps;<br>  /* the mmap_threshold is dynamic, until the user sets<br>     it manually, at which point we need to disable any<br>     dynamic behavior. */<br>  int no_dyn_threshold;<br><br>  /* Statistics */<br>  INTERNAL_SIZE_T mmapped_mem;<br>  INTERNAL_SIZE_T max_mmapped_mem;<br><br>  /* First address handed out by MORECORE/sbrk.  */<br>  char *sbrk_base;<br><br>#if USE_TCACHE<br>  /* Maximum number of buckets to use.  */<br>  size_t tcache_bins;<br>  size_t tcache_max_bytes;<br>  /* Maximum number of chunks in each bucket.  */<br>  size_t tcache_count;<br>  /* Maximum number of chunks to remove from the unsorted list, which<br>     aren&#x27;t used to prefill the cache.  */<br>  size_t tcache_unsorted_limit;<br>#endif<br>&#125;;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/615b84e8-6f07-44ad-ade5-7b26d9d70548'><img src="blob:https://tokameine.top/615b84e8-6f07-44ad-ade5-7b26d9d70548"></p>
<p>        trim_threshold：收缩阈值，默认为128KB，当Top chunk大小超过该值时，调用free将可能引起堆的收缩，减少Top chunk的大小</p>
<p>        如下内容摘自：<a target="_blank" rel="noopener" href="https://www.lihaoranblog.cn/malloc_par/">https://www.lihaoranblog.cn/malloc_par&#x2F;</a></p>
<blockquote>
<p>        在一定的条件下，调用free时会收缩内存，减小top chunk的大小。由于mmap分配阈值的动态调整，在free时可能将收缩阈值修改为mmap分配阈值的2倍，在64位系统上，mmap分配阈值最大值为32MB，所以收缩阈值的最大值为64MB，在32位系统上，mmap分配阈值最大值为512KB，所以收缩阈值的最大值为1MB。收缩阈值可以通过函数mallopt()进行设置</p>
</blockquote>
<p>        top_pad：默认为0，表示分配堆时是否添加了额外的pad</p>
<p>        mmap_threshold：mmap分配阈值，默认为128K；32位中最大位512KB，64位中最大位32MB，但mmap会动调调整分配阈值，因此这个值可能会修改</p>
<p>        arena_test&#x2F;arena_max：</p>
<p>        如下内容摘自：<a target="_blank" rel="noopener" href="https://www.lihaoranblog.cn/malloc_par/">https://www.lihaoranblog.cn/malloc_par&#x2F;</a></p>
<blockquote>
<p>   arena_test和arena_max用于PER_THREAD优化，在32位系统上arena_test默认值为2，64位系统上的默认值为8，当每个进程的分配区数量小于等于arena_test时，不会重用已有的分配区。为了限制分配区的总数，用arena_max来保存分配区的最大数量，当系统中的分配区数量达到arena_max，就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用mallopt()函数设置。</p>
</blockquote>
<p>        n_mmaps：当前堆用mmap分配内存块的数量</p>
<p>        n_mmaps_max：当前堆用mmap分配内存块的最大数量，默认65536，可修改</p>
<p>        no_dyn_threshold：默认为0，表示开启mmap分配阈值动调调整</p>
<p>        mmapped_mem&#x2F;max_mmapped_mem：统计mmap分配的内存大小，通常两值相等</p>
<p>        在使用Tcache的情况下：</p>
<p>        tcache_bins&#x2F;tcache_max_bytes：Tcache链表数量，不会超过tcache_max_bytes</p>
<p>        tcache_count：每个链表最多可挂的节点数</p>
<p>        tcache_unsorted_limit：可从Unsorted Bin中拿出chunk的最大数量</p>
<h2 id="Arena："><a href="#Arena：" class="headerlink" title="Arena："></a>Arena：</h2><p>        可能有的文章会将其翻译成“竞技场”，但笔者仍然会用“Arena”去称呼它</p>
<p>        通常，一个线程只会有一个Arena，主线程的叫做Main_Arena，其他线程的叫做Thread_Arena，但Arena的数量并不会随着线程数而无限增加。其数量上限与系统和处理器核心数相关：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">32位系统中：<br>     Number of arena = 2 * number of cores + 1.<br>64位系统中：<br>     Number of arena = 8 * number of cores + 1<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/5a25e4a8-da95-45f7-8283-dcc837244180'><img src="blob:https://tokameine.top/5a25e4a8-da95-45f7-8283-dcc837244180"></p>
<blockquote>
<p><strong>CTF-WIKI：</strong> 与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p>
</blockquote>
<p>         正如上述的malloc_par结构体中arena_test参数所说，如果当前Arena的数量小于arena_test，那么堆管理器就会在其他线程创建堆结构的时候为其另外创建一个Arena</p>
<p>        但如果数量超过了arena_test，那么只在需要的时候才会创建(比如某线程发现其他Arena全都被占用了，为了不因为等待排队而浪费掉时间，于是另外开辟新的Arena)</p>
<p><strong>笔者对Arena的理解为：</strong></p>
<p>        一个Arena包括了一系列的堆（可能有的读者会把额外开辟的空间归并到同一个堆里，但笔者习惯于将额外开辟的内存块称为“新堆”以区别最早初始化时的堆，笔者称之为“主堆”，这样在解释内存收缩时，能够将其理解为“归还主堆以外的堆”）</p>
<p>        在之前的调试中也曾发现，main_arena似乎存在于栈上，而在CTF-WIKI中将其描述为全局变量。每个Arena都有自己的一套malloc_state、malloc_par、heap_info结构体，Arena中的一系列堆通过Arena进行管理(这样解释似乎有些怪异因为malloc_state结构体中存在指向Arena的指针，但也有一定的合理性，它在某种程度上方便了笔者的理解)</p>
<p>        可以先假设这样一个场景：</p>
<p>        某个进程存在两个线程A、B并发运行，存在一个chunk p。现在，线程A进行free(p)，而线程B则要往chunk p处写入一些数据。假设A稍快一点，它先被处理器进行处理，那么系统就要先阻塞线程B的请求，直到线程A的事情已经做完了为止。当线程A结束了，系统就会发现这块地址不可写，然后阻止它进行这个操作</p>
<p>        但是，阻塞是一件非常耗时的工作。如果只有少量这种情况发生，似乎也不是不能接受这种开销，但如果需要处理大量的多线程工作，这种阻塞就将带来严重的浪费。</p>
<p>        如果我们为不同的线程开辟不同的Arena，每个Arena都有自己的Bins，那么线程B就不需要等待线程A，可以直接操作自己的Arena去申请或是释放chunk</p>
<p>        当然，实际调试中会发现，我们开辟的chunk总是在Arena下方(往高地址处)，我们也可以将其理解为每个线程自己的一个“主堆”，这样就能避开那些“可以不使用堆锁的情况”</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210807191136604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210807191136604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/4d56f2cd-7765-41b0-9272-105ce3f7d806"> ​</p>
<p>插画ID：91629597</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/09/babyheap-0ctf-2017/">← 下一篇 FastBinAttack实战 - babyheap_0ctf_2017</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-9/">关于如何理解Glibc堆管理器(Ⅸ——从源代码理解free) 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#heap-info%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">heap_info结构体：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-state%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">malloc_state：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-par%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">malloc_par：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arena%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Arena：</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>