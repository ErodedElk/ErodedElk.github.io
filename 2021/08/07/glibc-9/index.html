<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>关于如何理解Glibc堆管理器(Ⅸ——从源代码理解free) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>关于如何理解Glibc堆管理器(Ⅸ——从源代码理解free)</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2021-08-07T12:28:45.000Z" id="date"> 2021-08-07</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:34.996Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p> 本篇实为个人笔记，可能存在些许错误；若各位师傅发现哪里存在错误，还望指正。感激不尽。</p>
<p>若有图片及文稿引用，将在本篇结尾处著名来源(也有置于篇首的情况)。</p>
<p>        为了文章的可读性，笔者将使用“块引用”来表示分支情况，在没有特别标注的情况下(没有说明引用来源时)，其中内容均为笔者所写</p>
<h1 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void<br>__libc_free (void *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          /* chunk corresponding to mem */<br><br>  void (*hook) (void *, const void *)<br>    = atomic_forced_read (__free_hook);<br>  if (__builtin_expect (hook != NULL, 0))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (0));<br>      return;<br>    &#125;<br><br>  if (mem == 0)                              /* free(0) has no effect */<br>    return;<br><br>  p = mem2chunk (mem);<br><br>  if (chunk_is_mmapped (p))                       /* release mmapped memory. */<br>    &#123;<br>      /* See if the dynamic brk/mmap threshold needs adjusting.<br> Dumped fake mmapped chunks do not affect the threshold.  */<br>      if (!mp_.no_dyn_threshold<br>          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = 2 * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      return;<br>    &#125;<br><br>  MAYBE_INIT_TCACHE ();<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, 0);<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/d67d3ebe-363c-4979-880b-5a55d72d29c1'><img src="blob:https://tokameine.top/d67d3ebe-363c-4979-880b-5a55d72d29c1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static void<br>_int_free (mstate av, mchunkptr p, int have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        /* its size */<br>  mfastbinptr *fb;             /* associated fastbin */<br>  mchunkptr nextchunk;         /* next contiguous chunk */<br>  INTERNAL_SIZE_T nextsize;    /* its size */<br>  int nextinuse;               /* true if nextchunk is used */<br>  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */<br>  mchunkptr bck;               /* misc temp for linking */<br>  mchunkptr fwd;               /* misc temp for linking */<br><br>  size = chunksize (p);<br><br>  /* Little security check which won&#x27;t hurt performance: the<br>     allocator never wrapps around at the end of the address space.<br>     Therefore we can exclude some size values which might appear<br>     here by accident or by &quot;design&quot; from some intruder.  */<br>  if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)<br>       __builtin_expect (misaligned_chunk (p), 0))<br>    malloc_printerr (&quot;free(): invalid pointer&quot;);<br>  /* We know that each chunk is at least MINSIZE bytes in size or a<br>     multiple of MALLOC_ALIGNMENT.  */<br>  if (__glibc_unlikely (size &lt; MINSIZE  !aligned_OK (size)))<br>    malloc_printerr (&quot;free(): invalid size&quot;);<br><br>  check_inuse_chunk(av, p);<br><br>#if USE_TCACHE<br>  &#123;<br>    size_t tc_idx = csize2tidx (size);<br>    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      &#123;<br>/* Check to see if it&#x27;s already in the tcache.  */<br>tcache_entry *e = (tcache_entry *) chunk2mem (p);<br><br>/* This test succeeds on double free.  However, we don&#x27;t 100%<br>   trust it (it also matches random payload data at a 1 in<br>   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely<br>   coincidence before aborting.  */<br>if (__glibc_unlikely (e-&gt;key == tcache))<br>  &#123;<br>    tcache_entry *tmp;<br>    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);<br>    for (tmp = tcache-&gt;entries[tc_idx];<br> tmp;<br> tmp = tmp-&gt;next)<br>      if (tmp == e)<br>malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);<br>    /* If we get here, it was a coincidence.  We&#x27;ve wasted a<br>       few cycles, but don&#x27;t abort.  */<br>  &#125;<br><br>if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>  &#123;<br>    tcache_put (p, tc_idx);<br>    return;<br>  &#125;<br>      &#125;<br>  &#125;<br>#endif<br><br>  /*<br>    If eligible, place chunk on a fastbin so it can be found<br>    and used quickly in malloc.<br>  */<br><br>  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())<br><br>#if TRIM_FASTBINS<br>      /*<br>If TRIM_FASTBINS set, don&#x27;t place chunks<br>bordering top into fastbins<br>      */<br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br>#endif<br>      ) &#123;<br><br>    if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<br>  &lt;= 2 * SIZE_SZ, 0)<br> __builtin_expect (chunksize (chunk_at_offset (p, size))<br>     &gt;= av-&gt;system_mem, 0))<br>      &#123;<br>bool fail = true;<br>/* We might not have a lock at this point and concurrent modifications<br>   of system_mem might result in a false positive.  Redo the test after<br>   getting the lock.  */<br>if (!have_lock)<br>  &#123;<br>    __libc_lock_lock (av-&gt;mutex);<br>    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= 2 * SIZE_SZ<br>     chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);<br>    __libc_lock_unlock (av-&gt;mutex);<br>  &#125;<br><br>if (fail)<br>  malloc_printerr (&quot;free(): invalid next size (fast)&quot;);<br>      &#125;<br><br>    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);<br><br>    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, true);<br>    unsigned int idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br><br>    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */<br>    mchunkptr old = *fb, old2;<br><br>    if (SINGLE_THREAD_P)<br>      &#123;<br>/* Check that the top of the bin is not the record we are going to<br>   add (i.e., double free).  */<br>if (__builtin_expect (old == p, 0))<br>  malloc_printerr (&quot;double free or corruption (fasttop)&quot;);<br>p-&gt;fd = old;<br>*fb = p;<br>      &#125;<br>    else<br>      do<br>&#123;<br>  /* Check that the top of the bin is not the record we are going to<br>     add (i.e., double free).  */<br>  if (__builtin_expect (old == p, 0))<br>    malloc_printerr (&quot;double free or corruption (fasttop)&quot;);<br>  p-&gt;fd = old2 = old;<br>&#125;<br>      while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))<br>     != old2);<br><br>    /* Check that size of fastbin chunk at the top is the same as<br>       size of the chunk that we are adding.  We can dereference OLD<br>       only if we have the lock, otherwise it might have already been<br>       allocated again.  */<br>    if (have_lock &amp;&amp; old != NULL<br>&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))<br>      malloc_printerr (&quot;invalid fastbin entry (free)&quot;);<br>  &#125;<br><br>  /*<br>    Consolidate other non-mmapped chunks as they arrive.<br>  */<br><br>  else if (!chunk_is_mmapped(p)) &#123;<br><br>    /* If we&#x27;re single-threaded, don&#x27;t lock the arena.  */<br>    if (SINGLE_THREAD_P)<br>      have_lock = true;<br><br>    if (!have_lock)<br>      __libc_lock_lock (av-&gt;mutex);<br><br>    nextchunk = chunk_at_offset(p, size);<br><br>    /* Lightweight tests: check whether the block is already the<br>       top block.  */<br>    if (__glibc_unlikely (p == av-&gt;top))<br>      malloc_printerr (&quot;double free or corruption (top)&quot;);<br>    /* Or whether the next chunk is beyond the boundaries of the arena.  */<br>    if (__builtin_expect (contiguous (av)<br>  &amp;&amp; (char *) nextchunk<br>  &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0))<br>malloc_printerr (&quot;double free or corruption (out)&quot;);<br>    /* Or whether the block is actually not marked used.  */<br>    if (__glibc_unlikely (!prev_inuse(nextchunk)))<br>      malloc_printerr (&quot;double free or corruption (!prev)&quot;);<br><br>    nextsize = chunksize(nextchunk);<br>    if (__builtin_expect (chunksize_nomask (nextchunk) &lt;= 2 * SIZE_SZ, 0)<br> __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))<br>      malloc_printerr (&quot;free(): invalid next size (normal)&quot;);<br><br>    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);<br><br>    /* consolidate backward */<br>    if (!prev_inuse(p)) &#123;<br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((long) prevsize));<br>      if (__glibc_unlikely (chunksize(p) != prevsize))<br>        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);<br>      unlink_chunk (av, p);<br>    &#125;<br><br>    if (nextchunk != av-&gt;top) &#123;<br>      /* get and clear inuse bit */<br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>      /* consolidate forward */<br>      if (!nextinuse) &#123;<br>unlink_chunk (av, nextchunk);<br>size += nextsize;<br>      &#125; else<br>clear_inuse_bit_at_offset(nextchunk, 0);<br><br>      /*<br>Place the chunk in unsorted chunk list. Chunks are<br>not placed into regular bins until after they have<br>been given one chance to be used in malloc.<br>      */<br><br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      if (__glibc_unlikely (fwd-&gt;bk != bck))<br>malloc_printerr (&quot;free(): corrupted unsorted chunks&quot;);<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      if (!in_smallbin_range(size))<br>&#123;<br>  p-&gt;fd_nextsize = NULL;<br>  p-&gt;bk_nextsize = NULL;<br>&#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size  PREV_INUSE);<br>      set_foot(p, size);<br><br>      check_free_chunk(av, p);<br>    &#125;<br><br>    /*<br>      If the chunk borders the current high end of memory,<br>      consolidate into top<br>    */<br><br>    else &#123;<br>      size += nextsize;<br>      set_head(p, size  PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br><br>    /*<br>      If freeing a large space, consolidate possibly-surrounding<br>      chunks. Then, if the total unused topmost memory exceeds trim<br>      threshold, ask malloc_trim to reduce top.<br><br>      Unless max_fast is 0, we don&#x27;t know if there are fastbins<br>      bordering top, so we cannot tell for sure whether threshold<br>      has been reached unless fastbins are consolidated.  But we<br>      don&#x27;t want to consolidate on each free.  As a compromise,<br>      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD<br>      is reached.<br>    */<br><br>    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))<br>malloc_consolidate(av);<br><br>      if (av == &amp;main_arena) &#123;<br>#ifndef MORECORE_CANNOT_TRIM<br>if ((unsigned long)(chunksize(av-&gt;top)) &gt;=<br>    (unsigned long)(mp_.trim_threshold))<br>  systrim(mp_.top_pad, av);<br>#endif<br>      &#125; else &#123;<br>/* Always try heap_trim(), even if the top chunk is not<br>   large, because the corresponding heap might go away.  */<br>heap_info *heap = heap_for_ptr(top(av));<br><br>assert(heap-&gt;ar_ptr == av);<br>heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br><br>    if (!have_lock)<br>      __libc_lock_unlock (av-&gt;mutex);<br>  &#125;<br>  /*<br>    If the chunk was allocated via mmap, release via munmap().<br>  */<br><br>  else &#123;<br>    munmap_chunk (p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7e3518d6-98b4-4e17-9935-d0df60d52158'><img src="blob:https://tokameine.top/7e3518d6-98b4-4e17-9935-d0df60d52158"></p>
<h1 id="libc-free："><a href="#libc-free：" class="headerlink" title="__libc_free："></a>__libc_free：</h1><h2 id="分支1：free-0"><a href="#分支1：free-0" class="headerlink" title="分支1：free(0)"></a>分支1：free(0)</h2><blockquote>
<p>        函数直接返回</p>
</blockquote>
<h2 id="分支2：该内存由mmap分配"><a href="#分支2：该内存由mmap分配" class="headerlink" title="分支2：该内存由mmap分配"></a>分支2：该内存由mmap分配</h2><blockquote>
<p>         通过些许安全性检查后调用munmap_chunk将内存块返回给系统</p>
</blockquote>
<h2 id="分支3：否则"><a href="#分支3：否则" class="headerlink" title="分支3：否则"></a>分支3：否则</h2><blockquote>
<p>        调用_int_free将内存块释放</p>
</blockquote>
<p>        （注：在该函数中会将指针参数p指向mem-0x10，再将该指针传入_int_free）</p>
<h1 id="int-free："><a href="#int-free：" class="headerlink" title="_int_free："></a>_int_free：</h1><p>        首先进行一些必要的安全性检查</p>
<h2 id="分支1：使用Tcache"><a href="#分支1：使用Tcache" class="headerlink" title="分支1：使用Tcache"></a>分支1：使用Tcache</h2><blockquote>
<p>        使用chunksize获取p的size，再用csize2tidx通过size定位到索引tc_idx</p>
<p>        如果tc_idx合法，将指针e指向 p+0x10</p>
<p>        判断e-&gt;key是否为tcache。若是，进入循环，遍历整个Tcache，若存在相同chunk则crash</p>
<p>        否则通过安全性检查</p>
<p>        如果该Tcache Bin链表未满，则调用tcache_put将chunk放入Tcache Bin中</p>
<p>        函数结束</p>
</blockquote>
<h2 id="分支2：符合Fast-Bins范围-且-不与Top-chunk相邻"><a href="#分支2：符合Fast-Bins范围-且-不与Top-chunk相邻" class="headerlink" title="分支2：符合Fast Bins范围 且 不与Top chunk相邻"></a>分支2：符合Fast Bins范围 且 不与Top chunk相邻</h2><blockquote>
<p>        获取对应的链表索引idx，表头fb，将fd中储存chunk作为old</p>
<p>        将p作为新的头节点，old将成为第二个节点</p>
</blockquote>
<h2 id="分支3：不由mmap分配-且-不属于-Fast-Bins范围"><a href="#分支3：不由mmap分配-且-不属于-Fast-Bins范围" class="headerlink" title="分支3：不由mmap分配 且 不属于 Fast Bins范围"></a>分支3：不由mmap分配 且 不属于 Fast Bins范围</h2><blockquote>
<p>        nextchunk指向p的下一个chunk，nextsize为其size</p>
<p>        检查p是否为链表的第一个节点，nextchunk不应超出合法地址，且nextsize的P标记应被置1，否则均会crash</p>
<p>        如果chunk p的P标记被置0，则向上一个块合并，将合并后的块作为p，对其执行unlink_chunk</p>
</blockquote>
<h3 id="分支3-1：如果下一个chunk不是Top-chunk"><a href="#分支3-1：如果下一个chunk不是Top-chunk" class="headerlink" title="分支3.1：如果下一个chunk不是Top chunk"></a>分支3.1：如果下一个chunk不是Top chunk</h3><blockquote>
<p>        标记其P位为0，表示p已经被释放。如果该块此前已经处于被释放状态，那么还会再向该块进行合并，并用unlink_chunk将其摘下</p>
<p>        否则，只是将P位清零</p>
</blockquote>
<h2 id="分支4：其他"><a href="#分支4：其他" class="headerlink" title="分支4：其他"></a>分支4：其他</h2><p>        将bck作为Unsorted Bin的表头，fwd为第一个节点</p>
<p>        进行安全性检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fwd-&gt;bk != bck<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/5f57c51d-2a4b-4cf6-8898-52b722f91bcf'><img src="blob:https://tokameine.top/5f57c51d-2a4b-4cf6-8898-52b722f91bcf"></p>
<p>         将p挂入Unsorted Bin的第一个节点</p>
<p>        如果p的size属于Large Bin，还要将fd_nextsize与bk_nextsize置NULL</p>
<h2 id="分支5：否则-即与Top-chunk相邻时"><a href="#分支5：否则-即与Top-chunk相邻时" class="headerlink" title="分支5：否则(即与Top chunk相邻时)"></a>分支5：否则(即与Top chunk相邻时)</h2><blockquote>
<p>        将p与Top chunk合并</p>
</blockquote>
<h2 id="分支6：当释放的chunk极大时"><a href="#分支6：当释放的chunk极大时" class="headerlink" title="分支6：当释放的chunk极大时"></a>分支6：当释放的chunk极大时</h2><p>        指size大于FASTBIN_CONSOLIDATION_THRESHOLD时采用的分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/bd172462-7f0f-4628-bd25-e3cc6c16fa1f'><img src="blob:https://tokameine.top/bd172462-7f0f-4628-bd25-e3cc6c16fa1f"></p>
<p>         调用malloc_consolidate合并Fast Bin，并投放入Unsorted Bin中</p>
<h3 id="分支6-1：main-arena-且-Top-chunk大于一定值"><a href="#分支6-1：main-arena-且-Top-chunk大于一定值" class="headerlink" title="分支6.1：main_arena 且 Top_chunk大于一定值"></a>分支6.1：main_arena 且 Top_chunk大于一定值</h3><blockquote>
<p>        使用systrim缩减Top chunk</p>
<p>        (注：Top chunk的size大于trim_threshold时候触发缩减，这个值通常为128 * 1024 * 2)</p>
</blockquote>
<h3 id="分支6-2：否则"><a href="#分支6-2：否则" class="headerlink" title="分支6.2：否则"></a>分支6.2：否则</h3><blockquote>
<p>        调用heap_trim来缩减整个堆</p>
</blockquote>
<p>        （注：分支6中的两种缩减通常都是对额外开辟的堆进行缩减。一个线程在初始阶段只会有一个堆，只有当这个堆不够用时，它就会通过 sysmalloc 去开辟一个新堆，这个堆总是页对齐的，因此往往都比较大。而只有当这个新开辟的堆<strong>整个都不再被使用时</strong>，往往就会触发分支6来将整个堆释放掉）</p>
<h2 id="分支7：否则"><a href="#分支7：否则" class="headerlink" title="分支7：否则"></a>分支7：否则</h2><blockquote>
<p>        则使用munmap_chunk来强制释放该chunk</p>
</blockquote>
<p>​</p>
<p>插画ID：91567105_p0</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-10/">← 下一篇 关于如何理解Glibc堆管理器(Ⅹ——完结、补充、注释——Arena、heap_info、malloc_*)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-8/">关于如何理解Glibc堆管理器(Ⅷ——从源代码理解malloc) 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">源代码：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libc-free%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">__libc_free：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF1%EF%BC%9Afree-0"><span class="toc-number">2.1.</span> <span class="toc-text">分支1：free(0)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF2%EF%BC%9A%E8%AF%A5%E5%86%85%E5%AD%98%E7%94%B1mmap%E5%88%86%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">分支2：该内存由mmap分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF3%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">分支3：否则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int-free%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">_int_free：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF1%EF%BC%9A%E4%BD%BF%E7%94%A8Tcache"><span class="toc-number">3.1.</span> <span class="toc-text">分支1：使用Tcache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF2%EF%BC%9A%E7%AC%A6%E5%90%88Fast-Bins%E8%8C%83%E5%9B%B4-%E4%B8%94-%E4%B8%8D%E4%B8%8ETop-chunk%E7%9B%B8%E9%82%BB"><span class="toc-number">3.2.</span> <span class="toc-text">分支2：符合Fast Bins范围 且 不与Top chunk相邻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF3%EF%BC%9A%E4%B8%8D%E7%94%B1mmap%E5%88%86%E9%85%8D-%E4%B8%94-%E4%B8%8D%E5%B1%9E%E4%BA%8E-Fast-Bins%E8%8C%83%E5%9B%B4"><span class="toc-number">3.3.</span> <span class="toc-text">分支3：不由mmap分配 且 不属于 Fast Bins范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF3-1%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%8B%E4%B8%80%E4%B8%AAchunk%E4%B8%8D%E6%98%AFTop-chunk"><span class="toc-number">3.3.1.</span> <span class="toc-text">分支3.1：如果下一个chunk不是Top chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF4%EF%BC%9A%E5%85%B6%E4%BB%96"><span class="toc-number">3.4.</span> <span class="toc-text">分支4：其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF5%EF%BC%9A%E5%90%A6%E5%88%99-%E5%8D%B3%E4%B8%8ETop-chunk%E7%9B%B8%E9%82%BB%E6%97%B6"><span class="toc-number">3.5.</span> <span class="toc-text">分支5：否则(即与Top chunk相邻时)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF6%EF%BC%9A%E5%BD%93%E9%87%8A%E6%94%BE%E7%9A%84chunk%E6%9E%81%E5%A4%A7%E6%97%B6"><span class="toc-number">3.6.</span> <span class="toc-text">分支6：当释放的chunk极大时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-1%EF%BC%9Amain-arena-%E4%B8%94-Top-chunk%E5%A4%A7%E4%BA%8E%E4%B8%80%E5%AE%9A%E5%80%BC"><span class="toc-number">3.6.1.</span> <span class="toc-text">分支6.1：main_arena 且 Top_chunk大于一定值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF6-2%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.6.2.</span> <span class="toc-text">分支6.2：否则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF7%EF%BC%9A%E5%90%A6%E5%88%99"><span class="toc-number">3.7.</span> <span class="toc-text">分支7：否则</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>