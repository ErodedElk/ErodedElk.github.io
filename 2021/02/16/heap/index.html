<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>优先队列(堆) | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>优先队列(堆)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-02-16T14:36:03.000Z" id="date"> 2021-02-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.999Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>    <strong>学习过程跟进《数据结构与算法分析》，主要代码大致与树种例程相同，若有疏漏或错误，请务必提醒我，我会尽力修正。</strong></p>
<p>目录：</p>
<ul>
<li><strong>[toc]优先队列(堆)</strong></li>
<li><strong>最小堆HeapMin</strong></li>
<li><strong>左式堆Leftist Heap</strong></li>
<li><strong>二项队列Binomial-Queue</strong></li>
</ul>
<p><strong>优先队列(堆)：</strong></p>
<p>    一种能够赋予每个节点不同优先级的数据结构。有“最小堆”和“最大堆”两种基础类型。实现的根本原理有两种，一种是“数组”，另外一种则是“树”(大多是指二叉树)。但在实现最大&#x2F;最小堆时，使用数组更优。因为堆并不像树那样需要很多功能支持，自然也不需要用到指针(当然，高级结构还是会用到的，比如“左式堆”等，之后将有实现)。</p>
<p>    如果您此前已经看过堆的基本结构概念，那应该大致明白最小堆长什么样了，基础结构的堆就是一颗符合特定条件的二叉树罢了。</p>
<p>    特殊性质：对每一个节点的关键字，都要比其子树中的任何一个关键字都小(任何一个节点的关键字是其子树以及其自身中最小的那个)。这个条件是针对最小堆的，最大堆则反之。</p>
<p>    因为基础的堆结构只支持“插入”和“最小值出堆”这两种操作。在处理任务进程的时候，对应的也有“增加任务”和“处理任务量最少的任务”这种解释，或许这样更容易让人明白堆的作用。而最大堆则可将其解释为“处理优先级最高的任务”。(当然，实际上还需要对任务量&#x2F;优先级进行变动，包括增&#x2F;减关键字的大小这样的操作，自然也能够进行特定关键字的删改了)。</p>
<h2 id="最小堆HeapMin："><a href="#最小堆HeapMin：" class="headerlink" title="最小堆HeapMin："></a><strong>最小堆HeapMin：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//-----------声明部分----------//<br>struct HeapStruct;<br>struct ElementType;<br>typedef struct HeapStruct* PriorityQueue;//堆指针<br>#define MinElements 1<br>#define Max 99999<br>bool IsEmpty(PriorityQueue H);//是否为空堆<br>bool IsFull(PriorityQueue H);//是否为满堆<br> <br>void Insert(ElementType key, PriorityQueue H);//插入关键字<br>ElementType DeleteMin(PriorityQueue H);//删除最小值<br>PriorityQueue BuiltHeap(ElementType* Key, int N);//成堆<br>void PercolateDown(int i, PriorityQueue H);<br>PriorityQueue Initialize(int MaxElements);//建空堆<br>void IncreaseKey(int P, int Add, PriorityQueue H);//增加关键字值<br>void DecreaseKey(int P, int sub, PriorityQueue H);//降低关键字值<br>void Delete(int P, PriorityQueue H);//删除关键字<br>struct ElementType//关键字数据块<br>&#123;<br>int Key;<br>&#125;;<br>struct HeapStruct//堆结构<br>&#123;<br>int Capacity;<br>int Size;<br>ElementType* Element;<br>&#125;;<br>ElementType MinData;//最小数据块<br>//-----------声明部分----------//<br></code></pre></td></tr></table></figure>

<p>     看注释大概就能明白了。但值得说明的是，因为最终是通过数组来实现的，而数组必须先行规定好它的尺寸，所以建立的堆也必须面临“被装满”的情况(当然，用new函数重新开辟也行，谁让这是C++呢)</p>
<p><strong>建立空堆Initialize：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue Initialize(int MaxElements)//形参为堆的总节点数<br>&#123;<br>PriorityQueue H;<br>if (MaxElements &lt; MinElements)<br>return NULL;<br>H = new HeapStruct;<br>H-&gt;Element = new ElementType[MaxElements + 1];<br>H-&gt;Capacity = MaxElements;<br>H-&gt;Size = 0;<br>H-&gt;Element[0] = MinData;<br>return H;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    注：我并没有把new函数失败的情形写出来，但那些内容并不影响对数据结构的学习。对这方面有需求请自行添加。</p>
<p>    注：MinData是一个最小数据块，同时也只是一个冗余块。在之后的任何操作中，都不会对存有MinData的Element[0]进行任何操作。只是通过占用[0]节点，使得之后的操作变得更加可行了。需要注意的是，这个0节点并不是根节点(当时没绕过来，在这里浪费了太多时间)。</p>
<p><strong>插入Insert：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void Insert(ElementType key, PriorityQueue H)<br>&#123;<br>int i;<br>if (IsFull(H))<br>exit;<br>++H-&gt;Size;<br>for (i = H-&gt;Size; H-&gt;Element[i / 2].Key &gt; key.Key; i /= 2)<br>H-&gt;Element[i] = H-&gt;Element[i / 2];<br>H-&gt;Element[i] = key;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    for循环中的判断方式被称之为“上滤”，也是这种方式得以实现的重要规则。对于根节点从 Element[1] 开始的这个堆，Element[i]的左儿子必然是Element[2*i]，除非它没有左儿子。</p>
<p>    回到这个函数，因为int型会自动取整舍弃小数位，所以 Element[i&#x2F;2] 必定指向 Element[i] 的父节点，不论它是不是单数。</p>
<p>    而这个寻路条件则是在不断的比较子节点与父节点的大小。流程如下：</p>
<p>    ①先将新节点放在数组的最后一位(并不是指数组的末尾，而是按照顺序装填的最后一位)，然后比较它与父节点的大小。</p>
<p>    ②若它小于父节点，那么将其与父节点交换位置，此时 i&#x2F;&#x3D;2 ， Element[i]再次指向它。</p>
<p>    ③继续相同操作。直到父节点小于它，或是没有父节点为止。</p>
<p>    不得不承认，这种操作很棒。因为它让函数的最坏时间复杂度降到了logN(因为实际操作中，不一定都要上履到最顶层)。</p>
<p><strong>最小值出堆DeleteMin：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ElementType DeleteMin(PriorityQueue H)<br>&#123;<br>int i, Child;<br>ElementType MinElement, LastElement;<br>if (IsEmpty(H))<br>return H-&gt;Element[0];<br>MinElement = H-&gt;Element[1];<br>LastElement = H-&gt;Element[H-&gt;Size--];<br>for (i = 1; i * 2 &lt;= H-&gt;Size; i = Child)<br>&#123;<br>Child = 2 * i;<br>if (Child != H-&gt;Size &amp;&amp; H-&gt;Element[Child + 1].Key &lt; H-&gt;Element[Child].Key)<br>Child++;<br>if (LastElement.Key &gt; H-&gt;Element[Child].Key)<br>H-&gt;Element[i] = H-&gt;Element[Child];<br>else<br>break;<br>&#125;<br>H-&gt;Element[i] = LastElement;<br>return MinElement;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    同“上滤‘相近，在这个函数中运用的方法为”下滤“。简要谈谈过程吧：</p>
<p>    ①声明各种各样的变量，并判断H是不是一个空堆。</p>
<p>    ②将堆中最小的值Element[1]拷贝到MinElement中，同理将最后一个值放进LastElement中。(这个Element[1]将会被新值替换，而这个LastElement则要用来填补某个空缺)</p>
<p>    ③从i&#x3D;1开始，Child则指向根节点Element[1]的左儿子，同时比较根节点的左右儿子大小，将Child指向小的那一个，我是说，H-&gt;Element[Child]会指向小的那个。</p>
<p>    ④然后再判断最后一个数和 H-&gt;Element[Child] 的大小。如果最后一个比较大，那就把父节点Element[i]用它的子节点替代。</p>
<p>    ⑤重新回到循环，现在的 i 已经指向了本来的子节点，并开始重复上述从③开始的操作，直到当前Element[i]的子节点中较小的那一个Element[Child]比最后一个节点的值要小为止。</p>
<p>   ⑥将现在的父节点Element[i]用最后一个替代。</p>
<p>    或许从途中就会觉得有些怪异，这究竟是个怎么回事。</p>
<p>    事实上，经过上述操作直到步骤⑤，最终的Element[i]将会指向某片叶子，这片叶子是根据其上的操作逐层筛选出来的。最后通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">H-&gt;Element[i] = LastElement;<br></code></pre></td></tr></table></figure>

<p>    将这个位置用最后一位来替代，并返回了刚开始拷贝好的最小值，实现了删除最小值的操作。当然，实际上，这个数组的最后一位仍然保存着某个关键字，但并不需要太担心，因为经过了H-&gt;Size–，当下次插入节点的时候，遇到合适的数值，将会直接把这个位置覆盖掉。并且，也如您所见，所有的操作单元均在[1，H-&gt;Size]的范围内，对于范围外的元素，即便它还留有关键字，也不会再造成影响了。</p>
<p><strong>成堆BuiltHeap：</strong></p>
<p>    通常，我们将会导入一整串数组，然后再利用它们来生成一个堆结构。实际上，当然也可以通过Insert来一个个安置。以下是没套用Insert的例程，主要通过递归来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue BuiltHeap(ElementType *Key,int N)//Key指向将要导入的数据数组<br>&#123;<br>int i;<br>PriorityQueue H;<br>H = Initialize(N);<br>for (i = 1; i &lt;= N; i++)<br>H-&gt;Element[i] = Key[i - 1];<br>H-&gt;Size = N;<br>for (i = N / 2; i &gt; 0; i--)<br>PercolateDown(i, H);<br>return H;<br>&#125;<br>void PercolateDown(int i,PriorityQueue H)<br>&#123;<br>int MinSon;<br>ElementType Tmp;<br>if (i &lt;( H-&gt;Size / 2))<br>&#123;<br>if (2 * i + 1 &lt;= H-&gt;Size &amp;&amp; H-&gt;Element[2 * i].Key &gt; H-&gt;Element[2 * i + 1].Key)<br>MinSon = 2 * i+1;<br>else<br>MinSon = 2 * i;<br>if (H-&gt;Element[i].Key &gt; H-&gt;Element[MinSon].Key)<br>&#123;<br>Tmp = H-&gt;Element[i];<br>H-&gt;Element[i] = H-&gt;Element[MinSon];<br>H-&gt;Element[MinSon] = Tmp;<br>&#125;<br>PercolateDown(MinSon, H);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    ①声明，并建立空堆，然后把所有元素全都不按规则的塞进去，再指定好H-&gt;Size。</p>
<p>    ②从最后一个具有“父节点”性质的节点进入下滤函数。过程与DeleteMin相近：选出子节点中小的，再与父节点比较，将较小的那一个放在父节点的位置，而较大的那一个下沉到子节点。并且再次进入这个函数。</p>
<p>    ③实现全部的过滤之后，返回H。</p>
<p>    递归在这里是非常好用的。在BuiltHeap函数中，for循环实现了对每一个具有“父节点”性质的节点进行下滤(这是根据数组节点的排列顺序实现的，父节点必然都能按顺序排下去)。而递归则实现了对整条路径的下滤操作。假设从根节点开始下滤，那么必然会进入PercolateDown(MinSon，H)中，将较小的那个子节点作为本次递归的新的父节点同样进行下滤。最终实现了堆序(Heap order)。</p>
<p>    剩下的就是一些无关紧要的函数了，看看思路就行。因为是我自己写的，可能会有错误，如有发现，还请务必告知我，我会尽量修正。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void DecreaseKey(int P,int sub,PriorityQueue H)//降低关键字的值<br>&#123;<br>H-&gt;Element[P].Key -= sub;<br>int i;<br>ElementType Tmp;<br>for (i = P; H-&gt;Element[i / 2].Key &gt; H-&gt;Element[i].Key; i /= 2)<br>&#123;<br>Tmp = H-&gt;Element[i / 2];<br>H-&gt;Element[i / 2] = H-&gt;Element[i];<br>H-&gt;Element[i] = Tmp;<br>&#125;<br>&#125;<br>void IncreaseKey(int P, int Add, PriorityQueue H)//提高关键字的值<br>&#123;<br>int i,Child;<br>ElementType Tmp;<br>H-&gt;Element[P].Key += Add;<br>for (i = P; 2 * i &lt;= H-&gt;Size; i = Child)<br>&#123;<br>Child = 2 * i;<br>if (Child != H-&gt;Size &amp;&amp; H-&gt;Element[Child + 1].Key &lt; H-&gt;Element[Child].Key)<br>Child++;<br>if (H-&gt;Element[i].Key &gt; H-&gt;Element[Child].Key)<br>&#123;<br>Tmp = H-&gt;Element[Child];<br>H-&gt;Element[Child] = H-&gt;Element[i];<br>H-&gt;Element[i] = Tmp;<br>&#125;<br>else<br>break;<br>&#125;<br>&#125;<br>void Delete(int P,PriorityQueue H)//删除指定关键字<br>&#123;<br>DecreaseKey(P, Max, H);<br>DeleteMin(H);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    原理同上面的其他函数一样的，建议自己实现一下。</p>
<h2 id="左式堆Leftist-Heap："><a href="#左式堆Leftist-Heap：" class="headerlink" title="左式堆Leftist Heap："></a>左式堆Leftist Heap：</h2><p>    因为基础的堆结构由数组实现，所以并不支持合并等高级操作(有办法实现，但效率并不那么理想)，为解决这些问题，左式堆提供了一些方案。</p>
<p>    左式堆同样遵守最小堆的基本堆序——任意节点的关键字值低于其子树中的所有节点，但与之不同的是，左式堆的基本结构还包含了Npl(Null path length)，即从该结点到达一个没有两个孩子的结点的最短距离。并要求：<strong>任意结点的左孩子的Npl大于或等于右孩子的Npl。</strong></p>
<p><strong>声明部分：(函数对应的作用已经写在注释里了)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//----------声明部分----------//<br>typedef struct TreeNode* PriorityQueue;//节点指针<br>struct TreeNode//节点结构<br>&#123;<br>int Element;<br>PriorityQueue Left;<br>PriorityQueue Right;<br>int Npl;//Null Path Length<br>&#125;;<br>PriorityQueue Initialize(void);//建立空堆<br>PriorityQueue Merge(PriorityQueue H1, PriorityQueue H2);//合并堆(驱动例程)<br>static PriorityQueue Merge1(PriorityQueue H1, PriorityQueue H2);//合并堆(实际例程)<br>void SwapChildren(PriorityQueue H);(交换H的左右子树)<br>PriorityQueue Insert1(int key, PriorityQueue H);//插入节点<br>bool IsEmpty(PriorityQueue H);//是否为空堆<br>PriorityQueue DeleteMin1(PriorityQueue H);//删除最小值<br>//----------声明部分----------//<br></code></pre></td></tr></table></figure>

<p><strong>建立空堆Initialize：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue Initialize(void)<br>&#123;<br>PriorityQueue H;<br>H = new TreeNode;<br>H-&gt;Left = H-&gt;Right = NULL;<br>H-&gt;Npl = 0;<br>return H;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>规定NULL的Npl为-1，则对任何一个没有两个子树的节点，其Npl为0。</p>
<p><strong>插入Insert：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue Insert1(int key, PriorityQueue H)<br>&#123;<br>PriorityQueue SingleNode;<br>SingleNode = new TreeNode;<br>SingleNode-&gt;Element = key;<br>SingleNode-&gt;Npl = 0;<br>SingleNode-&gt;Left = SingleNode-&gt;Right = NULL;<br>H = Merge(SingleNode, H);<br>return H;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    区别于最小堆中的Insert函数，这里用的是Insert1。因为Insert没有返回值，也不需要返回值，所有那样做是没有问题的；但在左式堆中，将一个元素插入空堆时，需要返回新的根节点地址，所以应有一些区别。另外，这个函数首次出现了Merge函数。关于Merge函数将会放在最后，目前权且当它是一个合并两个堆，并返回新的根节点的函数即可。(目前我个人还不会写宏定义，但如果您已经学会了，不妨试着将Insert函数写成宏定义，书上是这样建议的)</p>
<p><strong>删除最小值Delete：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue DeleteMin1(PriorityQueue H)<br>&#123;<br>if (IsEmpty(H))<br>exit;<br>PriorityQueue LeftHeap=H-&gt;Left, RightHeap=H-&gt;Right;<br>delete H;<br>return Merge(LeftHeap, RightHeap);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    因为左式堆和最小堆有着同样的结构，所以最小值同样都是根节点，所以例程非常的简洁也很清晰。已经没必要做其他解释了。</p>
<p><strong>合并堆Merge：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">PriorityQueue Merge(PriorityQueue H1, PriorityQueue H2)//驱动例程<br>&#123;<br>if (H1 == NULL)<br>return H2;<br>if (H2 == NULL)<br>return H1;<br>if (H1-&gt;Element &lt; H2-&gt;Element)<br>return Merge1(H1, H2);<br>else<br>return Merge1(H2, H1);<br>&#125;<br>static PriorityQueue Merge1(PriorityQueue H1, PriorityQueue H2)//实际例程<br>&#123;<br>if (H1-&gt;Left == NULL)<br>H1-&gt;Left = H2;<br>else<br>&#123;<br>H1-&gt;Right = Merge(H1-&gt;Right, H2);<br>if (H1-&gt;Left-&gt;Npl &lt; H1-&gt;Right-&gt;Npl)<br>SwapChildren(H1);<br>H1-&gt;Npl = H1-&gt;Right-&gt;Npl + 1;<br>&#125;<br>return H1;<br>&#125;<br>void SwapChildren(PriorityQueue H)//交换子树<br>&#123;<br>PriorityQueue Tmp;<br>Tmp = H-&gt;Left;<br>H-&gt;Left = H-&gt;Right;<br>H-&gt;Right = Tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    最后是关键的合并堆函数。Merge函数作为合并开始的<strong>入口</strong>被调用，而实现过程则放在Merge1函数中进行。SwapChildren函数是附带的，你当然也可以把它写在Merge1中。</p>
<p>    对于没有图的过程描述，我觉得实在有些难以想象。这里引用书上的例子(尽管这个例子并不方便，但在某些地方能起到很好的范例)。</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210214144402351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210214144402351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210214144419792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210214144419792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70"></p>
<p>     现在，不妨先假设根节点为3的堆为H1，另外一个为H2。现在将它们放入Merge(H1,H2)。<strong>注：以下所说的H1和H2是在不停的变动的，具体目标请以所指根节点为准。</strong></p>
<p>    经过一系列的比较，达到这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">H1-&gt;Right = Merge(H1-&gt;Right, H2);<br></code></pre></td></tr></table></figure>

<p>    ①将H1-&gt;Right指向 <strong>根节点为8的堆 与 H2 合并的结果。</strong></p>
<p>    同理，经过一系列的比较。<strong>现在，H1的根节点是6，H2的根节点是8。</strong></p>
<p>    ②再次遇到相同的情况，H1-&gt;Right指向 <strong>根节点为7的堆 与 H2(根节点为8的堆) 合并</strong>的结果。</p>
<p>    再次经过一系列的比较。现在<strong>H1的根节点是7 ，H2的根节点是8。</strong></p>
<p>    ③同上，令H1-&gt;Right 指向 H1(<strong>根节点为18的堆) 与 H2(根节点为8的堆)合并</strong> 的结果。</p>
<p>    上一行描述合并后的结果显而易见，只是将18放到了8的右儿子处罢了。然后返回新根 8 的地址。</p>
<p>    现在，③行处的H1-&gt;Right指向新根 8。即 7-&gt;8。</p>
<p>    判断Npl，并将左右子树进行一次交换。</p>
<p>    以上内容实现了 <strong>根节点为3的右子树与 根节点为6的堆</strong> 的合并过程。</p>
<p>    回到①行中方的H1-&gt;Right，其现在指向了新的根 6。判断Npl，再次旋转。</p>
<p>    合并完成。</p>
<p>    很多时候，即便我仔细地捋顺了递归操作的流程，它的可读性仍然相当糟糕……但如果不去捋顺过程，又没办法改进其操作，甚至有的时候连利用都做不到。对于我这种出入数据结构的萌新来说，可能只能多看看代码来适应这种生活吧……</p>
<h2 id="二项队列Binomial-Queue："><a href="#二项队列Binomial-Queue：" class="headerlink" title="二项队列Binomial Queue："></a><strong>二项队列Binomial Queue：</strong></h2><p>(以下不只是简介，还包括了一些个人理解，如果您学习过程遇到什么麻烦，不妨先看看)</p>
<p>    根据书上的描述，似乎是左式堆的一种改良版。虽然左式堆和斜堆每次操作都花费logN时间，且有效支持了插入、合并与最小值出堆，但其每次操作花费常数平均时间来支持插入。而在二项队列中。每次操作的最坏情况运行时间为logN，而插入操作平均花费常数时间。这算是在一定程度上优化了斜堆。</p>
<p>    其结构就如名字一样，是“二项”。我们可以将其简单理解为“上项”和“下项”(这只是为了方便理解罢了，实际运用中自然不存在这种称呼，但我总要找个名字给它，不然描述起来还挺费劲的)。实际的样子当您看到图片的时候就能明白，我为什么要那样称呼它们了。</p>
<p>    并且，二项队列的样子也特殊一点。它是一种被称之为“森林”的结构，形象的说，它包括了许多中不同高度的二叉树(但每一种高度的树只有一颗，一旦出现两颗同样高度，它们就会被立刻合并成新的高度，这也是特色之一)。<strong>并且，它也有最小堆的特性</strong>，<strong>关键字的数值随高度递减，每一个根节点的值都比子树中任何一个节点的关键字小。</strong></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210215200618225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210215200618225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70"></p>
<p>    如图，这便算是一个简单的二项队列结构。上面是一个数组，数组中存放有指针。而下面的则是许多的树(剥去数组，你看到的才是真正的二项队结构，数组只是从计算机中实现的一种方法罢了。并且，B3中的那颗树和我们实际实现的有些不同，具体的情况后面会写。但目前，权且当它就长这个样吧(或许这才是本该有的结构，但计算机不方便这样做，所以之后会有另外一个实现的样子))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//-------------声明部分---------------//<br>typedef struct BinNode* Position;//位置指针<br>typedef struct BinNode* BinTree;//树指针<br>typedef struct Collection* BinQueue;//队列指针<br>#define MaxTrees 5 //数组的长度，也同时规定了二叉树的高度<br>#define Capacity ((1&lt;&lt;MaxTrees)-1)//容量是2^0+2^1+......+2^(MAXTREES-1)<br>BinQueue Initialize(void);//建立空队列<br>BinTree CombineTrees(BinTree T1, BinTree T2);//合并高度相同的树<br>BinQueue Merge(BinQueue H1, BinQueue H2);//合并两个队列<br>int DeleteMin(BinQueue H);<br>void Insert(int X, BinQueue H);<br>int IsEmpty(BinQueue H);<br> <br>struct  BinNode //树节点<br>&#123; <br>int Key;<br>Position LeftChild;<br>Position NextSibling;<br>&#125;;<br>struct Collection //森林<br>&#123;<br>int CurrentSize; //已容纳量<br>BinTree TheTrees[MaxTrees];//容纳二叉树的数组<br>&#125;;<br>//-------------声明部分---------------//<br></code></pre></td></tr></table></figure>

<p>    因为书上没有说明一些变量的作用，所以我自己绕了一会，在这里顺便说明一下吧：</p>
<p>    CurrentSize：已容纳量。指的是整个队列的节点数。比方说上图中的的容纳量就是15(对应总共15个节点)。</p>
<p>    Capacity：队列容量。指的是一个二项队列结构最高能容纳的节点数。比方说上图的队列容量就是(B3——15)(也因为我画的不太好，所以B3看起来高度不像3，但会意一下就行，实在不行去找找其他大佬的图也行)。(但写法是一个等比数列求和结果，很明显，每个高度的节点数是等比增加的)</p>
<p>    LeftChild&#x2F;NextSibling：连接指针。这个东西具体到后面看见实际的图片时，自然会懂。</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/2021021520402367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/2021021520402367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70"></p>
<p><strong>这幅图为实际做出的结构，以下说明的时候请经常对照以方便理解。高度相同的节点我已经尽量画在同一水平线了，也如您所见，B1没有节点，B3的高度确实是3(建立在B0处的节点高度设定为0的基础上)。</strong></p>
<p><strong>关于LeftChild和NextSibling指针已经标出(取首字母表示)。</strong></p>
<p><strong>建立队列Initialize：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">BinQueue Initialize(void)<br>&#123;<br>BinQueue H = new Collection;<br>for (int i = 0; i &lt; MaxTrees; i++)<br>H-&gt;TheTrees[i] = NULL;<br>H-&gt;CurrentSize = 0;<br>return H;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    没什么好说的，但因为书上没有，加上我当时不太明白几个参数的作用，所以绕了好一会，贴在这里以防万一。(至少如果不明白CurrentSize是什么，就没办法让它等于0了……)</p>
<p><strong>插入节点Insert：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void Insert(int X, BinQueue H)<br>&#123;<br>BinQueue temp = initialize();<br>temp-&gt;CurrentSize = 1;<br>temp-&gt;TheTrees[0] = new BinNode;<br>temp-&gt;TheTrees[0]-&gt;Key = X;<br>temp-&gt;TheTrees[0]-&gt;LeftChild = NULL;<br>temp-&gt;TheTrees[0]-&gt;NextSibling = NULL;<br>Merge(H, temp);<br>delete temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    从这个函数可以看出，所谓的插入节点，实际上是将新节点当作了一个只有B0结构的二项队列，然后将其合并。目前，我们只需要将Merge函数视作一个合并二项队列的函数即可，关于这个函数会在下面讲到。</p>
<p><strong>最小值出队DeleteMin：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int DeleteMin(BinQueue H)<br>&#123;<br>int i, j;<br>int MinTree;<br>BinQueue DeleteQueue;<br>Position DeleteTree, OldRoot;<br>int MinItem;//ElementType<br> <br>if (IsEmpty(H))<br>return NULL;<br> <br>MinItem=INFINITY;<br>for (i = 0; i &lt; MaxTrees; i++)<br>&#123;<br>if (H-&gt;TheTrees[i] &amp;&amp; H-&gt;TheTrees[i]-&gt;Key &lt; MinItem)<br>&#123;<br>MinItem = H-&gt;TheTrees[i]-&gt;Key;<br>MinTree = i;<br>&#125;<br>&#125;<br>DeleteTree = H-&gt;TheTrees[MinTree];<br>OldRoot = DeleteTree;<br>DeleteTree = DeleteTree-&gt;LeftChild;<br>delete OldRoot;<br> <br>DeleteQueue = initialize();<br>DeleteQueue-&gt;CurrentSize = (1 &lt;&lt; MinTree) - 1;<br>for (j = MinTree - 1; j &gt;= 0; j--)<br>&#123;<br>DeleteQueue-&gt;TheTrees[j] = DeleteTree;<br>DeleteTree = DeleteTree-&gt;NextSibling;<br>DeleteQueue-&gt;TheTrees[j]-&gt;NextSibling = NULL;<br>&#125;<br>H-&gt;TheTrees[MinTree] = NULL;<br>H-&gt;CurrentSize -= (DeleteQueue-&gt;CurrentSize + 1);<br>Merge(H, DeleteQueue);<br>return MinItem;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    函数本身不算难，但有些冗长。姑且做些说明，但自己写出来是最有效的理解方式。</p>
<p>    ①一系列将要用到的声明。其中MinItem是将要出堆的Key(因为我设定的Key是int类型)，再将MinItem设定为无限大(Infinity)。</p>
<p>    ②遍历队列数组，选出队列中最小的关键字节点。用MinTree标记其对应的索引，MinItem拷贝其数值。</p>
<p>    ③将标记好的最小值节点拷贝到DeleteTree与OldRoot，再把DeleteTree指向其左儿子。删除最小值节点。</p>
<p>    ④将刚才拷贝的左儿子新建到另外一个队列里，设定好相关的数值，最后把两个队列合并。</p>
<p>    值得注意的是，for循环是将失去了根节点的堆重新整合到新队列中。这个操作看起来有些抽象，但实际上是可行的。不妨带入B3节点来试探一下，删去了根节点后，它被拆分成了B0,B1,B2三棵树进入新队列了。最开始的那幅图其实很好的说明了问题，那张图的B3有这明显的复制粘贴B2的痕迹，但事实就如描述一样，它们真的就是像复制粘贴一样的结构。所有你可以试着去拆分一下，Bk去掉根节点必然会变成B0,B1,B2……Bk-1颗树。</p>
<p>    以及另外一个注意点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">H-&gt;CurrentSize -= (DeleteQueue-&gt;CurrentSize + 1);<br></code></pre></td></tr></table></figure>

<p>    其实不太必要在这个地方纠结太久，但以防万一还是说明一下。这行代码减去的数量将在Merge函数中补齐，先后的总节点数差距确实是 1 ,可以自行验证一下。如果缺乏这条函数，Merge将会导致CurrentSize与实际不符。（之所以减去那个量，是因为Merge会补回DeleteQueue-&gt;CurrentSize的数量，和这段语句正好相差 1 ）</p>
<p><strong>合并队列Merge：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">BinTree CombineTrees(BinTree T1,BinTree T2)<br>&#123;<br>if (T1-&gt;Key &gt; T2-&gt;Key)<br>return CombineTrees(T2, T1);<br>T2-&gt;NextSibling = T1-&gt;LeftChild;<br>T1-&gt;LeftChild = T2;<br>return T1;<br>&#125;<br>BinQueue Merge(BinQueue H1,BinQueue H2)<br>&#123;<br>BinTree T1, T2, Carry = NULL;<br>int i,j;<br>if (H1-&gt;CurrentSize + H2-&gt;CurrentSize &gt; Capacity)<br>exit;<br>H1-&gt;CurrentSize += H2-&gt;CurrentSize;<br>for (i = 0, j = 1; j &lt;= H1-&gt;CurrentSize; i++, j *= 2)<br>&#123;<br>T1 = H1-&gt;TheTrees[i]; T2 = H2-&gt;TheTrees[i];<br>switch(!!T1+2*!!T2+4*!!Carry)<br>&#123;<br>case 0://No tree<br>case 1://only h1<br>break;<br>case 2://only h2<br>H1-&gt;TheTrees[i] = T2;<br>H2-&gt;TheTrees[i] = NULL;<br>break;<br>case 4://only carry<br>H1-&gt;TheTrees[i] = Carry;<br>Carry = NULL;<br>break;<br>case 3://h1 and h2<br>Carry = CombineTrees(T1, T2);<br>break;<br>case 5://h1 and carry<br>Carry = CombineTrees(T1,Carry);<br>H1-&gt;TheTrees[i] = NULL;<br>break;<br>case 6://h2 and carry<br>Carry = CombineTrees(T2,Carry);<br>H2-&gt;TheTrees[i] = NULL;<br>break;<br>case 7://h1 and h2 and carry<br>H1-&gt;TheTrees[i] = Carry;<br>Carry = CombineTrees(T1,T2);<br>H2-&gt;TheTrees[i] = NULL;<br>break;<br>&#125;<br>&#125;<br>return H1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    最后是关键性的合并函数Merge。这个例程还需要用到CombineTrees函数，用于合并高度相同的树。</p>
<p>    函数本身并不是很复杂，用了一个switch来判断情况，这个方式相当有趣，是很值得学习的一种想法。(!!符号似乎是用来判断存在性的(我不太清楚这样描述对不对，所有用“似乎”)，若值存在且非0，则返回1，否则返回0)。</p>
<p>    以及比较有趣的是for循环的判断条件 <strong>j&lt;&#x3D;H1-&gt;CurrentSize 和 j*&#x3D;2</strong></p>
<p>    看起来有些抽象，解释起来也是。</p>
<p>    现在的H1-&gt;CurrentSize已经是合并结束后的总节点数量了，而这个数量直接关系到for循环需要抵达哪一个高度的数组格。(比如说，我的数组最高能到B20，但现在根本没有那么多树需要存放，最高的树高度只到B5，那如果全都扫一遍，岂不是浪费了很多时间？)</p>
<p>    所有才有 j*&#x3D;2这个条件来制约。如您所见，每个高度的节点数实际上是固定的 2^Bk(2的Bk次方，k指高度，如B0,B1等)。这就涉及到了一些数学关系，所有我就不写这了。只需要捋一捋，我想很快就会发现这神奇的操作(如果最高到B5，那这个for循环进行4次之后，它的 j 就会超出范围导致for循环终止)。</p>
<p>    流程其实没必要细讲了，函数写的很清楚了，注释也有，笔记的目的已经达成了，那就到这吧。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/02/17/sqlinject/">← Next SQL注入相关</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/02/11/hash/">散列Hash Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86HeapMin%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">最小堆HeapMin：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%BC%8F%E5%A0%86Leftist-Heap%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">左式堆Leftist Heap：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97Binomial-Queue%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">二项队列Binomial Queue：</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>