<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>加壳原理及实现流程与导入表结构分析 | TokameinE - 雨声淅淅沥沥，犬吠永不止息</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('/img/bg.jpg');
  --light-background: url('/img/91110244_p0.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>加壳原理及实现流程与导入表结构分析</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2021-05-29T11:45:12.000Z" id="date"> 2021-05-29</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-12-29T04:50:35.008Z" id="updated"> 2024-12-29</time></div></span></div></div><hr><div id="post-content"><p><strong>封面ID :</strong> 89322214</p>
<p><strong>前言：</strong></p>
<p>    笔者在学习制作软件外壳之前，一直对这种技术抱有过于简单的看法——即所谓的壳就是将代码段加密之后，往新节区写入解密代码并让OEP转为新节区处。</p>
<p>    总体来说，这种解释并没有什么问题；但这种认识却是非常片面也过于简单的，以至于在实现的过程中接连发生了许多难以预料的问题。这些问题将在本篇下方逐一解释。</p>
<p>    PE文件包括exe、dll、sys等多种类型，笔者只在这里实现EXE可执行文件的程序壳。尽管这相较于DLL文件更加简单，但也足矣说明很多问题了。</p>
<p>    笔者会用代码和实操混合起来演示。</p>
<p><strong>正文：</strong></p>
<p>    首先，先大致复习一下PE文件结构中一些和壳相关性较强的参数吧(详细定义不再赘述)。</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529170452898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529170452898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/7e00cdf2-b4cd-462d-a878-4e3d78892699"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">WORD MZSignature；<br>DWORD Signature；<br>WORD NumberOfSections；<br>DWORD AddressOfEntryPoint；<br>DWORD SizeOfCode；<br>DWORD BaseOfCode；<br>DWORD BaseOfData；<br>DWORD ImageBase；<br>DWORD SectionAlignment；<br>DWORD FileAlignment；<br>DWORD SizeOfImage；<br>struct IMAGE_DATA_DIRECTORY_ARRAY DataDirArray；<br>struct DLL_CHARACTERISTICS DllCharacteristics；<br>//不代表其他参数不会被应用<br></code></pre></td></tr></table></figure>

<p>    还需要提一句的是，所有Windows系统下的PE文件，要想执行都需要经过<strong>“PE装载器”</strong>来完成初始化和加载入内存的操作。这些PE文件结构中的参数就是做给装载器看的，只有确切告诉装载器一些数据，它才能将文件正确的加载入内存并完成一些其他的工作。</p>
<p><strong>以下图程序为范例：</strong></p>
<p>    (这是一个比较特殊的范例，它<strong>只有三个节区</strong>，笔者为此碰了不少壁)</p>
<p>    我们先走一遍基本流程，看看常规的操作是什么。</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529170432972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529170432972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//读取待加壳文件<br>HANDLE hFile = NULL;<br>HANDLE hMap = NULL;<br>LPVOID lpBase = NULL;<br><br>    hFile = CreateFile(FILENAME, GENERIC_READ  GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);<br>    hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, 0);<br>    lpBase = MapViewOfFile(hMap, FILE_MAP_READ  FILE_MAP_WRITE, 0, 0, 0);<br></code></pre></td></tr></table></figure>

<p>    我将上面的三个变量设为全局变量以方便其他函数中也能够调用，通过WindowsApi里的函数实现映射，此时，lpBase将指向文件的开头(MZ签名)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//验证该文件是否为PE文件 <br>   PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBase;<br>    PIMAGE_NT_HEADERS pNtHeader = NULL;<br>    //PE文件验证，判断e_magic是否为MZ<br>    if (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)<br>    &#123;<br>        UnmapViewOfFile(lpBase);<br>        CloseHandle(hMap);<br>        CloseHandle(hFile);<br>        return 0;<br>    &#125;<br>    //根据e_lfanew来找到Signature标志位<br>    pNtHeader = (PIMAGE_NT_HEADERS)((BYTE*)lpBase + pDosHeader-&gt;e_lfanew);<br>    //PE文件验证，判断Signature是否为PE<br>    if (pNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE)<br>    &#123;<br>        UnmapViewOfFile(lpBase);<br>        CloseHandle(hMap);<br>        CloseHandle(hFile);<br>        return 0;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>    笔者一度以为这种验证方法是否有些拘谨，但这一部分在实际操作中并不会有什么问题，因为PE装载器也是这样来识别文件的；这意味着，那些压缩文件头的壳即便将文件头修改得面目全非，也仍然能被识别成PE文件，因此多种壳的嵌套似乎就并没有那么不可能了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//声明一个指向“新节区头”的指针pTmpSec<br>    int nSecNum = pNtHeader-&gt;FileHeader.NumberOfSections;<br>    DWORD dwFileAlignment = pNtHeader-&gt;OptionalHeader.FileAlignment;<br>    DWORD dwSecAlignment = pNtHeader-&gt;OptionalHeader.SectionAlignment;<br>    PIMAGE_SECTION_HEADER pSecHeader = (PIMAGE_SECTION_HEADER)((DWORD) &amp; (pNtHeader-&gt;OptionalHeader) + pNtHeader-&gt;FileHeader.SizeOfOptionalHeader);<br>    PIMAGE_SECTION_HEADER pTmpSec = pSecHeader + nSecNum;<br></code></pre></td></tr></table></figure>

<p>    节区头是一个固定宽度的结构体，在“windows.h”中可以通过<strong>PIMAGE_SECTION_HEADER</strong>来直接声明(该文件头也包括一系列的PE文件头结构)。</p>
<p>    而按照PE文件的结构，Nt头的下面就是节区头，代码逻辑已经足够清晰了便不再赘述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _IMAGE_SECTION_HEADER &#123;<br>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];<br>    union &#123;<br>            DWORD   PhysicalAddress;<br>            DWORD   VirtualSize;<br>    &#125; Misc;<br>    DWORD   VirtualAddress;<br>    DWORD   SizeOfRawData;<br>    DWORD   PointerToRawData;<br>    DWORD   PointerToRelocations;<br>    DWORD   PointerToLinenumbers;<br>    WORD    NumberOfRelocations;<br>    WORD    NumberOfLinenumbers;<br>    DWORD   Characteristics;<br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">/*初始化“新节区头”的各项参数*/  <br><br>char szSecName[] = &quot;.toka&quot;;<br><br>  //拷贝节区名称<br>    strncpy((char*)pTmpSec-&gt;Name, szSecName, 7);<br><br>    //节的内存大小<br>    pTmpSec-&gt;Misc.VirtualSize = AlignSize(nSecSize, dwSecAlignment);<br><br>    //节的内存起始位置<br>    pTmpSec-&gt;VirtualAddress = pSecHeader[nSecNum - 1].VirtualAddress + AlignSize(pSecHeader[nSecNum - 1].Misc.VirtualSize, dwSecAlignment);<br><br>    //节的文件大小<br>    pTmpSec-&gt;SizeOfRawData = AlignSize(nSecSize, dwFileAlignment);<br><br>    //节的文件起始位置<br>    pTmpSec-&gt;PointerToRawData = pSecHeader[nSecNum - 1].PointerToRawData + AlignSize(pSecHeader[nSecNum - 1].SizeOfRawData, dwSecAlignment);<br><br>    //节的属性（包含代码，可执行，可读）<br>    pTmpSec-&gt;Characteristics = IMAGE_SCN_CNT_CODE  IMAGE_SCN_MEM_EXECUTE  IMAGE_SCN_MEM_READ;<br><br>    //修正节的数量，自增1<br>    pNtHeader-&gt;FileHeader.NumberOfSections++;<br><br>    //修正映像大小<br>    pNtHeader-&gt;OptionalHeader.SizeOfImage += pTmpSec-&gt;Misc.VirtualSize;<br><br>    //保存当前的OEP<br>    DWORD dwOep = pNtHeader-&gt;OptionalHeader.ImageBase + pNtHeader-&gt;OptionalHeader.AddressOfEntryPoint;<br><br>    //修正代码长度<br>    pNtHeader-&gt;OptionalHeader.SizeOfCode += pTmpSec-&gt;SizeOfRawData;<br><br>    //修正程序的入口地址<br>    pNtHeader-&gt;OptionalHeader.AddressOfEntryPoint = pTmpSec-&gt;VirtualAddress;<br></code></pre></td></tr></table></figure>

<p>    <strong>Name</strong>是一个8Byte字符数组，可直接拷贝。</p>
<p>    <strong>VirtualAddress</strong>为节区加载如内存时的<strong>RVA</strong>，它应该符合<strong>SectionAlignment</strong>的对齐参数(例如 .text的VirAddr为1000h，下一个节区的大小就应该是 (VirAddr+SizeOfRawData)的向上取SectionAlignment的整数倍)</p>
<p>    而<strong>SizeOfRawData</strong>则也该符合<strong>FileAlignment</strong>整数倍向上取整对齐</p>
<p>    我们默认新节区中存放的内容均可被当作代码执行，因此<strong>SizeOfCode</strong>增加节区的<strong>SizeOfRawData</strong>大小</p>
<p>    节区属性通常是固定的值，暂时不需要考虑过多</p>
<p>    最后将Nt头中的<strong>SizeOfImage</strong>增加节区的<strong>VirtualSize</strong>大小，并保存当前的OEP，将OEP设置到新的节区，完成一个新节区头的初始化(下图为此时的文件状态，可以看见，010已经能够识别到新的节区头和新的节区位置了)</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529173549384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529173549384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<p>    那么接下来，我们就需要给这个尚且什么都没有的节区添加可执行代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">char shellcode[] =<br>&quot;\x33\xdb&quot;<br>&quot;\x53&quot;<br>&quot;\x68\x2e\x65\x78\x65&quot;<br>&quot;\x68\x48\x61\x63\x6b&quot;<br>&quot;\x8b\xc4&quot;<br>&quot;\x53&quot;<br>&quot;\x50&quot;<br>&quot;\xb8\x31\x32\x86\x7c&quot;<br>&quot;\x90\x90&quot;<br>&quot;\xb8\x90\x90\x90\x90&quot;<br>&quot;\xff\xe0\x90&quot;;<br><br>//增加节区数据 函数<br>void AddSectionData(int nSecSize)<br>&#123;<br>    PBYTE pByte = NULL;<br>    //申请用来添加数据的空间，这里需要减去ShellCode本身所占的空间<br>    pByte = (PBYTE)malloc(nSecSize - (strlen(shellcode) + 3));<br>    ZeroMemory(pByte, nSecSize - (strlen(shellcode) + 3));<br>    DWORD dwNum = 0;<br><br>    //令文件指针指向文件末尾，以准备添加数据<br>    SetFilePointer(hFile, 0, 0, FILE_END);<br>    //在文件的末尾写入ShellCode<br>    WriteFile(hFile, shellcode, strlen(shellcode) + 3, &amp;dwNum, NULL);<br>    //在ShellCode的末尾用00补充满<br>    WriteFile(hFile, pByte, nSecSize - (strlen(shellcode) + 3), &amp;dwNum, NULL);<br>    FlushFileBuffers(hFile);<br>    free(pByte);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>    申请一段空间，大小为 <strong>节区大小-shellcode</strong> 大小，并将内容置零</p>
<p>    向文件末尾写入<strong>shellcode</strong>，并多余补零将节区大小不充到之前设定好的<strong>SizeOfRawData</strong></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529175413943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529175413943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<p>    可以看见，新的节区也已经获得了数据，倘若现在将其放入Ollydbg中动态调试，我们将得到预期的结果，并且软件也能够正常运行。</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529175006595.png'><img src="https://img-blog.csdnimg.cn/20210529175006595.png">​<img src="blob:https://tokameine.top/c0fe5318-1cf3-4cd4-8421-d6d2c645bf72"></p>
<p>    倘若我们只需要一个<strong>“伪壳”</strong>，那么做到这一步已经足够了；但实际上，<strong>上面的操作和基础的Shellcode注入并没有什么不同</strong>。它远无法达到一个“壳”所要求的强度</p>
<p>   因此我们需要为它引入一个<strong>“代码加密模块”</strong>，只要没有运行完壳代码，源程序将无法运行(这里将只加密 .text 段)。但一旦加密，许许多多的问题就跟着来了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//异或加密 <br>   BYTE* content = (BYTE*)lpBase;<br>    content = content+pSecHeader-&gt;PointerToRawData;<br>    int SizeText = pSecHeader-&gt;SizeOfRawData;<br>    for (int i = 0;i&lt;SizeText; i++)<br>    &#123;<br>        *content ^= 0x0D;<br>        content++;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>    在添加节区之后，我们为代码增加这样一个模块。它将会把**.text段的每个Byte与0x0D异或**</p>
<p>    那么来看看这样做会导致什么问题吧</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529180055597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529180055597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<p>    可以发现，010的识别出现了严重的偏差，但这个问题似乎还不够具有冲击力，不妨试着放入Ollydbg动态调试一下？</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529180149621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529180149621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/0661797e-ef91-4529-947b-ddb501c326fa"></p>
<p>    可能你会好奇，我还没有写如解密的代码，不能运行难道不是很正常吗？</p>
<p>    但再回忆一下刚才的过程，程序的OEP应该是我们自己编写的Shellcode，它是没有经过加密的；也就是说，哪怕程序不能运行，它<strong>至少也应该能够执行到Shellcode结束的地方</strong>才对吧？</p>
<p>    再来看看这个错误**”0x0000005”**，常见原因为内存地址非法引用、越界等，从结论来说，因为内存的错误导致程序已经完全不能运行了(程序已损坏)</p>
<p><strong>那么接下来讨论一下这个问题的原因：</strong></p>
<p>    我们需要引入一个上面没有提到的概念——“导入表”，它就在<strong>OptionalHeader</strong>中的<strong>DataDirArray</strong>里</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/202105291818206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/202105291818206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<p>下图为导入表完整的结构顺序，方框代表结构体，文字表示一个地址</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529185445990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529185445990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​<img src="blob:https://tokameine.top/e7e264b0-e474-434f-b46f-36fd237532b7"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _IMAGE_DATA_DIRECTORY &#123;<br>    DWORD   VirtualAddress;<br>    DWORD   Size;<br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;<br>    union &#123;<br>        DWORD   Characteristics;            // 0 for terminating null import descriptor<br>        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)<br>    &#125; DUMMYUNIONNAME;<br>    DWORD   TimeDateStamp;                  // 0 if not bound,<br>                                            // -1 if bound, and real date\time stamp<br>                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)<br>                                            // O.W. date/time stamp of DLL bound to (Old BIND)<br><br>    DWORD   ForwarderChain;                 // -1 if no forwarders<br>    DWORD   Name;<br>    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)<br>&#125; IMAGE_IMPORT_DESCRIPTOR;<br>typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _IMAGE_THUNK_DATA32 &#123;<br>    union &#123;<br>        DWORD ForwarderString;      // PBYTE <br>        DWORD Function;             // PDWORD<br>        DWORD Ordinal;<br>        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME<br>    &#125; u1;<br>&#125; IMAGE_THUNK_DATA32;<br>typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">typedef struct _IMAGE_IMPORT_BY_NAME &#123;<br>    WORD    Hint;<br>    CHAR   Name[1];<br>&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br></code></pre></td></tr></table></figure>

<p>    当系统运行PE文件时，装载器将会通过这张导入表的<strong>IMAGE_IMPORT_BY_NAME</strong>来得知程序需要用到哪些外置函数，并将这些函数的地址写入<strong>FirstThunk(IAT)<strong>，于是你的程序就能够通过调用</strong>FirstThunk</strong>中储存的地址来调用函数</p>
<p>    那么，这些导入表被放在示范文件的哪些地方了？ <strong>.text</strong> 段</p>
<p>    所以原因也就清楚了，当装载器试图获取函数的时候，你告诉它的每一个地址都是错误的，程序自然就会因为错误的地址导致崩溃了</p>
<p>    所以，如果你尝试将<strong>IMAGE_DATA_DIRECTORY</strong>中的<strong>Size</strong>置零，或是将<strong>VirtualAddress</strong>置零，还或者是将<strong>IMAGE_IMPORT_DESCRIPTOR</strong>置零，你的程序都不会发生刚才的问题</p>
<p>    放入Ollydbg中就能发现，程序至少能够执行到shellcode处了</p>
<p>    但实际上，我们其是遇到的不应该是这样的程序</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/20210529190740142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70'><img src="https://img-blog.csdnimg.cn/20210529190740142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rva2FtZWluZQ==,size_16,color_FFFFFF,t_70">​</p>
<p>    上图为win7操作系统自带的<strong>计算器calc.exe</strong></p>
<p>    我们可以很明显的发现，它的<strong>导入表全都在 .rdata</strong>，这完美的避开了导入表被破坏的情况</p>
<p>    因此倘若我们对这个文件进行加壳的时候就不会出现因为导入表破坏的情况出现了</p>
<p><strong>后话：</strong></p>
<p>    这更像是一种偷懒的方式，因为我们不可能总能遇到这张刚刚好的程序(尽管版本较新的编译器都会把这些段明确区分开来了)。</p>
<p>    笔者查阅了各种各样的文章，最终只在思路上有所理解，却苦于实现有些困难</p>
<p>  《加密与解密》第19章给出了导入表抹去的一种思路：</p>
<p>    通过拷贝原导入表并抹去，将导入表写入新节区；在壳代码段中调用LoadLibray()与GetProcAddress()两个函数来模拟装载器生成导入表的操作，最后将获取的地址装回原导入表的IAT处实现表的重载和加密。</p>
<p>    但我翻阅了一些大佬的文章，均没有提及上述过程的具体流程，似乎都默认了IAT不会被加密这一事实，因此在这里留作一个疑问，哪天得到了答案再作补充吧。</p>
<p>    至于Shellcode的构造，这里不做赘述，笔者自己目前也并没有非常精通，还是不要误导他人为好。</p>
<p><strong>参考</strong>：</p>
<p> <strong>《加密与解密》</strong></p>
<p> <strong>九阳道人：</strong></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-250960.htm">https://bbs.pediy.com/thread-250960.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-251267.htm">https://bbs.pediy.com/thread-251267.htm</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2021/06/21/wustctf2020level3/">← 下一篇 WUSTCTF2020-level3 笔记与自省</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2021/05/14/gwctf-2019-xxor/">GWCTF 2019 - xxor 笔记与思考 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="/img/faction/6.png" alt="Logo"></a><h1 id="Dr"><a href="TokameinE">TokameinE</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/ErodedElk"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/1782544616"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>